<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">We introduce a new approach to semantics which combines the benefits of distributional and formal logical semantics.</S>
		<S sid ="2" ssid = "2">Distributional models have been successful in modelling the meanings of content words, but logical semantics is necessary to adequately represent many function words.</S>
		<S sid ="3" ssid = "3">We follow formal semantics in mapping language to logical representations, but differ in that the relational constants used are induced by offline distributional clustering at the level of predicate- argument structure.</S>
		<S sid ="4" ssid = "4">Our clustering algorithm is highly scalable, allowing us to run on corpora the size of Gigaword.</S>
		<S sid ="5" ssid = "5">Different senses of a word are disambiguated based on their induced types.</S>
		<S sid ="6" ssid = "6">We outperform a variety of existing approaches on a wide-coverage question answering task, and demonstrate the ability to make complex multi-sentence inferences involving quantifiers on the FraCaS suite.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="7" ssid = "7">Mapping natural language to meaning representations is a central challenge of NLP.</S>
			<S sid ="8" ssid = "8">There has been much recent progress in unsupervised distributional semantics, in which the meaning of a word is induced based on its usage in large corpora.</S>
			<S sid ="9" ssid = "9">This approach is useful for a range of key applications including question answering and relation extraction (Lin and Pantel, 2001; Poon and Domingos, 2009; Yao et al., 2011).</S>
			<S sid ="10" ssid = "10">Because such a semantics can be automically induced, it escapes the limitation of depending on relations from hand-built training data, knowledge bases or ontologies, which have proved of limited use in capturing the huge variety of meanings that can be expressed in language.</S>
			<S sid ="11" ssid = "11">However, distributional semantics has largely developed in isolation from the formal semantics literature.</S>
			<S sid ="12" ssid = "12">Whilst distributional semantics has been effective in modelling the meanings of content words such as nouns and verbs, it is less clear that it can be applied to the meanings of function words.</S>
			<S sid ="13" ssid = "13">Semantic operators, such as determiners, negation, conjunctions, modals, tense, mood, aspect, and plurals are ubiquitous in natural language, and are crucial for high performance on many practical applications— but current distributional models struggle to capture even simple examples.</S>
			<S sid ="14" ssid = "14">Conversely, computational models of formal semantics have shown low recall on practical applications, stemming from their reliance on ontologies such as WordNet (Miller, 1995) to model the meanings of content words (Bobrow et al., 2007; Bos and Markert, 2005).</S>
			<S sid ="15" ssid = "15">For example, consider what is needed to answer a question like Did Google buy YouTube?</S>
			<S sid ="16" ssid = "16">from the following sentences: 1.</S>
			<S sid ="17" ssid = "17">Google purchased YouTube.</S>
	</SECTION>
	<SECTION title="Google’s acquisition of YouTube. " number = "2">
			<S sid ="18" ssid = "1">4.</S>
			<S sid ="19" ssid = "2">YouTube may be sold to Google.</S>
			<S sid ="20" ssid = "3">5.</S>
			<S sid ="21" ssid = "4">Google will buy YouTube or Microsoft.</S>
			<S sid ="22" ssid = "5">6.</S>
			<S sid ="23" ssid = "6">Google didn’t takeover YouTube.</S>
			<S sid ="24" ssid = "7">All of these require knowledge of lexical semantics (e.g. that buy and purchase are synonyms), but some also need interpretation of quantifiers, negatives, modals and disjunction.</S>
			<S sid ="25" ssid = "8">It seems unlikely that 179 Transactions of the Association for Computational Linguistics, 1 (2013) 179–192.</S>
			<S sid ="26" ssid = "9">Action Editor: Johan Bos.</S>
			<S sid ="27" ssid = "10">Submitted 1/2013; Revised 3/2013; Published 5/2013.</S>
			<S sid ="28" ssid = "11">Oc 2013 Association for Computational Linguistics.</S>
			<S sid ="29" ssid = "12">distributional or formal approaches can accomplish the task alone.</S>
			<S sid ="30" ssid = "13">We propose a method for mapping natural language to first-order logic representations capable of capturing the meanings of function words such as every, not and or, but which also uses distributional statistics to model the meaning of content words.</S>
			<S sid ="31" ssid = "14">Our approach differs from standard formal semantics in that the non-logical symbols used in the logical form are cluster identifiers.</S>
			<S sid ="32" ssid = "15">Where standard semantic formalisms would map the verb write to a write’ symbol, we map it to a cluster identifier such as relation37, which the noun author may also map to.</S>
			<S sid ="33" ssid = "16">This mapping is learnt by offline clustering.</S>
			<S sid ="34" ssid = "17">Unlike previous distributional approaches, we perform clustering at the level of predicate-argument structure, rather than syntactic dependency structure.</S>
			<S sid ="35" ssid = "18">This means that we abstract away from many syntactic differences that are not present in the semantics, such as conjunctions, passives, relative clauses, and long-range dependencies.</S>
			<S sid ="36" ssid = "19">This significantly reduces sparsity, so we have fewer predicates to cluster and more observations for each.</S>
			<S sid ="37" ssid = "20">Of course, many practical inferences rely heavily on background knowledge about the world—such knowledge falls outside the scope of this work.</S>
			<S sid ="38" ssid = "21">2 Background.</S>
			<S sid ="39" ssid = "22">Our approach is based on Combinatory Categorial Grammar (CCG; Steedman, 2000), a strongly lexicalised theory of language in which lexical entries for words contain all language-specific information.</S>
			<S sid ="40" ssid = "23">The lexical entry for each word contains a syntactic category, which determines which other categories the word may combine with, and a semantic interpretation, which defines the compositional semantics.</S>
			<S sid ="41" ssid = "24">For example, the lexicon may contain the entry: write f- (S\NP)/NP : λ yλ x.write!(x, y) Crucially, there is a transparent interface between the syntactic category and the semantics.</S>
			<S sid ="42" ssid = "25">For example the transitive verb entry above defines the verb syntactically as a function mapping two noun- phrases to a sentence, and semantically as a binary relation between its two argument entities.</S>
			<S sid ="43" ssid = "26">This means that it is relatively straightforward to deterministically map parser output to a logical form, as in the Boxer system (Bos, 2008).</S>
			<S sid ="44" ssid = "27">This Every dog barks NP↑/N N S\NP λ pλ q.∀x[ p(x) =⇒ q(x)] λ x.dog!(x) λ x.bark!(x) &gt; NP↑ λ q.∀x[dog!(x) =⇒ q(x)] &gt; S ∀x[dog!(x) =⇒ bark!(x)] Figure 1: A standard logical form derivation using CCG.</S>
			<S sid ="45" ssid = "28">The NP↑ notation means that the subject is type-raised, and taking the verb-phrase as an argument—so is an abbreviation of S/(S\NP).</S>
			<S sid ="46" ssid = "29">This is necessary in part to sup port a correct semantics for quantifiers.</S>
			<S sid ="47" ssid = "30">Input Sentence Shakespeare wrote Macbeth ⇓ Intial semantic analysis writearg0,arg1(shakespeare, macbeth) ⇓ Entity Typing writearg0:PE R,arg1:BOOK (shakespeare:PER, macbeth:BOOK) ⇓ Distributional semantic analysis relation37(shakespeare:PER, macbeth:BOOK) Figure 2: Layers used in our model.</S>
			<S sid ="48" ssid = "31">form of semantics captures the underlying predicate- argument structure, but fails to license many important inferences—as, for example, write and author do not map to the same predicate.</S>
			<S sid ="49" ssid = "32">In addition to the lexicon, there is a small set of binary combinators and unary rules, which have a syntactic and semantic interpretation.</S>
			<S sid ="50" ssid = "33">Figure 1 gives an example CCG derivation.</S>
	</SECTION>
	<SECTION title="Overview of Approach. " number = "3">
			<S sid ="51" ssid = "1">We attempt to learn a CCG lexicon which maps equivalent words onto the same logical form—for example learning entries such as: author f- N/PP[o f ] : λ xλ y.relation37(x, y) write f- (S\NP)/NP : λ xλ y.relation37(x, y) The only change to the standard CCG derivation is that the symbols used in the logical form are arbitrary relation identifiers.</S>
			<S sid ="52" ssid = "2">We learn these by first mapping to a deterministic logical form (using predicates such as author’ and write’), using a process similar to Boxer, and then clustering predicates based on their arguments.</S>
			<S sid ="53" ssid = "3">This lexicon can then be used to parse new sentences, and integrates seamlessly with CCG theories of formal semantics.</S>
			<S sid ="54" ssid = "4">Typing predicates—for example, determining that writing is a relation between people and books— has become standard in relation clustering (Schoenmackers et al., 2010; Berant et al., 2011; Yao et al., 2012).</S>
			<S sid ="55" ssid = "5">We demonstate how to build a typing model into the CCG derivation, by subcategorizing all terms representing entities in the logical form with a more detailed type.</S>
			<S sid ="56" ssid = "6">These types are also induced from text, as explained in Section 5, but for convenience we describe them with human-readable labels, such as PER, LOC and BOOK.</S>
			<S sid ="57" ssid = "7">A key advantage of typing is that it allows us to model ambiguous predicates.</S>
			<S sid ="58" ssid = "8">Following Berant et al.</S>
			<S sid ="59" ssid = "9">(2011), we assume that different type signatures of the same predicate have different meanings, but given a type signature a predicate is unambiguous.</S>
			<S sid ="60" ssid = "10">For example a different lexical entry for the verb born is used in the contexts Obama was born in Hawaii and Obama was born in 1961, reflecting a distinction in the semantics that is not obvious in the syntax1.</S>
			<S sid ="61" ssid = "11">Typing also greatly improves the efficiency of clustering, as we only need to compare predicates with the same type during clustering (for example, we do not have to consider clustering a predicate between people and places with predicates between people and dates).</S>
			<S sid ="62" ssid = "12">In this work, we focus on inducing binary relations.</S>
			<S sid ="63" ssid = "13">Many existing approaches have shown how to produce good clusterings of (nonevent) nouns (Brown et al., 1992), any of which could be simply integrated into our semantics—but relation clustering remains an open problem (see Section 9).</S>
			<S sid ="64" ssid = "14">Nary relations are binarized, by creating a binary relation between each pair of arguments.</S>
			<S sid ="65" ssid = "15">For example, for the sentence Russia sold Alaska to the United States, the system creates three binary relations— corresponding to sellToSomeone(Russia, Alaska), buyFromSomeone(US, Alaska), sellSomethingTo(Russia, US).</S>
			<S sid ="66" ssid = "16">This transformation does not 1Whilst this assumption is very useful, it does not always hold— for example, the genitive in Shakespeare’s book is ambiguous between ownership and authorship relations even given the types of the arguments.</S>
			<S sid ="67" ssid = "17">exactly preserve meaning, but still captures the most important relations.</S>
			<S sid ="68" ssid = "18">Note that this allows us to compare semantic relations across different syntactic types—for example, both transitive verbs and argument-taking nouns can be seen as expressing binary semantic relations between entities.</S>
			<S sid ="69" ssid = "19">Figure 2 shows the layers used in our model.</S>
	</SECTION>
	<SECTION title="Initial Semantic Analysis. " number = "4">
			<S sid ="70" ssid = "1">The initial semantic analysis maps parser output onto a logical form, in a similar way to Boxer.</S>
			<S sid ="71" ssid = "2">The semantic formalism is based on Steedman (2012).</S>
			<S sid ="72" ssid = "3">The first step is syntactic parsing.</S>
			<S sid ="73" ssid = "4">We use the C&amp;C parser (Clark and Curran, 2004), trained on CCGBank (Hockenmaier and Steedman, 2007), using the refined version of Honnibal et al.</S>
			<S sid ="74" ssid = "5">(2010) which brings the syntax closer to the predicate- argument structure.</S>
			<S sid ="75" ssid = "6">An automatic post-processing step makes a number of minor changes to the parser output, which converts the grammar into one more suitable for our semantics.</S>
			<S sid ="76" ssid = "7">PP (prepositional phrase) and PR (phrasal verb complement) categories are sub-categorised with the relevant preposition.</S>
			<S sid ="77" ssid = "8">Noun compounds with the same MUC named-entity type (Chinchor and Robinson, 1997) are merged into a single non-compositional node2 (we otherwise ignore named-entity types).</S>
			<S sid ="78" ssid = "9">All argument NPs and PPs are type-raised, allowing us to represent quantifiers.</S>
			<S sid ="79" ssid = "10">All prepositional phrases are treated as core arguments (i.e. given the category PP, not adjunct cat egories like (N\N)/NP or ((S\NP)\(S\NP))/NP),as it is difficult for the parser to distinguish argu ments and adjuncts.</S>
			<S sid ="80" ssid = "11">Initial semantic lexical entries for almost all words can be generated automatically from the syntactic category and POS tag (obtained from the parser), as the syntactic category captures the underlying predicate-argument structure.</S>
			<S sid ="81" ssid = "12">We use a Davidsonian-style representation of arguments (Davidson, 1967), which we binarize by creating a separate predicate for each pair of arguments of a word.</S>
			<S sid ="82" ssid = "13">These predicates are labelled with the lemma of the head word and a Propbank-style argument key (Kingsbury and Palmer, 2002), e.g. arg0, argIn.</S>
			<S sid ="83" ssid = "14">We distinguish noun and verb predicates based on POS 2For example, this allows us to give Barack Obama the semantics λ x.barack obama(x) instead of λ x.barack(x) ∧ obama(x), which is more convenient for collecting distributional statistics.</S>
			<S sid ="84" ssid = "15">W or d C at eg or y S e m an tic s A ut o m ati c au th or wr ite N / P P [ o f ] ( S \ N P ) / N P λ xλ y. au th or arg 0,ar gOf (y, x) λ xλ y. wr ite arg 0,a rg1 (y, x) M an ua l ev er y no t N P↑ /N (S \ N P) /( S\ N P) λ pλ q. ∀x [ p( x) → q( x)] λ pλ x. p( x) Figure 3: Example initial lexical entries tag—so, for example, we have different predicates for effect as a noun or verb.</S>
			<S sid ="85" ssid = "16">This algorithm can be overridden with manual lexical entries for specific closed-class function words.</S>
			<S sid ="86" ssid = "17">Whilst it may be possible to learn these from data, our approach is pragmatic as there are relatively few such words, and the complex logical forms required would be difficult to induce from dis- tributional statistics.</S>
			<S sid ="87" ssid = "18">We add a small number of lexical entries for words such as negatives (no, not etc.), and quantifiers (numbers, each, every, all, etc.).</S>
			<S sid ="88" ssid = "19">Some example initial lexical entries are shown in Figure 3.</S>
	</SECTION>
	<SECTION title="Entity Typing Model. " number = "5">
			<S sid ="89" ssid = "1">Our entity-typing model assigns types to nouns, which is useful for disambiguating polysemous predicates.</S>
			<S sid ="90" ssid = "2">Our approach is similar to O’Seaghdha (2010) in that we aim to cluster entities based on the noun and unary predicates applied to them (it is simple to convert from the binary predicates to unary predicates).</S>
			<S sid ="91" ssid = "3">For example, we want the pair (bornargIn, 1961) to map to a DAT type, and (bornargIn, Hawaii) to map to a LOC type.</S>
			<S sid ="92" ssid = "4">This is nontrivial, as both the predicates and arguments can be ambiguous between multiple types—but topic models offer a good solution (described below).</S>
			<S sid ="93" ssid = "5">5.1 Topic Model.</S>
			<S sid ="94" ssid = "6">We assume that the type of each argument of a predicate depends only on the predicate and argument, although Ritter et al.</S>
			<S sid ="95" ssid = "7">(2010) demonstrate an advantage of modelling the joint probability of the types of multiple arguments of the same predicate.</S>
			<S sid ="96" ssid = "8">We use the standard Latent Dirichlet Allocation model (Blei et al., 2003), which performs comparably to more complex models proposed in O’Seaghdha (2010).</S>
			<S sid ="97" ssid = "9">In topic-modelling terminology, we construct a document for each unary predicate (e.g. bornargIn), based on all of its argument entities (words).</S>
			<S sid ="98" ssid = "10">We assume that these arguments are drawn from a small number of types (topics), such as PER, DAT or LOC3.</S>
			<S sid ="99" ssid = "11">Each type j has a multinomial distribution φ j over arguments (for example, a LOC type is more likely to generate Hawaii than 1961).</S>
			<S sid ="100" ssid = "12">Each unary predicate i has a multinomial distribution θi over topics, so the bornargIn predicate will normally generate a DAT or LOC type.</S>
			<S sid ="101" ssid = "13">Sparse Dirichlet priors α and β on the multinomials bias the distributions to be peaky.</S>
			<S sid ="102" ssid = "14">The parameters are estimated by Gibbs sampling, using the Mallet implementation (McCallum, 2002).</S>
			<S sid ="103" ssid = "15">The generative story to create the data is: For every type k: Draw the p(arg|k) distribution φk from Dir(β ) For every unary predicate i: Draw the p(ty pe|i) distribution θi from Dir(α ) For every argument j: Draw a type zi j from Mult(θi) Draw an argument wi j from Mult(φθi ) 5.2 Typing in Logical Form.</S>
			<S sid ="104" ssid = "16">In the logical form, all constants and variables representing entities x can be assigned a distribution over types px(t) using the type model.</S>
			<S sid ="105" ssid = "17">An initial type distribution is applied in the lexicon, using the φ distributions for the types of nouns, and the θi distributions for the type of arguments of binary predicates (inverted using Bayes’ rule).</S>
			<S sid ="106" ssid = "18">Then at each β - reduction in the derivation, we update probabilities of the types to be the product of the type distributions of the terms being reduced.</S>
			<S sid ="107" ssid = "19">If two terms x and 3Types are induced from the text, but we give human-readable labels here for convenience.</S>
			<S sid ="108" ssid = "20">file a suit (S\NP)/NP NP↑ DOC = 0.5 ) PER = 0.7 ) CLOTHES = 0.6 ) λ y : L E G A L = 0.</S>
			<S sid ="109" ssid = "21">4 CLOT HES = 0.01 . . .</S>
			<S sid ="110" ssid = "22">λ x : ORG = 0.2 . . .</S>
			<S sid ="111" ssid = "23">f ilearg0 ,arg1 (x, y) λ p.∃y : S \ N P LEGA L = 0.3 DOC = 0.001 . . .</S>
			<S sid ="112" ssid = "24">[suit!</S>
			<S sid ="113" ssid = "25">(y) ∧ p(y)] &lt; λ x : PER = 0.7 ORG = 0.2 ...</S>
			<S sid ="114" ssid = "26">) ∃y : LEGAL = 0.94 CLOTHES = 0.05 DOC = 0.004 ...</S>
			<S sid ="115" ssid = "27">) )[suit!(y) ∧ f ilearg0,arg1 (x, y)] Figure 4: Using the type model for disambiguation in the derivation of file a suit.</S>
			<S sid ="116" ssid = "28">Type distributions are shown after the variable declarations.</S>
			<S sid ="117" ssid = "29">Both suit and the object of file are lexically ambiguous between different types, but after the β -reduction only one interpretation is likely.</S>
			<S sid ="118" ssid = "30">If the verb were wear, a different interpretation would be preferred.</S>
			<S sid ="119" ssid = "31">y combine to a term z: pz(t) = px(t) py(t) ∑ t!</S>
			<S sid ="120" ssid = "32">px(t!) py(t!) The entity-pair counts for authorarg0:PER,argOf :BOOK may be similar, on the assumption that both are samples from the same underlying semantic relation.</S>
			<S sid ="121" ssid = "33">To find the expected number of occurrences of For example, in wore a suit and file a suit, the variable representing suit may be lexically ambiguous between CLOTHES and LEGAL types, but the variables representing the objects of wear and f ile will have preferences that allow us to choose the correct type when the terms combine.</S>
			<S sid ="122" ssid = "34">Figure 4 shows an example derivation using the type model for disambiguation4.</S>
	</SECTION>
	<SECTION title="Distributional Relation Clustering. " number = "6">
			<S sid ="123" ssid = "1">Model The typed binary predicates can be grouped into clusters, each of which represents a distinct semantic relation.</S>
			<S sid ="124" ssid = "2">Note that because we cluster typed predicates, bornarg0:PE R,argIn:LOC and bornarg0:PE R,argIn:DAT can be clustered separately.</S>
			<S sid ="125" ssid = "3">6.1 Corpus statistics.</S>
			<S sid ="126" ssid = "4">Typed binary predicates are clustered based on the expected number of times they hold between each argument-pair in the corpus.</S>
			<S sid ="127" ssid = "5">This means we create a single vector of argument-pair counts for each predicate (not a separate vector for each argument).</S>
			<S sid ="128" ssid = "6">For example, the vector for the typed predicate writearg0:PE R,arg1:BOOK may contain nonzero counts for entity-pairs such as (Shakespeare, Macbeth), (Dickens, Oliver Twist) and (Rowling, Harry Potter).</S>
			<S sid ="129" ssid = "7">4Our implementation follows Steedman (2012) in using Generalized Skolem Terms rather than existential quantifiers, in order to capture quantifier scope alternations monotonically, but we omit these from the example to avoid introducing new notation.</S>
			<S sid ="130" ssid = "8">argument-pairs for typed binary predicates in a corpus, we first apply the type model to the derivation of each sentence, as described in Section 5.2.</S>
			<S sid ="131" ssid = "9">This outputs untyped binary predicates, with distributions over the types of their arguments.</S>
			<S sid ="132" ssid = "10">The type of the predicate must match the type of its arguments, so the type distribution of a binary predicate is simply the joint distribution of the two argument type distributions.</S>
			<S sid ="133" ssid = "11">For example, if the arguments in a bornarg0,argIn(obama, hawaii) derivation have the respective type distributions (PER=0.9, LOC=0.1) and (LOC=0.7, DAT=0.3), the distribution over binary typed predicates is (bornarg0:PE R,argIn:LOC =0.63, bornarg0:PE R,argIn:DAT =0.27, etc.) The expected counts for (obama, hawaii) in the vectors for bornarg0:PE R,argIn:LOC and bornarg0:PE R,argIn:DAT are then incremented by these probabilities.</S>
			<S sid ="134" ssid = "12">6.2 Clustering.</S>
			<S sid ="135" ssid = "13">Many algorithms have been proposed for clustering predicates based on their arguments (Poon and Domingos, 2009; Yao et al., 2012).</S>
			<S sid ="136" ssid = "14">The number of relations in the corpus is unbounded, so the clustering algorithm should be non-parametric.</S>
			<S sid ="137" ssid = "15">It is also important that it remains tractable for very large numbers of predicates and arguments, in order to give us a greater coverage of language than can be achieved by hand-built ontologies.</S>
			<S sid ="138" ssid = "16">We cluster the typed predicate vectors using the Chinese Whispers algorithm (Biemann, 2006)— although somewhat ad-hoc, it is both non-parametric and highly scalable5.</S>
			<S sid ="139" ssid = "17">This has previously been used for noun-clustering by Fountain and Lapata (2011), who argue it is a cognitively plausible model for language acquisition.</S>
			<S sid ="140" ssid = "18">The collection of predicates and arguments is converted into a graph with one node per predicate, and edge weights representing the similarity between predicates.</S>
			<S sid ="141" ssid = "19">Predicates with different types have zero-similarity, and otherwise similarity is computed as the cosine-similarity of the tfidf vectors of argument-pairs.</S>
			<S sid ="142" ssid = "20">We prune nodes occurring fewer than 20 times, edges with weights less be untyped), we perform a deterministic lookup in the cluster model learned in Section 6, using all possible corresponding typed predicates.</S>
			<S sid ="143" ssid = "21">This allows us to represent the binary predicates as packed predicates: functions from argument types to relations.</S>
			<S sid ="144" ssid = "22">For example, if the clustering maps bornarg0:PE R,argIn:LOC to rel49 (“birthplace”) and bornarg0:PE R,argIn:DAT to rel53 (“birthdate”), our lexicon contains the following packed lexical entry (type-distributions on the variables are suppressed): born f- (S\NP)/PP[in] : ) than 10−3, and a short list of stop predicates.</S>
			<S sid ="145" ssid = "23">The algorithm proceeds as follows: λ yλ x.</S>
			<S sid ="146" ssid = "24">(x : PER, y : LOC) ⇒ rel49 (x : PER, y : DAT ) ⇒ rel53 (x, y) 1.</S>
			<S sid ="147" ssid = "25">Each predicate p is assigned to a different se-.</S>
			<S sid ="148" ssid = "26">mantic relation rp 2.</S>
			<S sid ="149" ssid = "27">Iterate over the predicates p in a random order.</S>
			<S sid ="150" ssid = "28">3.</S>
			<S sid ="151" ssid = "29">Set rp = arg max ∑p! ✶r=rp!</S>
			<S sid ="152" ssid = "30">sim( p, p!), where.</S>
			<S sid ="153" ssid = "31">rsim( p, p!)</S>
			<S sid ="154" ssid = "32">is the distributional similarity be tween p and p!, and ✶r=r! is 1 iff r=r’ and 0 otherwise.</S>
			<S sid ="155" ssid = "33">4.</S>
			<S sid ="156" ssid = "34">Repeat (2.) to convergence..</S>
			<S sid ="157" ssid = "35">The distributions over argument types then imply a distribution over relations.</S>
			<S sid ="158" ssid = "36">For example, if the packed-predicate for bornarg0,argIn is applied to arguments Obama and Hawaii, with respective type distributions (PER=0.9, LOC=0.1) and (LOC=0.7, DAT=0.3)6, the distribution over relations will be (rel49=0.63, rel53=0.27, etc.).</S>
			<S sid ="159" ssid = "37">If 1961 has a type-distribution (LOC=0.1, DAT=0.9), the output packed-logical form for Obama was born in Hawaii in 1961 will be:</S>
	</SECTION>
	<SECTION title="Semantic Parsing using Relation. " number = "7">
			<S sid ="160" ssid = "1">rel49=0.63 rel49=0.09     Clusters rel53=0.27 (ob, hw) ∧ rel53=0.81 (ob, 1961)  The final phase is to use our relation clusters in the ...   ...  lexical entries of the CCG semantic derivation.</S>
			<S sid ="161" ssid = "2">This is slightly complicated by the fact that our predicates are lexically ambiguous between all the possible types they could take, and hence the relations they could express.</S>
			<S sid ="162" ssid = "3">For example, the system cannot tell whether born in is expressing a birthplace or birthdate relation until later in the derivation, when it combines with its arguments.</S>
			<S sid ="163" ssid = "4">However, all the possible logical forms are identical except for the symbols used, which means we can produce a packed logical form capturing the full distribution over logical forms.</S>
			<S sid ="164" ssid = "5">To do this, we make the predicate a function from argument types to relations.</S>
			<S sid ="165" ssid = "6">For each word, we first take the lexical semantic definition produced by the algorithm in Section 4.</S>
			<S sid ="166" ssid = "7">For binary predicates in this definition (which will 5We also experimented with a Dirichlet Process Mixture Model (Neal, 2000), but even with the efficient A* search algorithms introduced by Daume´ III (2007), the cost of inference was found to be prohibitively high when run at large scale.</S>
			<S sid ="167" ssid = "8">The probability of a given logical form can be read from this packed logical form.</S>
	</SECTION>
	<SECTION title="Experiments. " number = "8">
			<S sid ="168" ssid = "1">Our approach aims to offer a strong model of both formal and lexical semantics.</S>
			<S sid ="169" ssid = "2">We perform two evaluations, aiming to target each of these separately, but using the same semantic representations in each.</S>
			<S sid ="170" ssid = "3">We train our system on Gigaword (Graff et al., 2003), which contains around 4 billion words of newswire.</S>
			<S sid ="171" ssid = "4">The type-model is trained using 15 types7, and 5,000 iterations of Gibbs sampling (using the distributions from the final sample).</S>
			<S sid ="172" ssid = "5">Table 1 6These distributions are composed from the type-distributions for both the predicate and argument, as explained in Section 5 7This number was chosen by examination of models trained with different numbers of types.</S>
			<S sid ="173" ssid = "6">The algorithm produces semantically coherent clusters for much larger numbers of types, but many of these are fine-grained categories of people, which introduces sparsity in the relation clustering.</S>
			<S sid ="174" ssid = "7">Ty pe To p W or ds 1 2 5 8 10 s u s p e c t, a s s a il a n t, f u g it i v e , a c c o m p li c e a u t h o r , s i n g e r , a c t r e s s , a c t o r , d a d ci ty , ar e a, c o u nt ry , re gi o n, to w n, c a pi t al s u b si di ar y, a ut o m a k er , ai rli n e, C o. , G M m u si c al , t h ril le r, s e q u el , s p e ci al Table 1: Most probable terms in some clusters induced by the Type Model.</S>
			<S sid ="175" ssid = "8">shows some example types.</S>
			<S sid ="176" ssid = "9">The relation clustering uses only proper nouns, to improve precision (sparsity problems are partly offset by the large input corpus).</S>
			<S sid ="177" ssid = "10">Aside from parsing, the pipeline takes around a day to run using 12 cores.</S>
			<S sid ="178" ssid = "11">8.1 Question Answering Experiments.</S>
			<S sid ="179" ssid = "12">As yet, there is no standard way of evaluating lexical semantics.</S>
			<S sid ="180" ssid = "13">Existing tasks like Recognising Textual Entailment (RTE; Dagan et al., 2006) rely heavily on background knowledge, which is beyond the scope of this work.</S>
			<S sid ="181" ssid = "14">Intrinsic evaluations of entailment relations have low inter-annotator agreement (Szpektor et al., 2007), due to the difficulty of evaluating relations out of context.</S>
			<S sid ="182" ssid = "15">Our evaluation is based on that performed by Poon and Domingos (2009).</S>
			<S sid ="183" ssid = "16">We automatically construct a set of questions by sampling from text, and then evaluate how many answers can be found in a different corpus.</S>
			<S sid ="184" ssid = "17">From dependency-parsed answers to the same question (e.g. What did Google buy?</S>
			<S sid ="185" ssid = "18">may have many valid answers), and all of these contribute to the result.</S>
			<S sid ="186" ssid = "19">As none of the systems model tense or temporal semantics, annotators were instructed to annotate answers as correct if they were true at any time.</S>
			<S sid ="187" ssid = "20">This approach means we evaluate on relations in proportion to corpus frequency.</S>
			<S sid ="188" ssid = "21">We sample 1000 questions from the New York Times subset of Gigaword from 2010, and search for answers in the New York Times from 2009.</S>
			<S sid ="189" ssid = "22">We evaluate the following approaches: • CCG-Baseline The logical form produced by our CCG derivation, without the clustering.</S>
			<S sid ="190" ssid = "23">• CCGWordNet The CCG logical form, plus WordNet as a model of lexical semantics.</S>
			<S sid ="191" ssid = "24">• CCGDistributional The logical form including the type model and clusters.</S>
			<S sid ="192" ssid = "25">• Relational LDA An LDA based model for clustering dependency paths (Yao et al., 2011).</S>
			<S sid ="193" ssid = "26">We train on New York Times subset of Gigaword9, using their setup of 50 iterations with 100 relation types.</S>
			<S sid ="194" ssid = "27">• Reverb A sophisticated Open Information Extraction system (Fader et al., 2011).</S>
			<S sid ="195" ssid = "28">Unsupervised Semantic Parsing (USP; Poon and Domingos, 2009; USP; Poon and Domingos, 2010; USP; Titov and Klementiev, 2011) would be another nsub j dob j nsub j newswire, we sample either X ← verb → Y, X ← obvious baseline.</S>
			<S sid ="196" ssid = "29">However, memory requirements pob j nsub j dob j pob j verb → Y or X ← be → noun → Y patterns, mean it is not possible to run at this scale (our system where X and Y are proper nouns and the verb is not on a list of stop verbs, and deterministically convert these to questions.</S>
			<S sid ="197" ssid = "30">For example, from Google bought YouTube we create the questions What did Google buy?</S>
			<S sid ="198" ssid = "31">and What bought YouTube?.</S>
			<S sid ="199" ssid = "32">The task is to find proper-noun answers to these questions in a different corpus, which are then evaluated by human annotators based on the sentence the answer was retrieved from8.</S>
			<S sid ="200" ssid = "33">Systems can return multiple 8Common nouns are filtered automatically.</S>
			<S sid ="201" ssid = "34">To focus on evaluating the semantics, annotators ignored garbled sentences due to errors pre-processing the corpus (these are excluded from the results).</S>
			<S sid ="202" ssid = "35">We also automatically exclude weekday and month answers, which are overwhelmingly syntax errors for all systems—e.g. treating Tuesday as an object in Obama announced Tuesday that... is trained on 4 orders of magnitude more data than the USP evaluation).</S>
			<S sid ="203" ssid = "36">Yao et al.</S>
			<S sid ="204" ssid = "37">(2011) found it had comparable performance to Relational LDA.</S>
			<S sid ="205" ssid = "38">For the CCG models, rather than performing full first-order inference on a large corpus, we simply test whether the question predicate subsumes a candidate answer predicate, and whether the arguments match10.</S>
			<S sid ="206" ssid = "39">In the case of CCGDistributional, we calculate the probability that the two packed-predicates 9This is around 35% of Gigaword, and was the largest scale possible on our resources.</S>
			<S sid ="207" ssid = "40">10We do this as it is much more efficient than full first-order theorem-proving.</S>
			<S sid ="208" ssid = "41">We could in principle make additional inferences with theorem-proving, such as answering What did Google buy?</S>
			<S sid ="209" ssid = "42">from Google bought the largest video website and YouTube is the largest video website.</S>
			<S sid ="210" ssid = "43">S ys te m An sw er s C or re ct R el ati onal L D A R ev er b C CG B as eli ne C CG W or d N et C CG Di str ib uti on al @ 25 0 C CG Di str ib uti on al @ 50 0 70 46 18 0 20 3 21 1 25 0 50 0 11 .6 % 89 .4 % 95 .8 % 94 .8 % 94 .1 % 82 .0 % Table 2: Results on wide-coverage Question Answering task.</S>
			<S sid ="211" ssid = "44">CCGDistributional ranks question/answer pairs by confidence—@250 means we evaluate the top 250 of these.</S>
			<S sid ="212" ssid = "45">It is not possible to give a recall figure, as the total number of correct answers in the corpus is unknown.</S>
			<S sid ="213" ssid = "46">are in the same cluster, marginalizing over their argument types.</S>
			<S sid ="214" ssid = "47">Answers are ranked by this probability.</S>
			<S sid ="215" ssid = "48">For CCGWordNet, we check if the question predicate is a hypernym of the candidate answer predicate (using any WordNet sense of either term).</S>
			<S sid ="216" ssid = "49">Results are shown in Table 2.</S>
			<S sid ="217" ssid = "50">Relational-LDA induces many meaningful clusters, but predicates must be assigned to one of 100 relations, so results are dominated by large, noisy clusters (it is not possible to take the N-best answers as the cluster assignments do not have a confidence score).</S>
			<S sid ="218" ssid = "51">The CCG- Baseline errors are mainly caused by parser errors, or relations in the scope of non-factive operators.</S>
			<S sid ="219" ssid = "52">CCGWordNet adds few answers to CCG-Baseline, reflecting the limitations of hand-built ontologies.</S>
			<S sid ="220" ssid = "53">CCGDistributional substantially improves recall over other approaches whilst retaining good precision, demonstrating that we have learnt a powerful model of lexical semantics.</S>
			<S sid ="221" ssid = "54">Table 3 shows some correctly answered questions.</S>
			<S sid ="222" ssid = "55">The system improves over the baseline by mapping expressions such as merge with and acquisition of to the same relation cluster.</S>
			<S sid ="223" ssid = "56">Many of the errors are caused by conflating predicates where the entailment only holds in one direction, such as was elected to with ran for.</S>
			<S sid ="224" ssid = "57">Hierarchical clustering could be used to address this.</S>
			<S sid ="225" ssid = "58">8.2 Experiments on the FraCaS Suite.</S>
			<S sid ="226" ssid = "59">We are also interested in evaluating our approach as a model of formal semantics—demonstrating that it is possible to integrate the formal semantics of Steedman (2012) with our distributional clusters.</S>
			<S sid ="227" ssid = "60">The FraCaS suite (Cooper et al., 1996)11 contains a hand-built set of entailment problems designed to be challenging in terms of formal semantics.</S>
			<S sid ="228" ssid = "61">We use Section 1, which contains 74 problems requiring an understanding of quantifiers12.</S>
			<S sid ="229" ssid = "62">They do not require any knowledge of lexical semantics, meaning we can evaluate the formal component of our system in isolation.</S>
			<S sid ="230" ssid = "63">However, we use the same representations as in our previous experiment, even though the clusters provide no benefit on this task.</S>
			<S sid ="231" ssid = "64">Figure 5 gives an example problem.</S>
			<S sid ="232" ssid = "65">The only previous work we are aware of on this dataset is by MacCartney and Manning (2007).</S>
			<S sid ="233" ssid = "66">This approach learns the monotonicity properties of words from a hand-built training set, and uses this to transform a sentence into a polarity annotated string.</S>
			<S sid ="234" ssid = "67">The system then aims to transform the premise string into a hypothesis.</S>
			<S sid ="235" ssid = "68">Positively polarized words can be replaced with less specific ones (e.g. by deleting adjuncts), whereas negatively polarized words can be replaced with more specific ones (e.g. by adding adjuncts).</S>
			<S sid ="236" ssid = "69">Whilst this is high- precision and often useful, this logic is unable to perform inferences with multiple premise sentences (in contrast to our first-order logic).</S>
			<S sid ="237" ssid = "70">Development consists of adding entries to our lexicon for quantifiers.</S>
			<S sid ="238" ssid = "71">For simplicity, we treat multi- word quantifiers like at least a few, as being multi- word expressions—although a more compositional analysis may be possible.</S>
			<S sid ="239" ssid = "72">Following MacCartney and Manning (2007), we do not use held-out data— each problem is designed to test a different issue, so it is not possible to generalize from one subset of the suite to another.</S>
			<S sid ="240" ssid = "73">As we are interested in evaluating the semantics, not the parser, we manually supply gold-standard lexical categories for sentences with parser errors (any syntactic mistake causes incorrect semantics).</S>
			<S sid ="241" ssid = "74">Our derivations produce a distribution over logical forms—we license the inference if it holds in any interpretation with nonzero probability.</S>
			<S sid ="242" ssid = "75">We use the Prover9 (McCune, 2005) theorem prover for inference, returning yes if the premise implies the hypothesis, no if it implies the negation of the hypothesis, and unknown otherwise.Results are shown in Table 4.</S>
			<S sid ="243" ssid = "76">Our system im 11We use the version converted to machine readable format by MacCartney and Manning (2007) 12Excluding 6 problems without a defined solution.</S>
			<S sid ="244" ssid = "77">Q ue sti o n A ns w er S en te nc e W ha t di d De lta m er ge wi th ? W ha t sp ok e wi th H u Ji nt ao ? W h a t a r r i v e d i n C o l o r a d o ? W h a t r a n f o r C o n g r e s s ? N ort h w es t O ba m a Za zi Yo un g Th e 74 7 fre ig ht er s ca m e wi th D elt a’s ac qu isit io n of N ort h w es t O b a m a c o n v e y e d h i s r e s p e c t f o r t h e D a l a i L a m a t o C h i n a ’ s p r e s i d e n t H u J i n t a o d u r i n g t h e i r f i r s t m e e t i n g . . .</S>
			<S sid ="245" ssid = "78">Za zi fle w ba ck to Co lor ad o. . . .</S>
			<S sid ="246" ssid = "79">Yo un g wa s el ec te d to Co ng re ss in 19 72 Table 3: Example questions correctly answered by CCGDistributional.</S>
			<S sid ="247" ssid = "80">Pr e mi se s: Ev er y Eu ro pe an ha s th e rig ht to liv e in E ur op e. Ev er y Eu ro pe an is a pe rs on . Ev er y pe rs on wh o ha s th e rig ht to liv e in Eu ro pe ca n tra vel fre ely wi thi n E ur op e. Hy po th es is: Ev er y Eu ro pe an ca n tra vel fre ely wi thi n E ur op e S ol ut io n: Ye s Figure 5: Example problem from the FraCaS suite.</S>
			<S sid ="248" ssid = "81">Sy ste m Si n gl e Pr emi se M ult ipl e Pr emi ses Ma cC art ne y&amp; Ma nni ng 07 Ma cC art ne y&amp; Ma nni ng 08 C CG Di st (p ar se r sy nt ax ) C CG Di st (g ol d sy nt ax ) 8 4 % 9 8 % 7 0 % 8 9 % 5 0 % 8 0 % Table 4: Accuracy on Section 1 of the FraCaS suite.</S>
			<S sid ="249" ssid = "82">Problems are divided into those with one premise sentence (44) and those with multiple premises (30).</S>
			<S sid ="250" ssid = "83">proves on previous work by making multi-sentence inferences.</S>
			<S sid ="251" ssid = "84">Causes of errors include missing a distinct lexical entry for plural the, only taking existential interpretations of bare plurals, failing to interpret mass-noun determiners such as a lot of, and not providing a good semantics for non-monotone determiners such as most.</S>
			<S sid ="252" ssid = "85">We believe these problems will be surmountable with more work.</S>
			<S sid ="253" ssid = "86">Almost all errors are due to incorrectly predicting unknown — the system makes just one error on yes or no predictions (with or without gold syntax).</S>
			<S sid ="254" ssid = "87">This suggests that making first-order logic inferences in applications will not harm precision.</S>
			<S sid ="255" ssid = "88">We are less robust than MacCartney and Manning (2007) to syntax errors but, conversely, we are able to attempt more of the problems (i.e. those with multi-sentence premises).</S>
			<S sid ="256" ssid = "89">Other approaches based on distributional semantics seem unable to tackle any of these problems, as they do not represent quantifiers or negation.</S>
	</SECTION>
	<SECTION title="Related. " number = "9">
			<S sid ="257" ssid = "1">Work Much work on semantics has taken place in a supervised setting—for example the GeoQuery (Zelle and Mooney, 1996) and ATIS (Dahl et al., 1994) semantic parsing tasks.</S>
			<S sid ="258" ssid = "2">This approach makes sense for generating queries for a specific database, but means the semantic representations do not generalize to other datasets.</S>
			<S sid ="259" ssid = "3">There have been several attempts to annotate larger corpora with semantics—such as Ontonotes (Hovy et al., 2006) or the Groningen Meaning Bank (Basile et al., 2012).</S>
			<S sid ="260" ssid = "4">These typically map words onto senses in ontologies such as Word- Net, VerbNet (Kipper et al., 2000) and FrameNet (Baker et al., 1998).</S>
			<S sid ="261" ssid = "5">However, limitations of these ontologies mean that they do not support inferences such as X is the author of Y → X wrote Y. Given the difficulty of annotating large amounts of text with semantics, various approaches have attempted to learn meaning without annotated text.</S>
			<S sid ="262" ssid = "6">Distant Supervision approaches leverage existing knowledge bases, such as Freebase (Bollacker et al., 2008), to learn semantics (Mintz et al., 2009; Krishnamurthy and Mitchell, 2012).</S>
			<S sid ="263" ssid = "7">Dependency-based Compositional Semantics (Liang et al., 2011) learns the meaning of questions by using their answers as denotations— but this appears to be specific to question parsing.</S>
			<S sid ="264" ssid = "8">Such approaches can only learn the pre-specified relations in the knowledge base.</S>
			<S sid ="265" ssid = "9">The approaches discussed so far in this section have all attempted to map language onto some pre specified set of relations.</S>
			<S sid ="266" ssid = "10">Various attempts have been made to instead induce relations from text by clustering predicates based on their arguments.</S>
			<S sid ="267" ssid = "11">For example, Yao et al.</S>
			<S sid ="268" ssid = "12">(2011) propose a series of LDA- based models which cluster relations between entities based on a variety of lexical, syntactic and semantic features.</S>
			<S sid ="269" ssid = "13">Unsupervised Semantic Parsing (Poon and Domingos, 2009) recursively clusters fragments of dependency trees based on their arguments.</S>
			<S sid ="270" ssid = "14">Although USP is an elegant model, it is too computationally expensive to run on large corpora.</S>
			<S sid ="271" ssid = "15">It is also based on frame semantics, so does not cluster equivalent predicates with different frames.</S>
			<S sid ="272" ssid = "16">To our knowledge, our work is the first such approach to be integrated within a linguistic theory supporting formal semantics for logical operators.</S>
			<S sid ="273" ssid = "17">Vector space models represent words by vectors based on co-occurrence counts.</S>
			<S sid ="274" ssid = "18">Recent work has tackled the problem of composing these matrices to build up the semantics of phrases or sentences (Mitchell and Lapata, 2008).</S>
			<S sid ="275" ssid = "19">Another strand (Coecke et al., 2010; Grefenstette et al., 2011) has shown how to represent meanings as tensors, whose order depends on the syntactic category, allowing an elegant correspondence between syntactic and semantic types.</S>
			<S sid ="276" ssid = "20">Socher et al.</S>
			<S sid ="277" ssid = "21">(2012) train a composition function using a neural network—however their method requires annotated data.</S>
			<S sid ="278" ssid = "22">It is also not obvious how to represent logical relations such as quantification in vector-space models.</S>
			<S sid ="279" ssid = "23">Baroni et al.</S>
			<S sid ="280" ssid = "24">(2012) make progress towards this by learning a classifier that can recognise entailments such as all dogs =⇒ some dogs, but this remains some way from the power of first-order theorem proving of the kind required by the problem in Figure 5.</S>
			<S sid ="281" ssid = "25">An alternative strand of research has attempted to build computational models of linguistic theories based on formal compositional semantics, such as the CCG-based Boxer (Bos, 2008) and the LFG- based XLE (Bobrow et al., 2007).</S>
			<S sid ="282" ssid = "26">Such approaches convert parser output into formal semantic representations, and have demonstrated some ability to model complex phenomena such as negation.</S>
			<S sid ="283" ssid = "27">For lexical semantics, they typically compile lexical resources such as VerbNet and WordNet into inference rules—but still achieve only low recall on open- domain tasks, such as RTE, mostly due to the low coverage of such resources.</S>
			<S sid ="284" ssid = "28">Garrette et al.</S>
			<S sid ="285" ssid = "29">(2011) use distributional statistics to determine the probability that a WordNet-derived inference rule is valid in a given context.</S>
			<S sid ="286" ssid = "30">Our approach differs in that we learn inference rules not present in WordNet.</S>
			<S sid ="287" ssid = "31">Our lexical semantics is integrated into the lexicon, rather than being implemented as additional inference rules, meaning that inference is more efficient, as equivalent statements have the same logical form.</S>
			<S sid ="288" ssid = "32">Natural Logic (MacCartney and Manning, 2007) offers an interesting alternative to symbolic logics, and has been shown to be able to capture complex logical inferences by simply identifying the scope of negation in text.</S>
			<S sid ="289" ssid = "33">This approach achieves similar precision and much higher recall than Boxer on the RTE task.</S>
			<S sid ="290" ssid = "34">Their approach also suffers from such limitations as only being able to make inferences between two sentences.</S>
			<S sid ="291" ssid = "35">It is also sensitive to word order, so cannot make inferences such as Shakespeare wrote Macbeth =⇒ Macbeth was written by Shakespeare.</S>
	</SECTION>
	<SECTION title="Conclusions and Future  Work. " number = "10">
			<S sid ="292" ssid = "1">This is the first work we are aware of that combines a distributionally induced lexicon with formal semantics.</S>
			<S sid ="293" ssid = "2">Experiments suggest our approach compares favourably with existing work in both areas.</S>
			<S sid ="294" ssid = "3">Many potential areas for improvement remain.</S>
			<S sid ="295" ssid = "4">Hierachical clustering would allow us to capture hypernym relations, rather than the synonyms captured by our flat clustering.</S>
			<S sid ="296" ssid = "5">There is much potential for integrating existing hand-built resources, such as Ontonotes and WordNet, to improve the accuracy of clustering.</S>
			<S sid ="297" ssid = "6">There are cases where the existing CCGBank grammar does not match the required predicate-argument structure—for example in the case of light verbs.</S>
			<S sid ="298" ssid = "7">It may be possible to re- bank CCGBank, in a way similar to Honnibal et al.</S>
			<S sid ="299" ssid = "8">(2010), to improve it on this point.</S>
	</SECTION>
	<SECTION title="Acknowledgements">
			<S sid ="300" ssid = "9">We thank Christos Christodoulopoulos, Tejaswini Deoskar, Mark GranrothWilding, Ewan Klein, Katrin Erk, Johan Bos and the anonymous reviewers for their helpful comments, and Limin Yao for sharing code.</S>
			<S sid ="301" ssid = "10">This work was funded by ERC Advanced Fellowship 249520 GRAMPLUS and IP ECFP7 270273 Xperience.</S>
	</SECTION>
</PAPER>
