<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">Many classification problems require decisions among a large number of competing classes.</S>
		<S sid ="2" ssid = "2">These tasks, however, are not handled well by general purpose learning methods and are usually addressed in an ad-hoc fashion.</S>
		<S sid ="3" ssid = "3">We suggest a general approach – a sequential learning model that utilizes classifiers to sequentially restrict the number of competing classes while maintaining, with high probability, the presence of the true outcome in the candidates set.</S>
		<S sid ="4" ssid = "4">Some theoretical and computational properties of the model are discussed and we argue that these are important in NLP-like domains.</S>
		<S sid ="5" ssid = "5">The advantages of the model are illustrated in an experiment in part- of-speech tagging.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="6" ssid = "6">A large number of important natural language inferences can be viewed as problems of resolving ambiguity, either semantic or syntactic, based on properties of the surrounding context.</S>
			<S sid ="7" ssid = "7">These, in turn, can all be viewed as classification problems in which the goal is to select a class label from among a collection of candidates.</S>
			<S sid ="8" ssid = "8">Examples include part-of speech tagging, word-sense disambiguation, accent restoration, word choice selection in machine translation, context-sensitive spelling correction, word selection in speech recognition and identifying discourse markers.</S>
			<S sid ="9" ssid = "9">Machine learning methods have become the most popular technique in a variety of classification problems of these sort, and have shown significant success.</S>
			<S sid ="10" ssid = "10">A partial list consists of Bayesian classifiers (Gale et al., 1993), decision lists (Yarowsky, 1994), Bayesian hybrids (Golding, 1995), HMMs (Charniak, 1993), inductive logic methods (Zelle and Mooney, 1996), memoryThis research is supported by NSF grants IIS9801638, IIS 0085836 and SBR987345.</S>
			<S sid ="11" ssid = "11">based methods (Zavrel et al., 1997), linear classifiers (Roth, 1998; Roth, 1999) and transformation- based learning (Brill, 1995).</S>
			<S sid ="12" ssid = "12">In many of these classification problems a significant source of difficulty is the fact that the number of candidates is very large – all words in words selection problems, all possible tags in tagging problems etc. Since general purpose learning algorithms do not handle these multi-class classification problems well (see below), most of the studies do not address the whole problem; rather, a small set of candidates (typically two) is first selected, and the classifier is trained to choose among these.</S>
			<S sid ="13" ssid = "13">While this approach is important in that it allows the research community to develop better learning methods and evaluate them in a range of applications, it is important to realize that an important stage is missing.</S>
			<S sid ="14" ssid = "14">This could be significant when the classification methods are to be embedded as part of a higher level NLP tasks such as machine translation or information extraction, where the small set of candidates the classifier can handle may not be fixed and could be hard to determine.</S>
			<S sid ="15" ssid = "15">In this work we develop a general approach to the study of multi-class classifiers.</S>
			<S sid ="16" ssid = "16">We suggest a sequential learning model that utilizes (almost) general purpose classifiers to sequentially restrict the number of competing classes while maintaining, with high probability, the presence of the true outcome in the candidate set.</S>
			<S sid ="17" ssid = "17">In our paradigm the sought after classifier has to choose a single class label (or a small set of labels) from among a large set of labels.</S>
			<S sid ="18" ssid = "18">It works by sequentially applying simpler classifiers, each of which outputs a probability distribution over the candidate labels.</S>
			<S sid ="19" ssid = "19">These distributions are multiplied and thresholded, resulting in that each classifier in the sequence needs to deal with a (significantly) smaller number of the candidate labels than the previous classifier.</S>
			<S sid ="20" ssid = "20">The classifiers in the sequence are selected to be simple in the sense that they typically work only on part of the feature space where the decomposition of feature space is done so as to achieve statistical independence.</S>
			<S sid ="21" ssid = "21">Simple classifier are used since they are more likely to be accurate; they are chosen so that, with high probability (w.h.p.), they have one sided error, and therefore the presence of the true label in the candidate set is maintained.</S>
			<S sid ="22" ssid = "22">The order of the sequence is determined so as to maximize the rate of decreasing the size of the candidate labels set.</S>
			<S sid ="23" ssid = "23">Beyond increased accuracy on multi-class classification problems , our scheme improves the computation time of these problems several orders of magnitude, relative to other standard schemes.</S>
			<S sid ="24" ssid = "24">In this work we describe the approach, discuss an experiment done in the context of part-of-speech (pos) tagging, and provide some theoretical justifications to the approach.</S>
			<S sid ="25" ssid = "25">Sec.</S>
			<S sid ="26" ssid = "26">2 provides some background on approaches to multi-class classification in machine learning and in NLP.</S>
			<S sid ="27" ssid = "27">In Sec.</S>
			<S sid ="28" ssid = "28">3 we describe the sequential model proposed here and in Sec.</S>
			<S sid ="29" ssid = "29">4 we describe an experiment the exhibits some of its advantages.</S>
			<S sid ="30" ssid = "30">Some theoretical justifications are outlined in Sec.</S>
			<S sid ="31" ssid = "31">5.</S>
	</SECTION>
	<SECTION title="Multi-Class Classification. " number = "2">
			<S sid ="32" ssid = "1">Several works within the machine learning community have attempted to develop general approaches to multi-class classification.</S>
			<S sid ="33" ssid = "2">One of the most promising approaches is that of error correcting output codes (Dietterich and Bakiri, 1995); however, this approach has not been able to handle well a large number of classes (over 10 or 15, say) and its use for most large scale NLP applications is therefore questionable.</S>
			<S sid ="34" ssid = "3">Statistician have studied several schemes such as learning a single classifier for each of the class labels (one vs. all) or learning a discriminator for each pair of class labels, and discussed their relative merits(Hastie and Tibshirani, 1998).</S>
			<S sid ="35" ssid = "4">Although it has been argued that the latter should provide better results than others, experimental results have been mixed (Allwein et al., 2000) and in some cases, more involved schemes, e.g., learning a classifier for each set of three class labels (and deciding on the prediction in a tournament like fashion) were shown to perform better (Teow and Loe, 2000).</S>
			<S sid ="36" ssid = "5">Moreover, none of these methods seem to be computationally plausible for large scale problems, since the number of classifiers one needs to train is, at least, quadratic in the number of class labels.</S>
			<S sid ="37" ssid = "6">Within NLP, several learning works have already addressed the problem of multi-class classification.</S>
			<S sid ="38" ssid = "7">In (Kudoh and Matsumoto, 2000) the methods of “all pairs” was used to learn phrase annotations for shallow parsing.</S>
			<S sid ="39" ssid = "8">More than different classifiers where used in this task, making it infeasible as a general solution.</S>
			<S sid ="40" ssid = "9">All other cases we know of, have taken into account some properties of the domain and, in fact, several of the works can be viewed as instantiations of the sequential model we formalize here, albeit done in an ad-hoc fashion.</S>
			<S sid ="41" ssid = "10">In speech recognition, a sequential model is used to process speech signal.</S>
			<S sid ="42" ssid = "11">Abstracting away some details, the first classifier used is a speech signal analyzer; it assigns a positive probability only to some of the words (using Levenshtein distance (Levenshtein, 1966) or somewhat more sophisticated techniques (Levinson et al., 1990)).</S>
			<S sid ="43" ssid = "12">These words are then assigned probabilities using a different contextual classifier e.g., a language model, and then, (as done in most current speech recognizers) an additional sentence level classifier uses the outcome of the word classifiers in a word lattice to choose the most likely sentence.</S>
			<S sid ="44" ssid = "13">Several word prediction tasks make decisions in a sequential way as well.</S>
			<S sid ="45" ssid = "14">In spell correction confusion sets are created using a classifier that takes as input the word transcription and outputs a positive probability for potential words.</S>
			<S sid ="46" ssid = "15">In conventional spellers, the output of this classifier is then given to the user who selects the intended word.</S>
			<S sid ="47" ssid = "16">In context sensitive spelling correction (Golding and Roth, 1999; Mangu and Brill, 1997) an additional classifier is then utilized to predict among words that are supported by the first classifier, using contextual and lexical information of the surrounding words.</S>
			<S sid ="48" ssid = "17">In all studies done so far, however, the first classifier – the confusion sets – were constructed manually by the researchers.</S>
			<S sid ="49" ssid = "18">Other word predictions tasks have also constructed manually the list of confusion sets (Lee and Pereira, 1999; Dagan et al., 1999; Lee, 1999) and justifications where given as to why this is a reasonable way to construct it.</S>
			<S sid ="50" ssid = "19">(Even-Zohar and Roth, 2000) present a similar task in which the confusion sets generation was automated.</S>
			<S sid ="51" ssid = "20">Their study also quantified experimentally the advantage in using early classifiers to restrict the size of the confusion set.</S>
			<S sid ="52" ssid = "21">Many other NLP tasks, such as pos tagging, name entity recognition and shallow parsing require multi-class classifiers.</S>
			<S sid ="53" ssid = "22">In several of these cases the number of classes could be very large (e.g., pos tagging in some languages, pos tagging when a finer proper noun tag is used).</S>
			<S sid ="54" ssid = "23">The sequential model suggested here is a natural solution.</S>
	</SECTION>
	<SECTION title="The Sequential Model. " number = "3">
			<S sid ="55" ssid = "1">We study the problem of learning a multi-class classifier, where , and is typically large, on the order of . We address this problem using the Sequential Model (SM) in which simpler classifiers are sequentially used to filter subsets of out of consideration.</S>
			<S sid ="56" ssid = "2">The sequential model is formally defined as a - tuple: where is a decomposition of the domain (not necessarily disjoint; it could be that ).</S>
			<S sid ="57" ssid = "3">is the set of class labels.</S>
			<S sid ="58" ssid = "4">determines the order in which the classifiers are learned and evaluated.</S>
			<S sid ="59" ssid = "5">For convenience we denote is the set of classifiers used by the model, . is a set of constant thresholds.</S>
			<S sid ="60" ssid = "6">Given and a set of class labels, the th classifier outputs a probability distribution1 over labels in (where is the probability assigned to class by ), and satisfies that if then . The set of remaining candidates after the th classification stage is determined by and : The sequential process can be viewed as a multiplication of distributions.</S>
			<S sid ="61" ssid = "7">(Hinton, 2000) argues that a product of distributions (or, “experts”, PoE) 1 The output of many classifiers can be viewed, after appropriate normalization, as a confidence measure that can be used as our . is an efficient way to make decisions in cases where several different constrains play a role, and is advantageous over additive models.</S>
			<S sid ="62" ssid = "8">In fact, due to the thresholding step, our model can be viewed as a selective PoE.</S>
			<S sid ="63" ssid = "9">The thresholding ensures that the SM has the following monotonicity property: that is, as we evaluate the classifiers sequentially, smaller or equal (size) confusion sets are considered.</S>
			<S sid ="64" ssid = "10">A desirable design goal for the SM is that, w.h.p., the classifiers have one sided error (even at the price of rejecting fewer classes).</S>
			<S sid ="65" ssid = "11">That is, if is the true target2, then we would like to have that . The rest of this paper presents a concrete instantiation of the SM, and then provides a theoretical analysis of some of its properties (Sec.</S>
			<S sid ="66" ssid = "12">5).</S>
			<S sid ="67" ssid = "13">This work does not address the question of acquiring SM i.e., learning .</S>
	</SECTION>
	<SECTION title="Example: POS Tagging. " number = "4">
			<S sid ="68" ssid = "1">This section describes a two part experiment of pos tagging in which we compare, under identical conditions, two classification models: A SM and a single classifier.</S>
			<S sid ="69" ssid = "2">Both are provided with the same input features and the only difference between them is the model structure.</S>
			<S sid ="70" ssid = "3">In the first part, the comparison is done in the context of assigning pos tags to unknown words –those words which were not presented during train ing and therefore the learner has no baseline knowledge about possible POS they may take.</S>
			<S sid ="71" ssid = "4">This experiment emphasizes the advantage of using the SM during evaluation in terms of accuracy.</S>
			<S sid ="72" ssid = "5">The second part is done in the context of pos tagging of known words.</S>
			<S sid ="73" ssid = "6">It compares processing time as well as accuracy of assigning pos tags to known words (that is, the classifier utilizes knowledge about possible POS tags the target word may take).</S>
			<S sid ="74" ssid = "7">This part exhibits a large reduction in training time using the SM over the more common one-vs-all method while the accuracy of the two methods is almost identical.</S>
			<S sid ="75" ssid = "8">Two types of features – lexical features and contextual features may be used when learning how to tag words for pos.</S>
			<S sid ="76" ssid = "9">Contextual features capture the information in the surrounding context and the word lemma while the lexical features capture the morphology of the unknown word.3 Several is 2 We use the terms class and target interchangeably..</S>
			<S sid ="77" ssid = "10">3 Lexical features are used only when tagging unknown words.</S>
			<S sid ="78" ssid = "11">sues make the pos tagging problem a natural problem to study within the SM.</S>
			<S sid ="79" ssid = "12">(i) A relatively large number of classes (about 50).</S>
			<S sid ="80" ssid = "13">(ii) A natural decomposition of the feature space to contextual and lexical features.</S>
			<S sid ="81" ssid = "14">(iii) Lexical knowledge (for unknown words) and the word lemma (for known words) provide, w.h.p, one sided error (Mikheev, 1997).</S>
			<S sid ="82" ssid = "15">4.1 The Tagger Classifiers.</S>
			<S sid ="83" ssid = "16">The domain in our experiment is defined using the following set of features, all of which are computed relative to the target word . Contextual Features (as in (Brill, 1995; Roth and Zelenko, 1998)): Let be the tags of the word preceding, (following) the target word, respectively.</S>
			<S sid ="84" ssid = "17">1.</S>
			<S sid ="85" ssid = "18">. 2.</S>
			<S sid ="86" ssid = "19">. 3.</S>
			<S sid ="87" ssid = "20">. 4.</S>
			<S sid ="88" ssid = "21">. 5.</S>
			<S sid ="89" ssid = "22">. 6.</S>
			<S sid ="90" ssid = "23">. 7.</S>
			<S sid ="91" ssid = "24">. 8.</S>
			<S sid ="92" ssid = "25">Baseline tag for word . In case is an unknown word, the baseline is proper singular noun “NNP” for capitalized words and common singular noun “NN” otherwise.</S>
			<S sid ="93" ssid = "26">(This feature is introduced only in some of the experiments.)</S>
			<S sid ="94" ssid = "27">9.The target word . Lexical Features: Let be any three characters observed in the examples.</S>
			<S sid ="95" ssid = "28">10.</S>
			<S sid ="96" ssid = "29">Target word is capitalized..</S>
			<S sid ="97" ssid = "30">11.</S>
			<S sid ="98" ssid = "31">ends with and length( . 12.</S>
			<S sid ="99" ssid = "32">ends with and length( . 13.</S>
			<S sid ="100" ssid = "33">ends with and length( . In the following experiment, the SM used for unknown words makes use of three different classifiers and or , defined as follows: : a classifier based on the lexical feature . : a classifier based on lexical features : a classifier based on contextual features . : a classifier based on all the features, . The SM is compared with a single classifier – either or . Notice that is a single classifier that uses the same information as used by the SM.</S>
			<S sid ="101" ssid = "34">Fig 1 Figure 1: POS Tagging of Unknown Word using Contextual and Lexical features in a Sequential Model.</S>
			<S sid ="102" ssid = "35">The input for capitalized classifier has 2 values and therefore 2 ways to create confusion sets.</S>
			<S sid ="103" ssid = "36">There are at most different inputs for the suffix classifier (26 character + 10 digits + 5 other symbols), therefore suffix may emit up to confusion sets.</S>
			<S sid ="104" ssid = "37">illustrates the SM that was used in the experiments.</S>
			<S sid ="105" ssid = "38">All the classifiers in the sequential model, as well as the single classifier, use the SNoW learning architecture (Roth, 1998) with the Winnow update rule.</S>
			<S sid ="106" ssid = "39">SNoW (Sparse Network of Winnows) is a multi-class classifier that is specifically tailored for learning in domains in which the potential number of features taking part in decisions is very large, but in which decisions actually depend on a small number of those features.</S>
			<S sid ="107" ssid = "40">SNoW works by learning a sparse network of linear functions over a predefined or incrementally learned feature space.</S>
			<S sid ="108" ssid = "41">SNoW has already been used successfully on several tasks in natural language processing (Roth, 1998; Roth and Zelenko, 1998; Golding and Roth, 1999; Punyakanok and Roth, 2001).</S>
			<S sid ="109" ssid = "42">Specifically, for each class label SNoW learns a function that maps a feature based representation of the input instance to a number which can be interpreted as the prob ability of being the class label corresponding to . At prediction time, given , SNoW outputs (1) All functions – in our case, target nodes are used, one for each pos tag – reside over the same feature space, but can be thought of as autonomous functions (networks).</S>
			<S sid ="110" ssid = "43">That is, a given example is treated autonomously by each target subnetwork; an example labeled is considered as a positive example for the function learned for and as a negative example for the rest of the functions (target nodes).</S>
			<S sid ="111" ssid = "44">The network is sparse in that a target node need not be connected to all nodes in the input layer.</S>
			<S sid ="112" ssid = "45">For example, it is not connected to input nodes (features) that were never active with it in the same sentence.</S>
			<S sid ="113" ssid = "46">Although SNoW is used with different targets, the SM utilizes by determining the confusion set dynamically.</S>
			<S sid ="114" ssid = "47">That is, in evaluation (prediction), the maximum in Eq. 1 is taken only over the currently applicable confusion set.</S>
			<S sid ="115" ssid = "48">Moreover, in training, a given example is used to train only target networks that are in the currently applicable confusion set.</S>
			<S sid ="116" ssid = "49">That is, an example that is positive for target , is viewed as positive for this target (if it is in the con fusion set), and as negative for the other targets in the confusion set.</S>
			<S sid ="117" ssid = "50">All other targets do not see this example.</S>
			<S sid ="118" ssid = "51">The case of POS tagging of known words is handled in a similar way.</S>
			<S sid ="119" ssid = "52">In this case, all possible tags are known.</S>
			<S sid ="120" ssid = "53">In training, we record, for each word , all pos tags with which it was tagged in the training corpus.</S>
			<S sid ="121" ssid = "54">During evaluation, whenever word occurs, it is tagged with one of these pos tags.</S>
			<S sid ="122" ssid = "55">That is, in evaluation, the confusion set consists only of those tags observed with the target word in training, and the maximum in Eq. 1 is taken only over these.</S>
			<S sid ="123" ssid = "56">This is always the case when using (or ), both in the SM and as a single classifier.</S>
			<S sid ="124" ssid = "57">In training, though, for the sake of this experiment, we treat ( ) differently depending on whether it is trained for the SM or as a single classifier.</S>
			<S sid ="125" ssid = "58">When trained as a single classifier (e.g., (Roth and Zelenko, 1998)), uses each -tagged example as a positive exam ple for and a negative example for all other tags.</S>
			<S sid ="126" ssid = "59">On the other hand, the SM classifier is trained on a -tagged example of word , by using it as a positive example for and a negative example only for the effective confusion set.</S>
			<S sid ="127" ssid = "60">That is, those pos tags which have been observed as tags of in the training corpus.</S>
			<S sid ="128" ssid = "61">4.2 Experimental Results.</S>
			<S sid ="129" ssid = "62">The data for the experiments was extracted from the Penn Treebank WSJ and Brown corpora.</S>
			<S sid ="130" ssid = "63">The training corpus consists of words.</S>
			<S sid ="131" ssid = "64">The test corpus consists of words of which are unknown words (that is, they do not occur in the training corpus.</S>
			<S sid ="132" ssid = "65">(Numbers (the pos “CD”), are not included among the unknown words).</S>
			<S sid ="133" ssid = "66">POS Tagging of Unknown Words + b a s e l i n e ba sel in e Table 1: POS tagging of unknown words using contextual features (accuracy in percent).</S>
			<S sid ="134" ssid = "67">is a classifier that uses only contextual features, + baseline is the same classifier with the addition of the baseline feature (“NNP” or “NN”).</S>
			<S sid ="135" ssid = "68">Table 1 summarizes the results of the experiments with a single classifier that uses only contextual features.</S>
			<S sid ="136" ssid = "69">Notice that adding the baseline POS significantly improves the results but not much is gained over the baseline.</S>
			<S sid ="137" ssid = "70">The reason is that the baseline feature is almost perfect ( ) in the training data.</S>
			<S sid ="138" ssid = "71">For that reason, in the next experiments we do not use the baseline at all, since it could hide the phenomenon addressed.</S>
			<S sid ="139" ssid = "72">(In practice, one might want to use a more sophisticated baseline, as in (Dermatas and Kokkinakis, 1995).)</S>
			<S sid ="140" ssid = "73">S M ( ) S M ( ) Table 2: POS tagging of unknown words using contextual and lexical Features (accuracy in percent).</S>
			<S sid ="141" ssid = "74">is based only on contextual features, is based on contextual and lexical features.</S>
			<S sid ="142" ssid = "75">SM( ) denotes that follows in the sequential model.</S>
			<S sid ="143" ssid = "76">Table 2 summarizes the results of the main experiment in this part.</S>
			<S sid ="144" ssid = "77">It exhibits the advantage of using the SM (columns 3,4) over a single classifier that makes use of the same features set (column 2).</S>
			<S sid ="145" ssid = "78">In both cases, all features are used.</S>
			<S sid ="146" ssid = "79">In , a classifier is trained on input that consists of all these features and chooses a label from among all class labels.</S>
			<S sid ="147" ssid = "80">In the same features are used as input, but different classifiers are used sequentially – using only part of the feature space and restricting the set of possible outcomes available to the next classifier in the sequence – chooses only from among those left as candidates.</S>
			<S sid ="148" ssid = "81">It is interesting to note that further improvement can be achieved, as shown in the right most column.</S>
			<S sid ="149" ssid = "82">Given that the last stage in is identical to the single classifier , this shows the contribution of the filtering done in the first two stages using and . In addition, this result shows that the input spaces of the classifiers need not be disjoint.</S>
			<S sid ="150" ssid = "83">POS Tagging of Known Words Essentially everyone who is learning a POS tagger for known words makes use of a “sequential model” assumption during evaluation – by restricting the set of candidates, as discussed in Sec 4.1).</S>
			<S sid ="151" ssid = "84">The focus of this experiment is thus to investigate the advantage of the SM during training.</S>
			<S sid ="152" ssid = "85">In this case, a single (one-vs-all) classifier trains each tag against all other tags, while a SM classifier trains it only against the effective confusion set (Sec 4.1).</S>
			<S sid ="153" ssid = "86">Table 3 compares the performance of the classifier trained using in a one-vs-all method to the same classifier trained the SM way.</S>
			<S sid ="154" ssid = "87">The results are only for known words and the results of Brill’s tag- ger (Brill, 1995) are presented for comparison.</S>
			<S sid ="155" ssid = "88">o n e v s a ll S M B r il l Table 3: POS Tagging of known words using contextual features (accuracy in percent).</S>
			<S sid ="156" ssid = "89">one-vs-all denotes training where example serves as positive example to the true tag and as negative example to all the other tags.</S>
			<S sid ="157" ssid = "90">SM denotes training where example serves as positive example to the true tag and as a negative example only to a restricted set of tags in based on a previous classifier – here, a simple baseline restriction.</S>
			<S sid ="158" ssid = "91">While, in principle, (see Sec 5) the SM should do better (an never worse) than the one-vs-all classifier, we believe that in this case SM does not have any performance advantages since the classifiers work in a very high dimensional feature space which allows the one-vs-all classifier to find a separating hyperplane that separates the positive examples many different kinds of negative examples (even irrelevant ones).</S>
			<S sid ="159" ssid = "92">However, the key advantage of the SM in this case is the significant decrease in computation time, both in training and evaluation.</S>
			<S sid ="160" ssid = "93">Table 4 shows that in the pos tagging task, training using the SM is 6 times faster than with a one-vs-all method and 3000 faster than Brill’s learner.</S>
			<S sid ="161" ssid = "94">In addition, the evaluation time of our tagger was about twice faster than that of Brill’s tagger.</S>
			<S sid ="162" ssid = "95">o n e v s a ll S M B r i l l Tr ai n T es t Table 4: Processing time for POS tagging of known words using contextual features (In CPU seconds).</S>
			<S sid ="163" ssid = "96">Train: training time over sentences.</S>
			<S sid ="164" ssid = "97">Brill’s learner was interrupted after 12 days of training (default threshold was used).</S>
			<S sid ="165" ssid = "98">Test: average number of seconds to evaluate a single sentence.</S>
			<S sid ="166" ssid = "99">All runs were done on the same machine.</S>
	</SECTION>
	<SECTION title="The Sequential model: Theoretical. " number = "5">
			<S sid ="167" ssid = "1">Justification In this section, we discuss some of the theoretical aspects of the SM and explain some of its advantages.</S>
			<S sid ="168" ssid = "2">In particular, we discuss the following issues: 1.</S>
			<S sid ="169" ssid = "3">Domain Decomposition: When the input fea-.</S>
			<S sid ="170" ssid = "4">ture space can be decomposed, we show that it is advantageous to do it and learn several classifiers, each on a smaller domain.</S>
			<S sid ="171" ssid = "5">2.</S>
			<S sid ="172" ssid = "6">Range Decomposition: Reducing confusion.</S>
			<S sid ="173" ssid = "7">set size is advantageous both in training and testing the classifiers.</S>
			<S sid ="174" ssid = "8">(a) Test: Smaller confusion set is shown to yield a smaller expected error.</S>
			<S sid ="175" ssid = "9">(b) Training: Under the assumptions that a small confusion set (determined dynamically by previous classifiers in the sequence) is used when a classifier is evaluated, it is shown that training the classifiers this way is advantageous.</S>
			<S sid ="176" ssid = "10">3.</S>
			<S sid ="177" ssid = "11">Expressivity: SM can be viewed as a way to.</S>
			<S sid ="178" ssid = "12">generate an expressive classifier by building on a number of simpler ones.</S>
			<S sid ="179" ssid = "13">We argue that the SM way of generating an expressive classifier has advantages over other ways of doing it, such as decision tree.</S>
			<S sid ="180" ssid = "14">(Sec 5.3).</S>
			<S sid ="181" ssid = "15">In addition, SM has several significant computational advantages both in training and in test, since it only needs to consider a subset of the set of candidate class labels.</S>
			<S sid ="182" ssid = "16">We will not discuss these issues in detail here.</S>
			<S sid ="183" ssid = "17">5.1 Decomposing the Domain.</S>
			<S sid ="184" ssid = "18">Decomposing the domain is not an essential part of the SM; it is possible that all the classifiers used actually use the same domain.</S>
			<S sid ="185" ssid = "19">As we shown below, though, when a decomposition is possible, it is advantageous to use it.</S>
			<S sid ="186" ssid = "20">It is shown in Eq. 27 that when it is possible to decompose the domain to subsets that are condition ally independent given the class label, the SM with classifiers defined on these subsets is as accurate as the optimal single classifier.</S>
			<S sid ="187" ssid = "21">(In fact, this is shown for a pure product of simpler classifiers; the SM uses a selective product.)</S>
			<S sid ="188" ssid = "22">In the following we assume that provide a decomposition of the domain (Sec.</S>
			<S sid ="189" ssid = "23">3) and that . By conditional independence we mean that where is the input for the th classifier.</S>
			<S sid ="190" ssid = "24">(2) POS.</S>
			<S sid ="191" ssid = "25">(E.g., assume that word is a gerund; then the context is independent of the “ing” word ending.)</S>
			<S sid ="192" ssid = "26">In addition, decomposing the domain has significant advantages from the learning theory point of view (Roth, 1999).</S>
			<S sid ="193" ssid = "27">Learning over domains of lower dimensionality implies better generalization bounds or, equivalently, more accurate classifiers for a fixed size training set.</S>
			<S sid ="194" ssid = "28">5.2 Decomposing the range.</S>
			<S sid ="195" ssid = "29">The SM attempts to reduce the size of the candidates set.</S>
			<S sid ="196" ssid = "30">We justify this by considering two cases: (i) Test: we will argue that prediction among a smaller set of classes has advantages over predicting among a large set of classes; (ii) Training: we will argue that it is advantageous to ignore irrelevant examples.</S>
			<S sid ="197" ssid = "31">5.2.1 Decomposing the range during Test The following discussion formalizes the intuition that a smaller confusion set in preferred.</S>
			<S sid ="198" ssid = "32">Let be the true target function and the probability assigned by the final classifier to class given example . Assuming that the prediction is done, naturally, by choosing the most likely class label, we see that the expected error when using a confusion set of size is: (3) (4) (5) (6) (7) in Eq. 3 is identical and therefore can be treated as a constant.</S>
			<S sid ="199" ssid = "33">Eq. 5 is derived by applying the independence assumption.</S>
			<S sid ="200" ssid = "34">Eq. 6 is derived by using the Bayes rule for each term separately.</S>
			<S sid ="201" ssid = "35">We note that although the conditional independence assumption is a strong one, it is a reasonableassumption in many NLP applications; in particu lar, when cross modality information is used, this assumption typically holds for decomposition that is done across modalities.</S>
			<S sid ="202" ssid = "36">For example, in POS tagging, lexical information is often conditionally independent of contextual information, given the true Now we have: Claim 1 Let be two sets of class labels and assume for example . Then ..</S>
			<S sid ="203" ssid = "37">Proof.</S>
			<S sid ="204" ssid = "38">Denote: Then, (8) Claim 1 shows that reducing the size of the confusion set can only help; this holds under the assumption that the true class label is not eliminated from consideration by down stream classifiers, that , and the hypothesis produced by . Then, for all , is, under the one-sided error assumption.</S>
			<S sid ="205" ssid = "39">Moreover, it is easy to see that the proof of Claim 1 allows us to relax the one sided error assumption and assume (9) instead that the previous classifiers err with a probability which is smaller than: 5.2.2 Decomposing the range during training We will assume now, as suggested by the previous discussion, that in the evaluation stage the smallest possible set of candidates will be considered by each classifier.</S>
			<S sid ="206" ssid = "40">Based on this assumption, Claim 2 shows that training this way is advantageous.</S>
			<S sid ="207" ssid = "41">That is, that utilizing the SM in training yields a better classifier.</S>
			<S sid ="208" ssid = "42">Let be a learning algorithm that is trained to minimize: where is an example, is the true class, is the hypothesis, is a loss function and is the probability of seeing example when (see (Allwein et al., 2000)).</S>
			<S sid ="209" ssid = "43">(Notice that in this section we are using general loss function ; we could use, in particular, binary loss function used in Sec 5.2.) We phrase and prove the next claim, w.l.o.g, the case of vs. class labels.</S>
			<S sid ="210" ssid = "44">Claim 2 Let be the set of class labels, let be the set of examples for class . Assume a sequential model in which class does not compete with class . That is, whenever the SM filters out such that the final classifier ( ) considers only and . Then, the error of the hypothesis - produced by algorithm (for ) - when trained on examples in is no larger than the error produced by the hypothesis it produces when trained on examples in . Proof.</S>
			<S sid ="211" ssid = "45">Assume that the algorithm , when trained on a sample , produces a hypothesis that minimizes the empirical error over . Denote when is sampled according to a distribution that supports only examples with label in . Let be a sample set of size , according to In the limit, as In particular this holds if is a hypothesis produced by when trained on , that is sampled according to . 5.3 Expressivity.</S>
			<S sid ="212" ssid = "46">The SM is a decision process that is conceptually similar to a decision tree processes (Rasoul and Landgrebe, 1991; Mitchell, 1997), especially if one allows more general classifiers in the decision tree nodes.</S>
			<S sid ="213" ssid = "47">In this section we show that (i) the SM can express any DT.</S>
			<S sid ="214" ssid = "48">(ii) the SM is more compact than a decision tree even when the DT makes used of more expressive internal nodes (Murthy et al., 1994).</S>
			<S sid ="215" ssid = "49">The next theorem shows that for a fixed set of functions (queries) over the input features, any binary decision tree can be represented as a SM.</S>
			<S sid ="216" ssid = "50">Extending the proof beyond binary decision trees is straightforward.</S>
			<S sid ="217" ssid = "51">Theorem 3 Let be a binary decision tree with internal nodes.</S>
			<S sid ="218" ssid = "52">Then, there exist a sequential model such that and have the same size, and they produce the same predictions.</S>
			<S sid ="219" ssid = "53">Proof (Sketch): Given a decision tree on nodes we show how to construct a SM that produces equivalent predictions.</S>
			<S sid ="220" ssid = "54">1.</S>
			<S sid ="221" ssid = "55">Generate a confusion set the consists of.</S>
			<S sid ="222" ssid = "56">classes, each representing an internal node in . 2.</S>
			<S sid ="223" ssid = "57">For each internal node in , assign a clas-.</S>
			<S sid ="224" ssid = "58">sifier: . 3.</S>
			<S sid ="225" ssid = "59">Order the classifiers such that a clas-.</S>
			<S sid ="226" ssid = "60">sifier that is assigned to node is processed before any classifier that was assigned to any of the children of . 4.</S>
			<S sid ="227" ssid = "61">Define each classifier that was assigned to.</S>
			<S sid ="228" ssid = "62">node to have an influence on the outcome iff node lies in the path ( ) from the root to the predicted class.</S>
			<S sid ="229" ssid = "63">5.</S>
			<S sid ="230" ssid = "64">Show that using steps 14, the predicted target.</S>
			<S sid ="231" ssid = "65">of and are identical.</S>
			<S sid ="232" ssid = "66">This completes that proof and shows that the resulting SM is of equivalent size to the original decision tree.</S>
			<S sid ="233" ssid = "67">We note that given a SM, it is also relatively easy (details omitted) to construct a decision tree that produces the same decisions as the final classifier of the SM.</S>
			<S sid ="234" ssid = "68">However, the simple construction results in a decision tree that is exponentially larger than the original SM.</S>
			<S sid ="235" ssid = "69">Theorem 4 shows that this difference in expressivity is inherent.</S>
			<S sid ="236" ssid = "70">Theorem 4 Let be the number of classifiers in a sequential model and the number of internal nodes a in decision tree . Let be the set of classes in the output of and also the maximum degree of the internal nodes in . Denote by the number of functions representable by respectively.</S>
			<S sid ="237" ssid = "71">Then, when , is exponentially larger than . Proof (Sketch): The proof follows by counting the number of functions that can be represented using a decision tree with internal nodes(Wilf, 1994), and the number of functions that can be represented using a sequential model on intermediate classifier.</S>
			<S sid ="238" ssid = "72">Given the exponential gap, it follows that one may need exponentially large decision trees to represent an equivalent predictor to an size SM.</S>
	</SECTION>
	<SECTION title="Conclusion. " number = "6">
			<S sid ="239" ssid = "1">A wide range and a large number of classification tasks will have to be used in order to perform any high level natural language inference such as speech recognition, machine translation or question answering.</S>
			<S sid ="240" ssid = "2">Although in each instantiation the real conflict could be only to choose among a small set of candidates, the original set of candidates could be very large; deriving the small set of candidates that are relevant to the task at hand may not be immediate.</S>
			<S sid ="241" ssid = "3">This paper addressed this problem by developing a general paradigm for multi-class classification that sequentially restricts the set of candidate classes to a small set, in a way that is driven by the data observed.</S>
			<S sid ="242" ssid = "4">We have described the method and provided some justifications for its advantages, especially in NLP-like domains.</S>
			<S sid ="243" ssid = "5">Preliminary experiments also show promise.</S>
			<S sid ="244" ssid = "6">Several issues are still missing from this work.</S>
			<S sid ="245" ssid = "7">In our experimental study the decomposition of the feature space was done manually; it would be nice to develop methods to do this automatically.</S>
			<S sid ="246" ssid = "8">Better understanding of methods for thresholding the probability distributions that the classifiers output, as well as principled ways to order them are also among the future directions of this research.</S>
	</SECTION>
</PAPER>
