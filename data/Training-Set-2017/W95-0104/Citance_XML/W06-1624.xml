<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">In this paper, we present a weakly supervised learning approach for spoken language understanding in domain-specific dialogue systems.</S>
		<S sid ="2" ssid = "2">We model the task of spoken language understanding as a successive classification problem.</S>
		<S sid ="3" ssid = "3">The first classifier (topic classifier) is used to identify the topic of an input utterance.</S>
		<S sid ="4" ssid = "4">With the restriction of the recognized target topic, the second classifier (semantic classifier) is trained to extract the corresponding slot-value pairs.</S>
		<S sid ="5" ssid = "5">It is mainly data-driven and requires only minimally annotated corpus for training whilst retaining the understanding robustness and deepness for spoken language.</S>
		<S sid ="6" ssid = "6">Most importantly, it allows the employment of weakly supervised strategies for training the two classifiers.</S>
		<S sid ="7" ssid = "7">We first apply the training strategy of combining active learning and self-training (Tur et al., 2005) for topic classifier.</S>
		<S sid ="8" ssid = "8">Also, we propose a practical method for bootstrapping the topic-dependent semantic classifiers from a small amount of labeled sentences.</S>
		<S sid ="9" ssid = "9">Experiments have been conducted in the context of Chinese public transportation information inquiry domain.</S>
		<S sid ="10" ssid = "10">The experimental results demonstrate the effectiveness of our proposed SLU framework and show the possibility to reduce human labeling efforts significantly.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="11" ssid = "11">Spoken Language Understanding (SLU) is one of the key components in spoken dialogue systems.</S>
			<S sid ="12" ssid = "12">Its task is to identify the user’s goal and extract from the input utterance the information needed to complete the query.</S>
			<S sid ="13" ssid = "13">Traditionally, there are mainly two mainstreams in the SLU researches: knowledge-based approaches, which are based on robust parsing or template matching techniques (Sneff, 1992; Dowding et al., 1993; Ward and Issar, 1994); and data-driven approaches, which are generally based on stochastic models (Pieraccini and Levin, 1993; Miller et al., 1995).</S>
			<S sid ="14" ssid = "14">Both approaches have their drawbacks, however.</S>
			<S sid ="15" ssid = "15">The former approach is cost-expensive to develop since its grammar development is time- consuming, laboursome and requires linguistic skills.</S>
			<S sid ="16" ssid = "16">It is also strictly domain-dependent and hence difficult to be adapted to new domains.</S>
			<S sid ="17" ssid = "17">On the other hand, although addressing such drawbacks associated with knowledge-based approaches, the latter approach often suffers the data sparseness problem and hence needs a fully annotated corpus in order to reliably estimate an accurate model.</S>
			<S sid ="18" ssid = "18">More recently, some new variation methods are proposed through certain trade- offs, such as the semi-automatically grammar learning approach (Wang and Acero, 2001) and Hidden Vector State (HVS) model (He and Young, 2005).</S>
			<S sid ="19" ssid = "19">The two methods require only minimally annotated data (only the semantic frames are annotated).</S>
			<S sid ="20" ssid = "20">This paper proposes a novel weakly supervised spoken language understanding approach.</S>
			<S sid ="21" ssid = "21">Our SLU framework mainly includes two successive classifiers: topic classifier and semantic classifier.</S>
			<S sid ="22" ssid = "22">The main advantage of the proposed approach is that it is mainly data-driven and requires only minimally annotated corpus for training whilst retaining the understanding robustness and deepness for spoken language.</S>
			<S sid ="23" ssid = "23">In particular, the two classifiers are trained using weakly supervised strategies: the former one is trained through the combination of active learning and self-training (Tur et al., 2005), and the latter one 199 Proceedings of the 2006 Conference on Empirical Methods in Natural Language Processing (EMNLP 2006), pages 199–207, Sydney, July 2006.</S>
			<S sid ="24" ssid = "24">Qc 2006 Association for Computational Linguistics is trained using a practical bootstrapping technique.</S>
	</SECTION>
	<SECTION title="The System Architecture. " number = "2">
			<S sid ="25" ssid = "1">The semantic representation of an application domain is usually defined in terms of the semantic frame, which contains a frame type representing the topic of the input sentence, and some slots representing the constraints the query goal has to satisfy.</S>
			<S sid ="26" ssid = "2">Then, the goal of the SLU system is to translate an input utterance into a semantic frame.</S>
			<S sid ="27" ssid = "3">Besides the two key components, i.e., topic classifier and semantic classifier, our system also contains a preprocessor and a slot- value merger.</S>
			<S sid ="28" ssid = "4">Figure 1 illustrates the overall system architecture.</S>
			<S sid ="29" ssid = "5">It also describes the whole SLU procedure using an example sentence.</S>
			<S sid ="30" ssid = "6">FRAME: ShowRoute [address] by skipping the words “of the”.</S>
			<S sid ="31" ssid = "7">However, the robust local parser possibly skips the words in the sentence by mistake and produces an incorrect class label.</S>
			<S sid ="32" ssid = "8">To avoid this side-effect, this local parser exploits an embedded decision tree for pruning, of which the details can be seen in (Wu et al., 2005).</S>
			<S sid ="33" ssid = "9">According to our experience, it is fairly easy for a general developer with good understanding of the application to author the small grammar used by the local chart parser and annotate the training cases for the embedded decision tree.</S>
			<S sid ="34" ssid = "10">The work can be finished in several hours.</S>
			<S sid ="35" ssid = "11">2.2 Topic Classification.</S>
			<S sid ="36" ssid = "12">Given the representation of semantic frame, topic classification can be regarded as identifying the frame type.</S>
			<S sid ="37" ssid = "13">It is suited to be dealt using pattern recognition techniques.</S>
			<S sid ="38" ssid = "14">The application of statis Please tell me how can I go from the people&apos;s square to the bund by bus Preprocessor Please tell me how can I go from [location]1 to SLOTS: [route].[origin] = the people&apos;s square [route].[destinat ion] = the bund [route].[transpo rt_type] = busSlot value merger FRAME: ShowRoute [location]1: ShowRoute.[route].[origin] [location] : ShowRoute.[route].[destinat ion] tical pattern techniques to topic classification can improve the robustness of the whole understanding system.</S>
			<S sid ="39" ssid = "15">Also, in our system, topic classification can greatly reduce the search space and hence improve the performance of subsequent semantic classification.</S>
			<S sid ="40" ssid = "16">For example, the total number of slots into which the concept [location] [location]2 by [bus] [bus]: 2 ShowRoute.[route].[tr ansport_type] can be filled in all topics is 33 and the corre sponding maximum number of slots in a single Topic classification Please tell me how can I go from [location]1 to [location]2 by [bus] FRAME: ShowRoute Semantic classification topic is decreased to 10.</S>
			<S sid ="41" ssid = "17">Many statistical pattern recognition techniques have been applied to similar tasks, such as Naïve Figure 1: The System architecture1 2.1 The Preprocessor.</S>
			<S sid ="42" ssid = "18">Usually, the preprocessor is to look for the sub- strings in a sentence that correspond to a semantic class or matching a regular expression and to replace them with the class label, e.g., “Huashan Road” and “1954” are replaced with two class labels [road_name] and [number] respectively.</S>
			<S sid ="43" ssid = "19">In our system, the preprocessor can recognize more complex word sequences, e.g., “1954 Huashan Road” can be recognized as [address] through matching a rule like “[address] Æ [number] [road_name]”.</S>
			<S sid ="44" ssid = "20">The preprocessor is implemented with a local chart parser, which is a variation of Bayes, N-Gram and Support Vector Machines (SVMs) (Wang et al., 2002).</S>
			<S sid ="45" ssid = "21">According to the literature (Wang et al., 2002) and our experiments, the SVMs showed the best performance among many other statistical classifiers.</S>
			<S sid ="46" ssid = "22">Also, it has been showed that active learning can be ef fectively applied to the SVMs (Schohn and Cohn, 2000; Tong and Koller, 2000).</S>
			<S sid ="47" ssid = "23">Therefore, we choose the SVMs as the topic classifier.</S>
			<S sid ="48" ssid = "24">We resorted to the LIBSVM toolkit (Chang and Lin, 2001) to construct the SVMs for our experiments.</S>
			<S sid ="49" ssid = "25">Following the practice in (Wang et al., 2002), the SVMs use a binary valued features vector.</S>
			<S sid ="50" ssid = "26">If the simplest feature (Chinese character) is used, each query is converted J into a feature vector JJK JJK JK ch is the total number of the robust parser introduced in (Wang, 1999).</S>
			<S sid ="51" ssid = "27">The robust local parser can skip noise words in the sentence, which ensures that the system has the low level robustness.</S>
			<S sid ="52" ssid = "28">For example, “1954 of the Huashan Road)” can also be recognized as 1 Because the length is limited, in this paper we only illus-.</S>
			<S sid ="53" ssid = "29">trate all the example sentences in English, which are Chinese sentences, in fact.</S>
			<S sid ="54" ssid = "30">ch = &lt; c h1 ,… , c h|ch | &gt; Chinese characters occur in the corpus) with binary valued elements: 1 if a given Chinese character is in this input sentence or 0 otherwise.</S>
			<S sid ="55" ssid = "31">Due to the existence of the preprocessor, we can also include semantic class labels (e.g., [location]) as features for topic classification.</S>
			<S sid ="56" ssid = "32">Intuitively, the class label features are more informative than the Chinese character features.</S>
			<S sid ="57" ssid = "33">At the same time, including class labels as features can also relieve the data sparseness problem.</S>
			<S sid ="58" ssid = "34">2.3 Topic-dependent Semantic Classifica-.</S>
			<S sid ="59" ssid = "35">tion The job of semantic classification is to assign the concepts with the most likely slots.</S>
			<S sid ="60" ssid = "36">It can also be modeled as a classification problem since the number of possible slot names for each concept is limited.</S>
			<S sid ="61" ssid = "37">Let’s consider the example sentence in Figure 1.</S>
			<S sid ="62" ssid = "38">After the preprocessing and topic classification, we get the preprocessed result “Please tell me how can I go from [location]1 to [location]2 by [bus]?” and the topic ShowRoute.</S>
			<S sid ="63" ssid = "39">We have to work out which slots are to be filled with the values such as [location]2.</S>
			<S sid ="64" ssid = "40">The first clue is the surrounding literal context.</S>
			<S sid ="65" ssid = "41">Intuitively, we can infer that it is a [destination] since a [destination] indicator “to” is before it.</S>
			<S sid ="66" ssid = "42">If [location]1 has already been recognized as a [origin], it is another clue to imply that [location]2 is a [destina tion].</S>
			<S sid ="67" ssid = "43">Since initially the slot context is not available, the slot context is only employed for the semantic re-classification, which will be described in latter section.</S>
			<S sid ="68" ssid = "44">To learn the topic-dependent semantic classifiers, the training sentences need to be annotated against the semantic frame.</S>
			<S sid ="69" ssid = "45">Our annotating scenario is relatively simple and can be performed by general developers.</S>
			<S sid ="70" ssid = "46">For example, for the sentence “Please tell me how can I go from the peo ple’s square to the bund by bus?”, the annotated results are like the following: FRAME: ShowRoute Slots: [route].[origin].[location].( the people’s square) [route].[destination].[location].(the bund) [route].[transport_type].[by_bus].(bus) (2) from _ to (3) ShowRoute.[route].[origin] within the ±2 windows The former two are literal context features.</S>
			<S sid ="71" ssid = "47">Feature (1) is a context-word that tends to indicate ShowRoute.[route].[destination].</S>
			<S sid ="72" ssid = "48">Feature (2) is a collocation that checks for the pattern “from” and “to” immediately before and after the concept [location] respectively, and tends to indicate ShowRoute.[route].[origin].</S>
			<S sid ="73" ssid = "49">The third one is a slot context feature, which tends to imply the target concept [location] is of type Show- Route.[route].[destination].</S>
			<S sid ="74" ssid = "50">In nature, these features are equivalent to the rules in the semantic grammar used by the robust rule-based parser.</S>
			<S sid ="75" ssid = "51">For example, the feature (2) has the same function as the semantic rule “[origin] Æ from [location] to”.</S>
			<S sid ="76" ssid = "52">The advantage of our approach is that we can automatically learn the semantic “rules” from the training data rather than manually authoring them.</S>
			<S sid ="77" ssid = "53">Also, the learned “rules” are intrinsically robust since they may involves gaps, for example, feature (1) allows skipping some noise words between “to” and [location].</S>
			<S sid ="78" ssid = "54">The next problem is how to apply these features when predicting a new case since the active features for a new case may make opposite predictions.</S>
			<S sid ="79" ssid = "55">One simple and effective strategy is employed by the decision list (Rivest, 1987), i.e., always applying the strongest features.</S>
			<S sid ="80" ssid = "56">In a decision list, all the features are sorted in order of descending confidence.</S>
			<S sid ="81" ssid = "57">When a new target concept is classified, the classifier runs down the list and compares the features against the contexts of the target concept.</S>
			<S sid ="82" ssid = "58">The first matched feature is applied to make a predication.</S>
			<S sid ="83" ssid = "59">Obviously, how to measure the confidence of features is a very important issue for the decision list.</S>
			<S sid ="84" ssid = "60">We use the metric described in (Yarowsky, 1994; Golding, 1995).</S>
			<S sid ="85" ssid = "61">Provided that P ( s | f ) &gt; 0 for all i : The corresponding slot names can be automatically extracted from the domain model.</S>
			<S sid ="86" ssid = "62">A domain model is usually a hierarchical structure of c onfid e n c e ( f ) = m a x P ( si i | f ) (1) the relevant concepts in the application domain.</S>
			<S sid ="87" ssid = "63">For every occurrence of a concept in the domain model graph, we list all the concept names along the path from the root to its occurrence position and regard their concatenation as a slot name.</S>
			<S sid ="88" ssid = "64">Thus, the slot name is not flat since it inherits the hierarchy from the domain model.</S>
			<S sid ="89" ssid = "65">With provision of the annotated data, we can collect all the literal and slot context features related to each concept.</S>
			<S sid ="90" ssid = "66">The examples of features for the concept [location] are illustrated as follows: (1) to within the –3 windowsThis value measures the extent to which the con text is unambiguously correlated with one particular slot si . 2.4 Slot-value merging and semantic re-.</S>
			<S sid ="91" ssid = "67">classification The slot-value merger is to combine the slots assigned to the concepts in an input sentence.</S>
			<S sid ="92" ssid = "68">Another simultaneous task of the slot-value merger is to check the consistency among the identified slot-values.</S>
			<S sid ="93" ssid = "69">Since the topic-dependent classifiers corresponding to different concepts are training and running independently, it possibly results in inconsistent predictions.</S>
			<S sid ="94" ssid = "70">Considering the preprocessed word sequence “Please tell me how can I go from [location]1 to [location]2 by [bus]” , they are semantically clashed if [location]1 and [location]2 are both classified as ShowRoute.[route].[origin].</S>
			<S sid ="95" ssid = "71">To relieve this problem, we can use the semantic classifier based on the slot context feature.</S>
			<S sid ="96" ssid = "72">We apply the context features like, for example, “Show labeled frame types (e.g. ShowRoute) of the seed sentences to train a topic classifier through the combination of active learning and self- training.</S>
			<S sid ="97" ssid = "73">The resulting topic classifier is used to label the remaining training sentences with the corresponding topic, which are not selected by active learning.</S>
			<S sid ="98" ssid = "74">Then, we use all the sentences annotated against the semantic frame (including the seed sentences and sentences labeled by active learning) and the remaining training Route.[route].[origin] within the ±k windows”, sentences labeled the topic to train the semantic which tends to imply Show- Route.[route].[destination].</S>
			<S sid ="99" ssid = "75">The literal contexts reflect the local lexical semantic dependency.</S>
			<S sid ="100" ssid = "76">The slot contexts, however, are good at capturing the long distance dependency.</S>
			<S sid ="101" ssid = "77">Therefore, when the slot-value merger finds that two or more slot- value pairs clash, it first anchors the one with the highest confidence.</S>
			<S sid ="102" ssid = "78">Then, it extracts the slot contexts for the other concepts and passes them to the semantic classification module for re- classification.</S>
			<S sid ="103" ssid = "79">If the re- classification results still clash, the dialog system can involve the user in an interactive dialog for clarity.</S>
			<S sid ="104" ssid = "80">The idea of semantic classification and re- classification can be understood as follows: it first finds the concept or slot islands (like partial parsing) and then links them together.</S>
			<S sid ="105" ssid = "81">This mechanism is well-suited for SLU since the spoken utterance usually consists of several phrases and noises (restart, repeats and filled pauses, etc) are most often between them (Ward and Issar, 1994).</S>
			<S sid ="106" ssid = "82">Especially, this phenomena and the out- of-order structures are very frequent in the spoken Chinese utterances.</S>
	</SECTION>
	<SECTION title="Weakly  Supervised  Training  of  the. " number = "3">
			<S sid ="107" ssid = "1">Topic Classifier and Topic-dependent Semantic Classifiers As stated before, to train the classifiers for topic identification and slot-filling, we need to label each sentence in the training set against the semantic frame.</S>
			<S sid ="108" ssid = "2">Although this annotating scenario is relatively minimal, the labeling process is still time-consuming and costly.</S>
			<S sid ="109" ssid = "3">Meanwhile unlabeled sentences are relatively easy to collect.</S>
			<S sid ="110" ssid = "4">Therefore, to reduce the cost of labeling training utterances, we employ weakly supervised techniques for training the topic and semantic classifiers.</S>
			<S sid ="111" ssid = "5">The weakly supervised training of the two classifiers is successive.</S>
			<S sid ="112" ssid = "6">Assume that a small amount of seed sentences are manually labeled against the semantic frame.</S>
			<S sid ="113" ssid = "7">We first exploit the classifiers using a practical bootstrapping technique.</S>
			<S sid ="114" ssid = "8">3.1 Combining Active Learning and Self-.</S>
			<S sid ="115" ssid = "9">training for Topic Classification We employ the strategy of combining active learning and self-training for training the topic classifier, which was firstly proposed in (Tur et al., 2005) and applied to a similar task.</S>
			<S sid ="116" ssid = "10">One way to reduce the number of labeling examples is active learning, which have been applied in many domains (McCallum and Nigam, 1998; Tang et al., 2002; Tur et al., 2005).</S>
			<S sid ="117" ssid = "11">Usually, the classifier is trained by randomly sampling the training examples.</S>
			<S sid ="118" ssid = "12">However, in active learning, the classifier is trained by selectively sampling the training examples (Cohn et al., 1994).</S>
			<S sid ="119" ssid = "13">The basic idea is that the most informative ones are selected from the unlabeled examples for a human to label.</S>
			<S sid ="120" ssid = "14">That is to say, this strategy tries to always select the examples, which will have the largest improvement on performance, and hence minimizes the human labeling effort whilst keeping performance (Tur et al., 2005).</S>
			<S sid ="121" ssid = "15">According to the strategy of determining the informative level of an example, the active learning approaches can be divided into two categories: uncertainty-based and committee- based.</S>
			<S sid ="122" ssid = "16">Here, we employ the uncertainty-based strategy for selective sampling.</S>
			<S sid ="123" ssid = "17">It is assumed that a small amount of labeled examples is initially available, which is used to train a basic classifier.</S>
			<S sid ="124" ssid = "18">Then the classifier is applied to the unannotated examples.</S>
			<S sid ="125" ssid = "19">Typically the most unconfident examples are selected for a human to label and then added to the training set.</S>
			<S sid ="126" ssid = "20">The classifier is retrained and the procedure is repeated until the system performance converges.</S>
			<S sid ="127" ssid = "21">Another alternative for reducing human labeling effort is self-training.</S>
			<S sid ="128" ssid = "22">In self-training, an initial classifier is built using a small amount of annotated examples.</S>
			<S sid ="129" ssid = "23">The classifier is then used to label the unannotated training examples.</S>
			<S sid ="130" ssid = "24">The examples with classification confidence scores over a certain threshold, together with their predicted labels, are added to the training set to retrain the classifier.</S>
			<S sid ="131" ssid = "25">This procedure repeated until the system performance converges.</S>
			<S sid ="132" ssid = "26">These two strategies are complementary and hence can be combined.</S>
			<S sid ="133" ssid = "27">The combination strategy is quite straightforward for pool-based training.</S>
			<S sid ="134" ssid = "28">At each iteration, the current classifier is applied to the examples in the current pool.</S>
			<S sid ="135" ssid = "29">The most unconfident examples in the pool are selected by active learning and labeled by a human.</S>
			<S sid ="136" ssid = "30">The remaining examples in the pool are automatically labeled by the current classifier.</S>
			<S sid ="137" ssid = "31">Then, these two parts of labeled examples are both added into the training set and used for retraining Thus, many language processing problems can be dealt using the bootstrapping methods since language is highly redundant (Yarowsky, 1995).</S>
			<S sid ="138" ssid = "32">The semantic classification problem here also exhibits the redundancy.</S>
			<S sid ="139" ssid = "33">In the example “Please tell me how can I go from [location]1 to [location]2 by [bus]?”, there are multiple literal context features which all indicate that [location]1 is of type ShowRoute.[route].[origin], such as: (1) from within the –1 windows; (2) from _ to ; (3) to within the +1 windows.</S>
			<S sid ="140" ssid = "34">If the [location]2 has already be recognized as ShowRoute.[route].[destination], thus the slot context feature “ShowRoute.[route].[origin]the classifier.</S>
			<S sid ="141" ssid = "35">Since the LIBSVM toolkit pro within the±2 windows” is also a strong evi vides the class probability, we directly use the class probability as the confidence score.</S>
			<S sid ="142" ssid = "36">Our dynamic pool-based (the pool size is n ) algorithm of combining active learning and self- training for training the topic classifier is as follows: 1.</S>
			<S sid ="143" ssid = "37">Given a small amount of human-labeled.</S>
			<S sid ="144" ssid = "38">dence that [location]1 is of type Show- Route.[route].[origin].</S>
			<S sid ="145" ssid = "39">That is to say, the literal context and slot context features above effectively overdetermine the slot of a concept in the input sentence.</S>
			<S sid ="146" ssid = "40">Especially, the literal and slot context features can be seen as two natural “views” of an example from the respective of training set t ( n sentences) and a larger “Co-Training” (Blum and Mitchell, 1998).</S>
			<S sid ="147" ssid = "41">Our amount of unlabeled set S u , build the initial classifier using S t . 2.</S>
			<S sid ="148" ssid = "42">While labelers/ sentences are available.</S>
			<S sid ="149" ssid = "43">(a) Get n unlabeled sentences from S u bootstrapping algorithm exploits the property of redundancy to incrementally identify the features for assigning slots of a concept, given a few annotated seed sentences.</S>
			<S sid ="150" ssid = "44">The bootstrapping algorithm is performed on(b) Apply the current classifier to n unla each topic Ti ( 1 ≤ i ≤ n , n is the number of beled sentences(c) Select m examples which are most in topic) as follows: 1.</S>
			<S sid ="151" ssid = "45">For each concept C j. in Ti (1 ≤ j ≤ m , m is formative to the current classifier andthe number of concepts appears in the senmanually label the selected m exam ples tences of topic Ti ): (d) Add the m human-labeled examples (1.1) Build the two initial classifiers based on and the remaining n − mmachine literal and slot context features respec labeled examples to the training set t (e) Train a new classifier on all labeled examples 3.2 Bootstrapping the Topic-dependent.</S>
			<S sid ="152" ssid = "46">tively using a small amount of labeled seed sentences.</S>
			<S sid ="153" ssid = "47">(1.2) Apply the current classifier based on the literal context feature to the remaining unlabeled concepts in the training sen Semantic Classifiers tences belong to topic Ti . Keep those Bootstrapping refers to a problem of inducing a classifier given a small set of labeled data and a large set of unlabeled data (Abney, 2002).</S>
			<S sid ="154" ssid = "48">It has been applied to problems such as word-sense disambiguation (Yarowsky, 1995), web-page classification (Blum and Mitchell, 1998), named- entity recognition (Collins and Singer, 1999) and automatic construction of semantic lexicon (Thelen and Riloff, 2003).</S>
			<S sid ="155" ssid = "49">The key to the boot- strapping methods is to exploit the redundancy in the unlabeled data (Collins and Singer, 1999).</S>
			<S sid ="156" ssid = "50">classified slots with confidence score above a certain threshold (In this paper, the threshold is fixed on 0.5).</S>
			<S sid ="157" ssid = "51">2.</S>
			<S sid ="158" ssid = "52">Check the consistency of the classified slots.</S>
			<S sid ="159" ssid = "53">in each sentence.</S>
			<S sid ="160" ssid = "54">If some slots in a sentence clashed, take the one with the highest confidence score among them and leave the others unlabeled.</S>
			<S sid ="161" ssid = "55">3.</S>
			<S sid ="162" ssid = "56">For each concept C j in Ti , apply the current.</S>
			<S sid ="163" ssid = "57">classifier based on the slot context to the residual unlabeled concepts.</S>
			<S sid ="164" ssid = "58">Keep those classi fied slots with confidence score above a certain threshold.</S>
			<S sid ="165" ssid = "59">Repeat Step 3.</S>
	</SECTION>
	<SECTION title="Augment the new classified cases into the. " number = "4">
			<S sid ="166" ssid = "1">training set and retrain the two classifiers based on literal and slot context features respectively.</S>
	</SECTION>
	<SECTION title="If new slots are classified from the training. " number = "5">
			<S sid ="167" ssid = "1">data, return to step 2.</S>
			<S sid ="168" ssid = "2">Otherwise, repeat 25 to label training data and keep all new classified slots regardless of the confidence score.</S>
			<S sid ="169" ssid = "3">Train the two final semantic classifiers based on the literal and context features respec tively using the new labeled training data.</S>
			<S sid ="170" ssid = "4">4 Experiments and Results.</S>
			<S sid ="171" ssid = "5">4.1 Data Collection and Experimental Set-.</S>
			<S sid ="172" ssid = "6">ting Our experiments were carried out in the context of Chinese public transportation information inquiry domain.</S>
			<S sid ="173" ssid = "7">We collected two kinds of corpus for our domain using different ways.</S>
			<S sid ="174" ssid = "8">Firstly, a natural language corpus was collected through a specific website which simulated a dialog system.</S>
			<S sid ="175" ssid = "9">The user can conduct some mixed-initiative conversational dialogues with it by typing Chinese queries.</S>
			<S sid ="176" ssid = "10">Then we collected 2,286 natural language utterances through this way.</S>
			<S sid ="177" ssid = "11">It was divided into two parts: the training set contained 1,800 sentences (TR), and the test set contained 486 sentences (TS1).</S>
			<S sid ="178" ssid = "12">Also, a spoken language corpus was collected through the deployment of a preliminary version of telephone-based dialog system, of which the speech recognizer is based on the speaker-independent Chinese dictation system of IBM ViaVoice Telephony and the SLU component is a robust rule-based parser.</S>
			<S sid ="179" ssid = "13">The spoken utterances corpus contained 363 spoken utterances.</S>
			<S sid ="180" ssid = "14">Then we obtained two test set from this corpus: one consisted of the recognized text (TS2); the other consisted of the corresponding transcription (TS3).</S>
			<S sid ="181" ssid = "15">The Chinese character error rate and concept error rate of TS2 are 35.6% and 41.1% respectively.</S>
			<S sid ="182" ssid = "16">We defined ten types of topic for our domain: ListStop, ShowFare, ShowRoute, ShowRouteTime, etc. The first corpus covers all the ten topic types and the second corpus only covers four topic types.</S>
			<S sid ="183" ssid = "17">The total number of Chinese characters appear in the data set is 923.</S>
			<S sid ="184" ssid = "18">All the sentences were annotated against the semantic frame.</S>
			<S sid ="185" ssid = "19">In our experiments, the topic classifier and semantic classifiers were trained on the natural language training set (TR) and tested on three test sets (TS1, TS2 and TS3).</S>
			<S sid ="186" ssid = "20">The performance of topic classification and semantic classification are measured in terms of topic error rate and slot error rate respectively.</S>
			<S sid ="187" ssid = "21">Topic performance is measured by comparing the topic of a sentence predicated by the topic classifier with the reference topic.</S>
			<S sid ="188" ssid = "22">The slot error rate is measured by counting the insertion, deletion and substitution errors between the slots generated by our system and these in the reference annotation.</S>
			<S sid ="189" ssid = "23">4.2 Supervised Training Experiments.</S>
			<S sid ="190" ssid = "24">Firstly, in order to validate the effectiveness of our proposed SLU system using successive learners, we compared our system with a rule- based robust semantic parser.</S>
			<S sid ="191" ssid = "25">The parsing algorithm of this parser is same as the local chart parser used by the preprocessor.</S>
			<S sid ="192" ssid = "26">The handcrafted grammar for this semantic parser took a linguistic expert one month to develop, which consists of 798 rules (except the lexical rules for named entities such as [loc_name]).</S>
			<S sid ="193" ssid = "27">In our SLU system, we first use the SVMs to identify the topic and then apply the semantic classifier (decision list) related to the identified topic to assign the slots to the concepts.</S>
			<S sid ="194" ssid = "28">The SVMs used the augmented binary features (923 Chinese characters and 20 semantic class labels).</S>
			<S sid ="195" ssid = "29">A general developer independently annotated the TR set against the semantic frame, which took only four days.</S>
			<S sid ="196" ssid = "30">Through feature extraction from the TR set and feature pruning, we obtained 2,259 literal context features and 369 slot context features for 20 kinds of concepts in our domain.</S>
			<S sid ="197" ssid = "31">Table 1 Shows that our SLU method has better performance than the rule-based robust parser in both topic classification and slot identification.</S>
			<S sid ="198" ssid = "32">Due to the high concept error rate of recognized utterances, the performance of semantic classification on the TS2 is relatively poor.</S>
			<S sid ="199" ssid = "33">However, if considering only the correctly identified concepts on TS2, the slot error rate is 9.2%.</S>
			<S sid ="200" ssid = "34">Note that, since the TS2 (recognized speech) covers only four types of topic but TS1 (typed utterance) covers ten topics, the topic error on the TS2 (recognized speech) is lower than that on TS1.</S>
			<S sid ="201" ssid = "35">Table 1 also compares our system with the two-stage classification with the reversed order.</S>
			<S sid ="202" ssid = "36">Another alternative for our system is to reverse the two main processing stages, i.e., finding the roles for the concepts prior to identifying the topic.</S>
			<S sid ="203" ssid = "37">For instance, in the example sentence in Fig.1, the concept (e.g., [location]) in the pre- processed sequence is first recognized as slots (e.g., [route].[origin]) before topic classification.</S>
			<S sid ="204" ssid = "38">Therefore, the slots like [route].[origin] can be included as features for topic classification, which is deeper than the concepts like [location] and potential to achieve improvement on performance of topic classification.</S>
			<S sid ="205" ssid = "39">This strategy was adopted in some previous works (He and Young, 2003; Wutiwiwatchai and Furui, 2003).</S>
			<S sid ="206" ssid = "40">However, the results indicate that, at least in our two-stage classification formwork, the strategy of identifying the topic before assigning the slots to the concepts is more optimal.</S>
			<S sid ="207" ssid = "41">According to our error analysis, the unsatisfied performance of the reversed two-stage classification system can be explained as follows: (1) Since the semantic classification is performed on all topics, the plots the learning curves of three strategies trained on TR and tested on the TS1 set.</S>
			<S sid ="208" ssid = "42">It is evident that active learning significantly reduces the need for labeled data.</S>
			<S sid ="209" ssid = "43">For instance, it requires 1600 examples if they are randomly chosen to achieve a topic error rate of 3.2% on TS1, but only 600 actively selected examples, a saving of 62.5%.</S>
			<S sid ="210" ssid = "44">The strategy of combing active learning and self-training can further improve the performance of topic classification compared with active learning only with the same amount of labeled data.</S>
			<S sid ="211" ssid = "45">10.00% Random 9.00% search space is much bigger and the ambiguities increase.</S>
			<S sid ="212" ssid = "46">This deteriorates the performance of semantic classification.</S>
			<S sid ="213" ssid = "47">(2) In the case that the slots and Chinese characters are included as features, the topic classifier relies heavily on the slot features.</S>
			<S sid ="214" ssid = "48">Then, the errors of semantic classification have serious negative effect on the topic classification.</S>
			<S sid ="215" ssid = "49">Table 1: Performance comparsion of the rule- based robust semantic parser, the reversed two- stage classification system and our SLU systems 8.00% 7.00% 6.00% 5.00% 4.00% 3.00% 2.00% Active Learning Active Learning &amp; Self-traing 0 200 400 600 800 1000 1200 1400 1600 1800 2000 Number of labeled sentences (TER: Topic Error Rate; SER: Slot Error Rate; DL: Decision List) T S 1 T S 2 T S 3 TE R (% ) SE R ( %) TE R (% ) SE R ( %) TE R (%) SE R ( %) Rule ba se d se m an tic pa rs er 6.</S>
			<S sid ="216" ssid = "50">8 11.</S>
			<S sid ="217" ssid = "51">6 4.</S>
			<S sid ="218" ssid = "52">1 47.</S>
			<S sid ="219" ssid = "53">9 3.0 5.4 R e v e rs e d t w o sta ge cl as sif ic a- tio n sy ste m 4.</S>
			<S sid ="220" ssid = "54">9 11.</S>
			<S sid ="221" ssid = "55">1 3.</S>
			<S sid ="222" ssid = "56">6 47.</S>
			<S sid ="223" ssid = "57">4 2.5 4.9 O u r s y s t e m 2.</S>
			<S sid ="224" ssid = "58">9 8.</S>
			<S sid ="225" ssid = "59">4 2.</S>
			<S sid ="226" ssid = "60">2 45.</S>
			<S sid ="227" ssid = "61">6 1.4 4.6 4.3 Weakly Supervised Training.</S>
			<S sid ="228" ssid = "62">Experiments 4.3.1 Active Learning and Self-training Experiments for Topic Classification In order to evaluate the performance of active learning and self-training, we compared three sampling strategies: random sampling, active learning only, active learning and self-training.</S>
			<S sid ="229" ssid = "63">At each iteration of pool-based active learning and self-training, we get 200 sentences (i.e., the pool size is set as 200) and select 50 most unconfident sentences from them for manually labeling and exploit the remaining sentences using self- training.</S>
			<S sid ="230" ssid = "64">All the experiments were repeated ten times with different randomly selected seed sentences and the results were averaged.</S>
			<S sid ="231" ssid = "65">Figure 1Figure 2: Learning curves using different sam pling strategies.</S>
			<S sid ="232" ssid = "66">We also evaluated the performance of topic classification using active learning and self- training with the pool size of 200 on the three test sets.</S>
			<S sid ="233" ssid = "67">Table 2 shows that active learning and self-training with the pool size of 200 achieves almost the same performance on three test sets as random sampling, but requires only 33.3% data.</S>
			<S sid ="234" ssid = "68">Table 2: The topic error rate using active learning and self-training with pool size of 200 on the three test sets (AL: Active Learning) T S 1 ( % ) TS 2 (% ) TS 3 (% ) L ab el ed S en t.( #) R a n d o m 2 . 9 2.</S>
			<S sid ="235" ssid = "69">2 1.</S>
			<S sid ="236" ssid = "70">4 1 , 8 0 0 A L 3 . 2 2.</S>
			<S sid ="237" ssid = "71">5 1.</S>
			<S sid ="238" ssid = "72">7 6 0 0 A L &amp; self tr ai ni ng 2 . 9 2.</S>
			<S sid ="239" ssid = "73">5 1.</S>
			<S sid ="240" ssid = "74">4 6 0 0 4.3.2 Bootstrapping Experiments for Semantic Classification As stated before, the bootstrapping procedure begins with a small amount of sentences anno tated against the semantic frame, which is the initial seed sentence or annotated by active learning, and the remaining training sentences, the topics of which are machine-labeled by the resulting topic classifier.</S>
			<S sid ="241" ssid = "75">For example, in the weakly supervised training scenario with the pool size of 200, the active learning and self- training procedure ran 8 iterations.</S>
			<S sid ="242" ssid = "76">At each iteration, 50 sentences were selected by active learning.</S>
			<S sid ="243" ssid = "77">So the total number of labeled sentences is 600.</S>
			<S sid ="244" ssid = "78">We compared our bootstrapping methods.</S>
			<S sid ="245" ssid = "79">with supervised training for semantic classification.</S>
			<S sid ="246" ssid = "80">We tried two bootstrapping methods: using only the literal context features (Bootstrapping 1) and using the literal and slot context features (Bootstrapping 2).</S>
			<S sid ="247" ssid = "81">If the step 4 of the bootstrap- ping algorithm in Section 3.2 is canceled, the new bootstrapping variation corresponds to Bootstrapping 2.</S>
			<S sid ="248" ssid = "82">Also, we repeated the experiments ten times with different labeled sentences and the results were averaged.</S>
			<S sid ="249" ssid = "83">Figure 3 plots the learning curves of bootstrapping and supervised training with different number of labeled sentences on the TS1 set.</S>
			<S sid ="250" ssid = "84">The results indicate that bootstrapping methods can effectively make use of the unlabeled data to improve the semantic classification performance.</S>
			<S sid ="251" ssid = "85">In particular, the learning curve of bootstrapping 1 achieves more significant improvement than the curve of boot- strapping 2.</S>
			<S sid ="252" ssid = "86">It can be explained as follows: including the slot context features further increases the redundancy of data and hence corrects the initial misclassified cases by the semantic classifier using only literal context features or provides new cases.</S>
			<S sid ="253" ssid = "87">20.00% trained using only 600 labeled sentences.</S>
			<S sid ="254" ssid = "88">Table 3 shows that the weakly supervised scenario achieves comparable performance to the supervised one, but requires only 33.3% labeled data.</S>
			<S sid ="255" ssid = "89">Table 3: Performance comparison of two SLU systems through weakly supervised and supervised training on the three test sets (TER: Topic Error Rate; SER: Slot Error Rate) T S 1 T S 2 T S 3 TE R (% ) SE R (% ) TE R (% ) SE R (% ) TE R (% ) SE R (% ) S up er vi se d 2.</S>
			<S sid ="256" ssid = "90">9 8.</S>
			<S sid ="257" ssid = "91">4 2.</S>
			<S sid ="258" ssid = "92">2 45.</S>
			<S sid ="259" ssid = "93">6 1.4 4.</S>
			<S sid ="260" ssid = "94">6 W e a k l y S u p e r v i s e d 2.</S>
			<S sid ="261" ssid = "95">9 9.</S>
			<S sid ="262" ssid = "96">7 2.</S>
			<S sid ="263" ssid = "97">5 44.</S>
			<S sid ="264" ssid = "98">8 1.4 5.</S>
			<S sid ="265" ssid = "99">7 5 Conclusion and Future work.</S>
			<S sid ="266" ssid = "100">We have presented a new SLU framework using two successive classifiers.</S>
			<S sid ="267" ssid = "101">The proposed framework exhibits the advantages as follows.</S>
			<S sid ="268" ssid = "102">z It has good robustness on processing spoken language: (1) The preprocessor provides the low level robustness.</S>
			<S sid ="269" ssid = "103">(2) It inherits the robustness of topic classification using statistical pattern recognition techniques.</S>
			<S sid ="270" ssid = "104">It can also make use of topic classification to guide slot filling.</S>
			<S sid ="271" ssid = "105">(3) The strategy of first finding the concepts or slot islands and then linking them is suited for processing spoken language.</S>
			<S sid ="272" ssid = "106">18.00% 16.00% 14.00% 12.00% 10.00% 8.00% 6.00% S u p e r v i s e d t r a i n i n g B o o t s t r a p p i n g 1 B o o t s t r a p p i n g 2 0 100 200 300 400 500 600 700 N u m b e r o f l a b e l e d s e n t e n c e s z It also keeps the understan ding deepness: (1) The clas s of sem anti c clas sific atio n is the slot nam e, whi ch inhe rits the hier arch y fro m the dom ain mod el.</S>
			<S sid ="273" ssid = "107">(2) The sem anti c re- clas sific atio n mec hani sm ensu res the cons is- tenc y amo ng the iden tifie d slot valu e pair s. z It is mai nly data driv en and requ ires only mini mall y ann otat ed corp us for train ing.</S>
			<S sid ="274" ssid = "108">Mos t imp orta ntly, our prop osed SLU fram ewo rk allo ws the emp loy men t of wea kly supe rvis ed strat egie s for train ing the two clas sifie rs, whi ch can redu ce the cost of a n n o t a t i n g l a b e l e d s e n t e n c e s . The future work includ es further evaluat ion of Figure 3: Learning curves of bootstrapping methods for semantic classification on TS1.</S>
			<S sid ="275" ssid = "109">Finally, we compared two SLU systems through weakly supervised and supervised training respectively.</S>
			<S sid ="276" ssid = "110">The supervised one was trained using all the annotated sentences in TR (1800 sentences).</S>
			<S sid ="277" ssid = "111">In the weakly supervised training scenario (the pool size is still 200), The topic classifier and semantic classifiers were both our approach in other application domains and languages.</S>
			<S sid ="278" ssid = "112">We also plan to integrate this understanding system into a whole dialog system.</S>
			<S sid ="279" ssid = "113">Then, high level knowledges, such as the dialog context, can also be included as the features of topic and semantic classifiers.</S>
			<S sid ="280" ssid = "114">Moreover, currently, the topics are manually defined through examination of the example sentences by human.</S>
			<S sid ="281" ssid = "115">Then, it is worthwhile to investigate how to appropriately define topics and the probability of exploiting the sentence clustering techniques to facilitate the topic (frame) designment.</S>
	</SECTION>
	<SECTION title="Acknowledgements. " number = "6">
			<S sid ="282" ssid = "1">The authors would like to thank three anonymous reviewers for their careful reading and helpful suggestions.</S>
			<S sid ="283" ssid = "2">This work is supported by National Natural Science Foundation of China (NSFC, No. 60496326) and 863 project of China (No. 2001AA11421011).</S>
	</SECTION>
</PAPER>
