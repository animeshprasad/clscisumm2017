<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">Morphology and syntax interact considerably in many languages and language processing should pay attention to these interdependencies.</S>
		<S sid ="2" ssid = "2">We analyze the effect of syntactic features when used in automatic morphology prediction on four typologically different languages.</S>
		<S sid ="3" ssid = "3">We show that predicting morphology for languages with highly ambiguous word forms profits from taking the syntactic context of words into account and results in state-of- the-art models.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="4" ssid = "4">In this paper, we investigate the interplay between syntax and morphology with respect to the task of assigning morphological descriptions (or tags) to each token of a sentence.</S>
			<S sid ="5" ssid = "5">Specifically, we examine the effect of syntactic information when it is integrated into the feature model of a morphological tag- ger.</S>
			<S sid ="6" ssid = "6">We test the effect of syntactic features on four languages – Czech, German, Hungarian, and Spanish – and find that syntactic features improve our tag- ger considerably for Czech and German, but not for Hungarian and Spanish.</S>
			<S sid ="7" ssid = "7">Our analysis of constructions that show morpho-syntactic agreement suggests that syntactic features are important if the language shows frequent word form syncretisms1 that by morphological and syntactic means.2 Different languages, however, use them to a different extent.</S>
			<S sid ="8" ssid = "8">Languages like English encode grammatical information (like the subject vs object status of an argument) via word order, whereas languages like Czech or Hungarian use different word forms.</S>
			<S sid ="9" ssid = "9">Automatic analysis of languages with rich morphology needs to pay attention to the interaction between morphology and syntax in order to arrive at suitable computational models.</S>
			<S sid ="10" ssid = "10">Linguistic theory (e. g., Bresnan (2001), Melcˇuk (2009)) suggests many interactions between morphology and syntax.</S>
			<S sid ="11" ssid = "11">For example, languages with a case system use different forms of the same word to mark different syntactic (or semantic) relations (Blake, 2001).</S>
			<S sid ="12" ssid = "12">In many languages, two words that participate in a syntactic relation show covariance in some or all of their morphological features (so-called agreement, Corbett (2006)).3 Automatic annotation of morphology assigns morphological descriptions (e. g., nominative- singular-masculine) to word forms.</S>
			<S sid ="13" ssid = "13">It is usually modeled as a sequence model, often in combination with part-of-speech tagging and lemmatization (Collins, 2002; Hajicˇ, 2004; Smith et al., 2005; Chrupała et al., 2008, and others).</S>
			<S sid ="14" ssid = "14">Sequence models achieve high accuracy and coverage but since they only use linear context they only approximate some of the underlying hierarchical relationships.</S>
			<S sid ="15" ssid = "15">As an example for these hierarchical relationships, can be disambiguated by the syntactic context.</S>
			<S sid ="16" ssid = "16">The meaning of a sentence is structurally encoded 1 Syncretism describes the situation where a word form is ambiguous between several different morphological descriptions within its inflection paradigm.</S>
			<S sid ="17" ssid = "17">since text-based tools rarely have access to this information.</S>
			<S sid ="18" ssid = "18">3 For example, in English, the subject of a sentence and the.</S>
			<S sid ="19" ssid = "19">finite verb agree with respect to their number and person feature.</S>
			<S sid ="20" ssid = "20">NK NK CJ MO CJ MO PM MO CD NK MO die wirtschaftlich am weitesten entwickelten , modernen und zum Teil katholisch gepra¨gten Regionen nom/acc.pl.fem nom/acc.pl.fem the economic - most developed , modern and to part catholic influenced regions ’the regions that are economically most developed, modern, and partly catholic’ Figure 1: Example of a German noun phrase.</S>
			<S sid ="21" ssid = "21">First and last word agree in number, gender, and case value.</S>
			<S sid ="22" ssid = "22">Figure 1 shows a German noun phrase taken from the German TiGer corpus (Brants et al., 2002).</S>
			<S sid ="23" ssid = "23">The two bold-faced words are the determiner and the head noun of the phrase, and they agree in their gender, number, and case values.</S>
			<S sid ="24" ssid = "24">The word Regionen (regions) is four-way ambiguous for its case value, which is reduced to a two-way ambiguity between nominative and accusative by the determiner.</S>
			<S sid ="25" ssid = "25">Further disambiguation would require information about the syntactic role of the noun phrase in a sentence.</S>
			<S sid ="26" ssid = "26">There are 11 tokens between these two words, which would require a context window of at least 13 to capture the agreement relation within a sequence model.</S>
			<S sid ="27" ssid = "27">Syntactically, however, as indicated by the dependency tree, the determiner and the head are linked directly.</S>
			<S sid ="28" ssid = "28">The interdependency between morphology and syntax in the example thus manifests itself in the morphological disambiguation of a highly syncretic word form because of its government or agreement relation to its respective syntactic head/dependents.</S>
			<S sid ="29" ssid = "29">Of course, the sequence model is most of the time a reasonable approximation, because the majority of noun phrases in the TiGer corpus are not as long as the example in Figure 1.4 Furthermore, not all languages show this kind of relationship between morphological forms and syntactic relation as demonstrated for German.</S>
			<S sid ="30" ssid = "30">But taking advantage of the morphosyntactic dependencies in a language can give us better models that may even be capable of handling the more difficult or rare cases.</S>
			<S sid ="31" ssid = "31">We therefore advocate that models for predicting morphology should be designed with the typological characteristics of a language and its morphosyntactic properties in mind, and should, where appropriate, integrate 4 We find 57,551 noun phrases with less than three tokens between determiner and noun and 4,670 with three or more.</S>
			<S sid ="32" ssid = "32">syntactic information in order to better model the morphosyntactic interdependencies of the language.</S>
			<S sid ="33" ssid = "33">In the remainder of the paper, we show empirically that taking syntactic information into account produces state-of-the-art models for languages with a high interdependency between morphology and syntax.</S>
			<S sid ="34" ssid = "34">We use a simple setup, where we combine a morphological tagger and a dependency parser in a bootstrapping architecture in order to analyze the effect of syntactic information on the performance of the morphological tagger (Section 2).</S>
			<S sid ="35" ssid = "35">Using syntactic features in morphology prediction requires a syntactically annotated corpus for training a statistical parser, which may not be available for languages with few resources.</S>
			<S sid ="36" ssid = "36">We show in Section 3 that only very little syntactically annotated data is required to achieve the improvements.</S>
			<S sid ="37" ssid = "37">We furthermore expect that the improved morphological information also improves parsing performance and present a preliminary experiment in Section 4.</S>
	</SECTION>
	<SECTION title="Experiments. " number = "2">
			<S sid ="38" ssid = "1">In this section, we present a series of experiments that investigate the effect of syntactic information on the prediction of morphological features.</S>
			<S sid ="39" ssid = "2">We start by describing our data sets and the system that we used for the experiments.</S>
			<S sid ="40" ssid = "3">2.1 Languages and Data Sets.</S>
			<S sid ="41" ssid = "4">We test our hypotheses on four different languages: Czech, German, Hungarian, and Spanish.</S>
			<S sid ="42" ssid = "5">Spanish, a Romance language, and German, a Germanic language, constitute inflecting languages that show verbal and nominal morphology, but not as sophisticated as Czech and Hungarian.</S>
			<S sid ="43" ssid = "6">As we will see in the experiments, it is relatively easy to predict the morphological information annotated in the Spanish data set.</S>
			<S sid ="44" ssid = "7">Czech and Hungarian represent languages with very rich morphological systems both in verbal and nominal morphological paradigms.</S>
			<S sid ="45" ssid = "8">They differ significantly in the way in which morphological information is encoded in word forms.</S>
			<S sid ="46" ssid = "9">Czech, a Slavic language, is an inflecting language, where one suffix may signal several different morphological categories simultaneously (e. g., number, gender, case).</S>
			<S sid ="47" ssid = "10">In contrast, Hungarian, a FinnoUgric language, is of the agglutinating type, where each morphological category is marked by its own morpheme.</S>
			<S sid ="48" ssid = "11">Both German and Czech show various form syncretisms in their inflection paradigms.</S>
			<S sid ="49" ssid = "12">Form syncretisms emerge when the same word form is ambiguous between several different morphological descriptions, and they are a major challenge to automatic morphological analysis.</S>
			<S sid ="50" ssid = "13">Spanish shows syncretism in the verbal inflection paradigms.</S>
			<S sid ="51" ssid = "14">In Hungarian, form syncretisms are much less frequent.</S>
			<S sid ="52" ssid = "15">The case paradigm of Hungarian only shows one form syncretism between dative and genitive case (out of about 18 case suffixes).</S>
			<S sid ="53" ssid = "16">All languages show agreement between subject and verb, and within the noun phrase.</S>
			<S sid ="54" ssid = "17">The word order in Czech and Hungarian is very variable whereas it is more restrictive in Spanish and German.</S>
			<S sid ="55" ssid = "18">As our data, we use the CoNLL 2009 Shared its feature model.</S>
			<S sid ="56" ssid = "19">Models are trained using passive- aggressive online training (Crammer et al., 2003).</S>
			<S sid ="57" ssid = "20">The system makes two passes over each sentence: The first pass provides predicted tags that are used as features during the second pass.</S>
			<S sid ="58" ssid = "21">We also adopted the idea of a tag filter, which deterministically assigns tags for words that always occur with the same tag in the training data.</S>
			<S sid ="59" ssid = "22">For all matters of syntactic annotation in this paper, we use the graph-based dependency parser by Bohnet (2010), also included in mate-tools.</S>
			<S sid ="60" ssid = "23">All data sets are annotated with gold syntactic information, which is used to train the parsing models.</S>
			<S sid ="61" ssid = "24">For our experiments, we use a bootstrapping approach: the parser uses the output of the morphology in its feature set, and the morphological tagger we want to analyze uses the output of the parser as syntactic features.</S>
			<S sid ="62" ssid = "25">Since it is best to keep the training setting as similar as possible to the test setting, we use 10-fold jackknifing to annotate our training data with predicted morphology or syntax respectively.</S>
			<S sid ="63" ssid = "26">Jackknifing differs from cross-validation only in its purpose.</S>
			<S sid ="64" ssid = "27">Cross-validation is used for evaluating data, jackknifing is used to annotate data.</S>
			<S sid ="65" ssid = "28">The data set is split into n parts, and n-1 parts are used to train a model for annotating the nth part.</S>
			<S sid ="66" ssid = "29">This is then rotated n times such that each part is annotated by the automatic tool without training it on its own test data.</S>
			<S sid ="67" ssid = "30">Jackknifing is important for creating a realis Task data sets (Hajicˇ et al., 2009) for Czech and tic training scenario that provides automatic prepro Spanish.</S>
			<S sid ="68" ssid = "31">For German, we use the dependency conversion of the TiGer treebank by Seeker and Kuhn (2012), splitting it into 40k/5k/5k sentences for training/development/test.</S>
			<S sid ="69" ssid = "32">For Hungarian, we use the Szeged Dependency Treebank (Vincze et al., 2010), with the split of Farkas et al.</S>
			<S sid ="70" ssid = "33">(2012).</S>
			<S sid ="71" ssid = "34">2.2 System Description.</S>
			<S sid ="72" ssid = "35">To test our hypotheses, we implemented a tagger that assigns full morphological descriptions to each token in a sentence.</S>
			<S sid ="73" ssid = "36">The system was inspired by the morphological tagger included in mate-tools.5 Like the tagger provided with mate-tools, it is a classifier that tags each token using the surrounding tokens in 5 A collection of language independent, data-driven analysis tools for lemmatization, pos-tagging, morphological analysis, and dependency parsing: http://code.google.com/p/mate-tools cessing.</S>
			<S sid ="74" ssid = "37">For annotating development and test sets, models are trained on the jackknifed training set.</S>
			<S sid ="75" ssid = "38">2.3 The Effects of Syntactic Features.</S>
			<S sid ="76" ssid = "39">In the first experiment, we use the system described in Section 2.2 to predict morphological information on all four languages.</S>
			<S sid ="77" ssid = "40">We start with describing the general setup and the feature set, and continue with a discussion of the results.</S>
			<S sid ="78" ssid = "41">The experimental setup is as follows: the German and Spanish data sets are annotated with lemma and part-of-speech information using 10-fold jackknifing.</S>
			<S sid ="79" ssid = "42">The annotation is done with mate-tools’ lemmatizer and postagger.</S>
			<S sid ="80" ssid = "43">For Czech and Hungarian, we keep the annotation provided with the data sets.</S>
			<S sid ="81" ssid = "44">Note that our experimental setup does not include lemmas or part-of-speech tags as part of the prediction of the morphology but annotates them in a pre processing step.</S>
			<S sid ="82" ssid = "45">It is not necessary to separate part- of-speech and lemma from the prediction of morphology and, in fact, many systems perform these steps simultaneously (e. g. Spoustova´ et al.</S>
			<S sid ="83" ssid = "46">(2009)).</S>
			<S sid ="84" ssid = "47">Doing morphology prediction as a separate step allows us to use lemma and part-of-speech information in the feature set.6 The feature sets in Table 1 were developed specifically for our experiments and are the result of an automatic forward/backward feature selection process.</S>
			<S sid ="85" ssid = "48">The purpose of the feature selection was to arrive at a baseline system that performs well without any syntactic information.</S>
			<S sid ="86" ssid = "49">With such an optimized baseline system, we can measure the contribution of syntactic features more reliably.</S>
			<S sid ="87" ssid = "50">static features form form1b form2b form3b form1a lemma2a pos1b pos2b pos1a form+pos pos+s1 pos+s2 pos+s3 pos+s4 lemma+p2 lemma+p3 pos+number form+form1b pos+pos1a pos+pos1b+pos2b s1+s1 1b s1+s1 1a s2+s2 1a last-verb-lemma last-verb-pos next-verb-lemma next-verb-pos dynamic features pos1b+case1b+pos2b+case2b Hungarian only features pos+uppercase Czech only features The last-verb/next-verb and pos+case features are variants of the features proposed in Votrubec (2006).</S>
			<S sid ="88" ssid = "51">They extract information about the first verb within the last 10/the next 30 tokens in the sentence.</S>
			<S sid ="89" ssid = "52">The case feature extracts the case value from previously assigned morphological tags.</S>
			<S sid ="90" ssid = "53">Note that the verb features are approximating syntactic information by making the assumption that the closest verbs are likely to be syntactic heads for many words.</S>
			<S sid ="91" ssid = "54">static features dynamic features h tag ld tag pos+p2 Spanish only features Table 2: Syntactic features.</S>
			<S sid ="92" ssid = "55">h and ld mark features from s5 p1 p4 p5 s2 1a s3 1a s4 1a Table 1: Baseline feature set.</S>
			<S sid ="93" ssid = "56">form means word form, lemma is lemma, pos is part-of-speech, s1/p1 stand for suffix and prefix of length 1 (characters), tag is the morphological tag predicted by the system, 1b/1a means 1 token before/after the current token, and + marks feature conjunctions.</S>
			<S sid ="94" ssid = "57">number marks if the form contains a digit.</S>
			<S sid ="95" ssid = "58">After preprocessing the data, our baseline system is trained using the feature set shown in Table 1.</S>
			<S sid ="96" ssid = "59">The baseline system does not make use of any syntactic information but predicts morphological information based solely on tokens and their linear context.</S>
			<S sid ="97" ssid = "60">The features are divided into static features, which can be computed on the input, and dynamic features, which are computed also on previous output of the system (cf.</S>
			<S sid ="98" ssid = "61">two passes in Section 2.2).</S>
			<S sid ="99" ssid = "62">6 Lemma and part-of-speech prediction may also profit from syntactic information, see e.g. Prins (2004) or Bohnet and Nivre (2012).the head and the leftmost daughter, dir is a binary fea ture marking the direction of the head with respect to the current token.</S>
			<S sid ="100" ssid = "63">After training the baseline models, we use them to annotate the whole data set with morphological information (using 10-fold jackknifing for the training portions).</S>
			<S sid ="101" ssid = "64">We then use 10-fold jackknifing again to annotate the data sets with the dependency parser.</S>
			<S sid ="102" ssid = "65">At this point, all our data sets are annotated with predicted morphology from our baseline system and with syntactic information from the parser, which uses the morphological information from our baseline system in its feature set.</S>
			<S sid ="103" ssid = "66">We can now retrain our morphological tagger using features that are derived from the dependency trees provided by the parser.</S>
			<S sid ="104" ssid = "67">Note that this is not a stacking architecture, since the second system does not use the predicted morphology output from the baseline system.</S>
			<S sid ="105" ssid = "68">The loop simply ensures that we get the best possible syntactic features.</S>
			<S sid ="106" ssid = "69">We extract two kinds of syntactic features: features of the syntactic head of the current token, and a ll dev set o ov a ll test set o ov d e v s e t a l l o o v t e s t s e t all oov Czec h Czech m orf ett e 90.37 6 8.</S>
			<S sid ="107" ssid = "70">6 6 90.01 6 7.</S>
			<S sid ="108" ssid = "71">2 5 fea tur am a 9 4.</S>
			<S sid ="109" ssid = "72">7 5 84 .1 2 9 4.</S>
			<S sid ="110" ssid = "73">7 8 84 .2 3 ou r ba sel in e 92.51 7 3.</S>
			<S sid ="111" ssid = "74">1 2 92.29 7 2.</S>
			<S sid ="112" ssid = "75">5 8 our bas elin e 9 3.</S>
			<S sid ="113" ssid = "76">8 0 80 .4 7 9 3.</S>
			<S sid ="114" ssid = "77">5 7 80 .5 3 pre d sy nt ax *93.18 7 4.</S>
			<S sid ="115" ssid = "78">0 4 *92.82 7 3.</S>
			<S sid ="116" ssid = "79">1 1 pre d sy nta x *9 4.4 0 81 .5 1 *9 4.2 4 81 .6 1 gol d sy nt ax *93.64 7 5.</S>
			<S sid ="117" ssid = "80">2 0 *93.30 7 4.</S>
			<S sid ="118" ssid = "81">9 6 gol d sy nta x *9 4.8 0 82 .4 5 *9 4.6 4 82 .8 0 German morfette 86.78 66.37 84.58 61.05 our baseline 90.92 72.52 89.11 69.67 pred syntax *92.07 75.06 *90.10 71.18 gold syntax *92.70 *76.29 *90.87 *73.20 Hungarian morfette *96.19 *85.82 95.99 *85.43 our baseline 96.08 84.49 95.94 83.76 pred syntax 96.18 84.70 96.11 83.85 gold syntax *96.46 85.30 *96.35 84.50 Spanish German RFTagger 90.63 72.11 89.04 70.80 our baseline 92.59 80.73 91.48 78.83 pred syntax *93.70 82.71 *92.51 80.20 gold syntax *94.28 *84.12 *93.32 *82.35 Hungarian our baseline 97.27 92.61 97.03 91.28 pred syntax 97.38 92.39 97.19 91.50 gold syntax *97.63 92.79 *97.45 91.92 Spanish m orf ett e 9 7.</S>
			<S sid ="119" ssid = "82">8 3 8 9.</S>
			<S sid ="120" ssid = "83">6 7 9 7.</S>
			<S sid ="121" ssid = "84">7 6 9 1.</S>
			<S sid ="122" ssid = "85">0 0 ou r ba sel in e 9 7.</S>
			<S sid ="123" ssid = "86">8 3 8 9.</S>
			<S sid ="124" ssid = "87">0 5 9 7.</S>
			<S sid ="125" ssid = "88">5 9 9 0.</S>
			<S sid ="126" ssid = "89">8 8 our ba sel ine 98 .2 3 92 .4 6 9 8.</S>
			<S sid ="127" ssid = "90">0 2 93 .1 5 pre d sy nt ax 9 7.</S>
			<S sid ="128" ssid = "91">8 4 8 9.</S>
			<S sid ="129" ssid = "92">0 8 9 7.</S>
			<S sid ="130" ssid = "93">6 7 9 0.</S>
			<S sid ="131" ssid = "94">9 1 pre d sy nta x 98 .2 4 92 .3 0 9 8.</S>
			<S sid ="132" ssid = "95">0 7 93 .0 3 gol d sy nt ax 9 8.</S>
			<S sid ="133" ssid = "96">1 1 9 0.</S>
			<S sid ="134" ssid = "97">3 4 9 7.</S>
			<S sid ="135" ssid = "98">8 8 9 1.</S>
			<S sid ="136" ssid = "99">6 1 gol d sy nta x 98 .4 0 92 .8 2 *9 8.2 2 93 .6 4 Table 3: The effect of syntactic features when predicting morphological information.</S>
			<S sid ="137" ssid = "100">* mark statistically significantly better models compared to our baseline (sentence- based t-test with α = 0.05).</S>
			<S sid ="138" ssid = "101">features of the leftmost daughter of the current token.</S>
			<S sid ="139" ssid = "102">We also experimented with other types, e. g. the rightmost daughter, but these features did not improve the model.</S>
			<S sid ="140" ssid = "103">This is likely due to the way these languages encode morphological information and may be different for other languages.</S>
			<S sid ="141" ssid = "104">From the head and the leftmost daughter, we construct features about form, lemma, affixes, and tags.</S>
			<S sid ="142" ssid = "105">Table 2 lists the syntactic features that we use in the model.</S>
			<S sid ="143" ssid = "106">With the syntactic features available due to the parsing step, we train new models with the full system.</S>
			<S sid ="144" ssid = "107">For each language, we run four experiments.</S>
			<S sid ="145" ssid = "108">The first two are baseline experiments, where we use the off-the-shelf morphological tagger morfette (Chrupała et al., 2008) and our own baseline system, both of which do not use any syntactic features.</S>
			<S sid ="146" ssid = "109">In the third experiment, we evaluate our full system using the syntactic features provided by the dependency parser.</S>
			<S sid ="147" ssid = "110">As an oracle experiment, we also report results on the full system when using the gold standard syntax from the treebank.</S>
			<S sid ="148" ssid = "111">Table 3 presents all results in terms of accuracy on all tokens (all) Table 4: The effect of syntactic features when predicting morphology using lexicons.</S>
			<S sid ="149" ssid = "112">* mark statistically significantly better models compared to our baseline (sentence- based t-test with α = 0.05).</S>
			<S sid ="150" ssid = "113">and out-of-vocabulary tokens only (oov).</S>
			<S sid ="151" ssid = "114">Out-of- vocabulary tokens do not occur in the training data.</S>
			<S sid ="152" ssid = "115">We find trends along several axes: Generally, the syntactic features work well for Czech and German, whereas for Hungarian and Spanish, they do not yield any significant improvement.</S>
			<S sid ="153" ssid = "116">The improvements for German and Czech are between 0.5 (Czech) and 1.0 (German) percentage points absolute in token accuracy, and between 0.2 (Czech test set) and 2.5 (German dev set) percentage points absolute in accuracy of unknown words.</S>
			<S sid ="154" ssid = "117">There are no obvious differences between the development and the test set in any of the languages.</S>
			<S sid ="155" ssid = "118">Compared to the morfette baseline, we find our systems to be either superior or equal to morfette in terms of token accuracy.</S>
			<S sid ="156" ssid = "119">Regarding accuracy on unknown words, morfette outperforms our systems for Hungarian, but is outperformed on Czech and German.</S>
			<S sid ="157" ssid = "120">For Spanish, all systems yield similar results.</S>
			<S sid ="158" ssid = "121">Looking at the oracle experiment, we see that for all languages, the system can learn something from syntax.</S>
			<S sid ="159" ssid = "122">For Czech and German, this is clearly the case, for Hungarian and Spanish, the differences are small but visible.</S>
			<S sid ="160" ssid = "123">There are pronounced differences between the predicted and the gold syntax experiments in Czech and German.</S>
			<S sid ="161" ssid = "124">Clearly, the parser makes mistakes that propagate through to the prediction of the morphology.</S>
			<S sid ="162" ssid = "125">2.4 Syntax vs Lexicon.</S>
			<S sid ="163" ssid = "126">The current state-of-the-art in predicting morphological features makes use of morphological lexicons (e.g. Hajicˇ (2000), HakkaniTu¨ r et al.</S>
			<S sid ="164" ssid = "127">(2002), Hajicˇ (2004)).</S>
			<S sid ="165" ssid = "128">Lexicons define the possible morphological descriptions of a word and a statistical model selects the most probable one among them.</S>
			<S sid ="166" ssid = "129">In the following experiment, we test whether the contribution of syntactic features is similar or different to the contribution of morphological lexicons.</S>
			<S sid ="167" ssid = "130">Lexicons encode important knowledge that is difficult to pick up in a purely statistical system, e. g. the gender of nouns, which often cannot be deduced from the word form (Corbett, 1991).7 We extend our system from the previous experiment to include information from a morphological dictionaries.</S>
			<S sid ="168" ssid = "131">For Czech, we use the morphological analyzer distributed with the Prague Dependency Treebank 2 (Hajicˇ et al., 2006).</S>
			<S sid ="169" ssid = "132">For German, we use DMor (Schiller, 1994).</S>
			<S sid ="170" ssid = "133">For Hungarian, we use (Tro´ n et al., 2006), and for Spanish, we use the morphological analyzer included in Freeling (Carreras et al., 2004).</S>
			<S sid ="171" ssid = "134">The output of the analyzers is given to the system as features that simply record the presence of a particular morphological analysis for the current word.</S>
			<S sid ="172" ssid = "135">The system can thus use the output of any tool regardless of its annotation scheme, especially if the annotation scheme of the treebank is different from the one of the morphological analyzer.</S>
			<S sid ="173" ssid = "136">Table 4 presents the results of experiments where we add the output of the morphological analyzers to our system.</S>
			<S sid ="174" ssid = "137">Again, we run experiments with and without syntactic features.</S>
			<S sid ="175" ssid = "138">For Czech, we also show results from featurama8 with the feature set developed by Votrubec (2006).</S>
			<S sid ="176" ssid = "139">For German, we show results for RFTagger (Schmid and Laws, 2008).</S>
			<S sid ="177" ssid = "140">As expected, the information from the morphological lexicon improves the overall performance 7 Lexicons are also often used to speed up processing considerably by restricting the search space of the statistical model.</S>
			<S sid ="178" ssid = "141">8 http://sourceforge.net/projects/featurama/ considerably compared to the results in Table 3, especially on unknown tokens.</S>
			<S sid ="179" ssid = "142">This shows that even with the considerable amounts of training data available nowadays, rule-based morphological analyzers are important resources for morphological description (cf.</S>
			<S sid ="180" ssid = "143">Hajicˇ (2000)).</S>
			<S sid ="181" ssid = "144">The contribution of syntactic features in German and Czech is almost the same as in the previous experiment, indicating that the syntactic features contribute information that is orthogonal to that of the morphological lexicon.</S>
			<S sid ="182" ssid = "145">The lexicon provides lexical knowledge about a word form, while the syntactic features provide the syntactic context that is needed in German and Czech to decide on the right morphological tag.</S>
			<S sid ="183" ssid = "146">2.5 Language Differences.</S>
			<S sid ="184" ssid = "147">From the previous experiments, we conclude that syntactic features help in the prediction of morphology for Czech and German, but not for Hungarian and Spanish.</S>
			<S sid ="185" ssid = "148">To further investigate the difference between Czech and German on the one hand, and Hungarian and Spanish on the other, we take a closer look at the output of the tagger.</S>
			<S sid ="186" ssid = "149">We find an interesting difference between the two pairs of languages, namely the performance with respect to agreement.</S>
			<S sid ="187" ssid = "150">Agreement is a phenomenon where morphology and syntax strongly interact.</S>
			<S sid ="188" ssid = "151">Morphological features co-vary between two items in the sentence, but the relation between these items can occur at various linguistic levels (Corbett, 2006).</S>
			<S sid ="189" ssid = "152">If the syntactic information helps with predicting morphological information, we expect this to be particularly helpful with getting agreement right.</S>
			<S sid ="190" ssid = "153">All languages show agreement to some extent.</S>
			<S sid ="191" ssid = "154">Specifically, all languages show agreement in number (and person) between the subject and the verb of a clause.</S>
			<S sid ="192" ssid = "155">Czech, German, and Spanish show agreement in number, gender, and case (not Spanish) within a noun phrase.</S>
			<S sid ="193" ssid = "156">Hungarian shows case agreement within the noun phrase only rarely, e.g. for attributively used demonstrative pronouns.</S>
			<S sid ="194" ssid = "157">In order to test the effect on agreement, we measure the accuracy on tokens that are in an agreement relation with their syntactic head.</S>
			<S sid ="195" ssid = "158">We counted subject verb agreement as well as agreement with respect to number, gender, and case (where applicable) between a noun and its dependent adjective and determiner.</S>
			<S sid ="196" ssid = "159">Table 5 displays the counts from the devel opment sets of each language.</S>
			<S sid ="197" ssid = "160">We compare the baseline system that does not use any syntactic information with the output of the morphological tagger that uses the gold syntax.</S>
			<S sid ="198" ssid = "161">We use the gold syntax rather than the predicted one in order to eliminate any influence from parsing errors.</S>
			<S sid ="199" ssid = "162">As can be seen from the results, the level of agreement relations in Czech and German improves when using syntactic information, whereas in Spanish and Hungarian, only very tiny changes occur.</S>
			<S sid ="200" ssid = "163">agreement baseline gold syntax Czech sbj-verb 3199/4044 = 79.10 3264/4044 = 80.71 NP case 8719/9132 = 95.48 8821/9132 = 96.59 NP num 8933/9132 = 97.82 9016/9132 = 98.73 NP gen 8493/9132 = 93.00 8768/9132 = 96.01 German sbj-verb 4412/4696 = 93.95 4562/4696 = 97.15 NP case 13340/13951 = 95.62 13510/13951 = 96.84 NP num 13631/13951 = 97.71 13788/13951 = 98.83 NP gen 13253/13951 = 95.00 13528/13951 = 96.97 Hungarian sbj-verb 8653/10219 = 84.68 8655/10219 = 84.70 NP case 402/891 = 45.12 412/891 = 46.24 Spanish sbj-verb 1930/2004 = 96.31 1932/2004 = 96.41 NP num 8810/8849 = 99.56 8816/8849 = 99.63 NP gen 8810/8849 = 99.56 8821/8849 = 99.68 Table 5: Agreement counts in morphological annotation compared between the baseline system and the oracle system using gold syntax.</S>
			<S sid ="201" ssid = "164">For Czech and German, these results sugguest that syntactic information helps with agreement.</S>
			<S sid ="202" ssid = "165">We believe that the reasons why it does not help for Hungarian and Spanish are the following: for Spanish, we see that also the baseline model achieves very high accuracies (cf.</S>
			<S sid ="203" ssid = "166">Table 3) and also high rates of correct agreement.</S>
			<S sid ="204" ssid = "167">It seems that for Spanish, syntactic context is simply not necessary to make the correct prediction.</S>
			<S sid ="205" ssid = "168">For Hungarian, the reason lies within the inflectional paradigms of the language, which do not show any form syncretism, meaning that word forms in Hungarian are usually not ambiguous within one morphological category (e.g. case).</S>
			<S sid ="206" ssid = "169">Making a morphological tag prediction, however, is difficult only if the word form itself is ambiguous between several morphological tags.</S>
			<S sid ="207" ssid = "170">In this case, using the agreement relation between the word and its syntactic head can help the system making the proper prediction.</S>
			<S sid ="208" ssid = "171">This is the situation that we find in Czech and German, where form syncretism is pervasive in the inflectional paradigms.</S>
			<S sid ="209" ssid = "172">2.6 Syntactic Features in Czech.</S>
			<S sid ="210" ssid = "173">In Section 2.4 we compared the performance of our system on Czech to another system, featurama (see Table 4).</S>
			<S sid ="211" ssid = "174">Featurama outperforms our baseline system by a percentage point in token accuracy (and even more for unknown tokens).</S>
			<S sid ="212" ssid = "175">Syntactic information closes that gap to a large extent but only using gold syntax gets our system on a par with featurama.</S>
			<S sid ="213" ssid = "176">The question then arises whether the syntactic features actually contribute something new to the task, or whether the same effect could also be achieved with linear context features alone as in featurama.</S>
			<S sid ="214" ssid = "177">In order to test this we run an additional experiment, where we add some of the syntax features to the feature set of featurama.</S>
			<S sid ="215" ssid = "178">Specifically, we add the static features from Table 2 that do not use lemma or part-of-speech information.</S>
			<S sid ="216" ssid = "179">Due to the way featurama works, we cannot use features from the morphological tags (the dynamic features).</S>
			<S sid ="217" ssid = "180">The results in Table 6 show that also featurama profits from syntactic features, which corroborates the findings from the previous experiments.</S>
			<S sid ="218" ssid = "181">We also note again that better syntax would improve results even more.</S>
			<S sid ="219" ssid = "182">dev set test set a l l o o v a l l o o v fe at ur a m a 9 4.</S>
			<S sid ="220" ssid = "183">7 5 84 .1 2 9 4.</S>
			<S sid ="221" ssid = "184">7 8 84 .2 3 pre d sy nt ax 9 5.</S>
			<S sid ="222" ssid = "185">1 8 84 .6 5 9 5.</S>
			<S sid ="223" ssid = "186">0 9 84 .5 2 gol d sy nt ax *9 5.</S>
			<S sid ="224" ssid = "187">39 84 .6 2 *9 5.</S>
			<S sid ="225" ssid = "188">34 85 .0 3 Table 6: Syntactic features for featurama (Czech).</S>
			<S sid ="226" ssid = "189">* mark statistically significantly better models compared to feat- urama (sentence-based t-test with α = 0.05).</S>
	</SECTION>
	<SECTION title="How Much Syntax is Needed?. " number = "3">
			<S sid ="227" ssid = "1">Syntactic features require syntactically annotated corpora.</S>
			<S sid ="228" ssid = "2">Without a treebank to train the parser, the morphology cannot profit from syntactic features.9 This may be problematic for languages for which there is no treebank, because creating a treebank is expensive.</S>
			<S sid ="229" ssid = "3">Fortunately, it turns out that very small amounts of syntactically annotated data are enough 9 Which is of course only a problem for statistical parsers..</S>
			<S sid ="230" ssid = "4">German Czech 94 94 93 93 92 92 91 dev 91 test dev test 90 90 89 89 88 0 5000 10000 15000 20000 25000 30000 35000 40000 # of sentences in training data of syntactic parser 88 0 5000 10000 15000 20000 25000 30000 35000 40000 # of sentences in training data of syntactic parser Figure 2: Dependency between amount of training data for syntactic parser and quality of morphological prediction.</S>
			<S sid ="231" ssid = "5">to provide a parsing quality that is sufficient for the morphological tagger.</S>
			<S sid ="232" ssid = "6">In order to test what amount of training data is needed, we train several parsing models on increasing amounts of syntactically annotated data.</S>
			<S sid ="233" ssid = "7">For example, the first experiment uses the first 1,000 sentences of the treebank.</S>
			<S sid ="234" ssid = "8">We perform 5-fold jackknifing with the parser on these sentences to annotate them with syntax.</S>
			<S sid ="235" ssid = "9">Then we train one parsing model on these 1,000 sentences and use it to annotate the token in the sentence another token as the head.</S>
			<S sid ="236" ssid = "10">It does not have any tree requirements, so it is not even guaranteed to yield a cycle-free tree structure.</S>
			<S sid ="237" ssid = "11">In Table 7, we compare the simple parser with the mate- parser, both trained on the first 5,000 sentences of the treebank.</S>
			<S sid ="238" ssid = "12">Evaluation is done in terms of labeled (LAS) and unlabeled attachment score (UAS).10 dev set test set LAS UAS LAS UAS Czech rest of the trai nin g dat a as wel l as the de vel op me nt and the test set.</S>
			<S sid ="239" ssid = "13">Thi s give s us the full dat a set an sim ple par ser (5k ) 71.</S>
			<S sid ="240" ssid = "14">57 78.96 69.</S>
			<S sid ="241" ssid = "15">09 77.</S>
			<S sid ="242" ssid = "16">23 full par ser (5k ) 76.</S>
			<S sid ="243" ssid = "17">77 84.38 74.</S>
			<S sid ="244" ssid = "18">70 83.</S>
			<S sid ="245" ssid = "19">00 not ate d wit h syn tax that was lear ned fro m the firs t 1,0 00 sen ten ces of the tree ban k. The mo rph ologi sim ple par ser (5k ) G er m a n 83.</S>
			<S sid ="246" ssid = "20">06 85.23 78.</S>
			<S sid ="247" ssid = "21">56 81.</S>
			<S sid ="248" ssid = "22">18 cal tag ger is the n trai ned on the full trai nin g set an d full par ser (5k ) 87.</S>
			<S sid ="249" ssid = "23">56 90.08 83.</S>
			<S sid ="250" ssid = "24">69 86.</S>
			<S sid ="251" ssid = "25">58 applied to development and test set.</S>
			<S sid ="252" ssid = "26">Figure 2 shows the dependency between the amount of training data given to the parser and the quality of the morphological tagger using syntactic features provided by this parser.</S>
			<S sid ="253" ssid = "27">The leftmost point corresponds to a model that does not use syntactic information.</S>
			<S sid ="254" ssid = "28">For both languages, German and Czech, we find that already 1,000 sentences are enough training data for the parser to provide useful syntactic information to the morphological tagger.</S>
			<S sid ="255" ssid = "29">After 5,000 sentences, both curves flatten out and stay on the same level.</S>
			<S sid ="256" ssid = "30">We conclude that using syntactic features for morphological prediction is viable even if there is only small amounts of syntactic data available to train the parser.</S>
			<S sid ="257" ssid = "31">As a related experiment, we also test if we can get the same effect with a very simple and thus much Table 7: Simple parser vs full parser – syntactic quality.</S>
			<S sid ="258" ssid = "32">Trained on first 5,000 sentences of the training set.</S>
			<S sid ="259" ssid = "33">As expected, the simple parser performs much worse in terms of syntactic quality.</S>
			<S sid ="260" ssid = "34">Table 8 shows the performance of the morphological tagger when using the output of both parsers as syntactic features.</S>
			<S sid ="261" ssid = "35">For Czech, both parsers seem to supply similar information to the morphological tagger, while for German, using the full parser is clearly better.</S>
			<S sid ="262" ssid = "36">In both cases, the morphological tagger outperforms the models that do not use syntactic information (cf.</S>
			<S sid ="263" ssid = "37">Table 3).</S>
			<S sid ="264" ssid = "38">The performance on unknown words is however much worse for both languages.</S>
			<S sid ="265" ssid = "39">We conclude that even with a simple parser and little training data, the morphology can make use of syntactic information to some extent.</S>
			<S sid ="266" ssid = "40">faster parser.</S>
			<S sid ="267" ssid = "41">We use the brute-force algorithm described in Covington (2001), which selects for each 10 LAS: correct edges with correct labels , UAS: correct edges.</S>
			<S sid ="268" ssid = "42">all edges all edges dev set test set all oov all oov Czech no sy nta x 92.</S>
			<S sid ="269" ssid = "43">51 73.</S>
			<S sid ="270" ssid = "44">12 92.</S>
			<S sid ="271" ssid = "45">29 72.</S>
			<S sid ="272" ssid = "46">58 sim ple sy nta x 92.</S>
			<S sid ="273" ssid = "47">96 73.</S>
			<S sid ="274" ssid = "48">45 92.</S>
			<S sid ="275" ssid = "49">53 72.</S>
			<S sid ="276" ssid = "50">66 full sy nta x 93.</S>
			<S sid ="277" ssid = "51">08 73.</S>
			<S sid ="278" ssid = "52">64 92.</S>
			<S sid ="279" ssid = "53">69 73.</S>
			<S sid ="280" ssid = "54">39 G e r m a n no sy nta x 90.</S>
			<S sid ="281" ssid = "55">92 72.</S>
			<S sid ="282" ssid = "56">52 89.</S>
			<S sid ="283" ssid = "57">11 69.</S>
			<S sid ="284" ssid = "58">67 sim ple sy nta x 91.</S>
			<S sid ="285" ssid = "59">52 73.</S>
			<S sid ="286" ssid = "60">34 89.</S>
			<S sid ="287" ssid = "61">66 70.</S>
			<S sid ="288" ssid = "62">52 full sy nta x 91.</S>
			<S sid ="289" ssid = "63">92 83.</S>
			<S sid ="290" ssid = "64">46 89.</S>
			<S sid ="291" ssid = "65">91 80.</S>
			<S sid ="292" ssid = "66">50 Table 8: Simple parser vs full parser – morphological quality.</S>
			<S sid ="293" ssid = "67">The parsing models were trained on the first 5,000 sentences of the training data, the morphological tagger was trained on the full training set.</S>
	</SECTION>
	<SECTION title="Does Better Morphology  lead to Better. " number = "4">
			<S sid ="294" ssid = "1">Parses?</S>
			<S sid ="295" ssid = "2">In the previous sections, we show that syntactic information improves a model for predicting morphology for Czech and German, where syntax and morphology interact considerably.</S>
			<S sid ="296" ssid = "3">A natural question then is whether the improvement also occurs in the other direction, namely whether the improved morphology also leads to better parsing models.</S>
			<S sid ="297" ssid = "4">In the previous experiments, we run a 10-fold jackknifing process to annotate the training data with morphological information using no syntactic features and afterwards use jackknifing with the parser to annotate syntax.</S>
			<S sid ="298" ssid = "5">The syntax is subsequently used as features for our predicted-syntax experiments.</S>
			<S sid ="299" ssid = "6">We can apply the same process once more with the morphology prediction in order to annotate the training data with morphological information that is predicted using the syntactic features.</S>
			<S sid ="300" ssid = "7">A parser trained on this data will then use the improved morphology as features.</S>
			<S sid ="301" ssid = "8">If the improved morphology has an impact on the parser, the quality of the second parsing model should then be superior to the first parsing model, which uses the morphology predicted without syntactic information.</S>
			<S sid ="302" ssid = "9">Note that for the following experiments, neither morphology model uses the morphological lexicon.</S>
			<S sid ="303" ssid = "10">Table 9 presents the evaluation of the two parsing models (one using morphology without syntactic features, the other one using the improved morphology).</S>
			<S sid ="304" ssid = "11">The results show no improvement in parsing performance when using the improved morphology.</S>
			<S sid ="305" ssid = "12">Looking closer at the output, we find differences be dev set test set LAS UAS LAS UAS Czech baseline morph 81.73 88.45 81.02 87.77 morph w/ syntax 81.63 88.37 80.83 87.61 German baseline morph 91.16 92.97 88.06 90.24 morph w/ syntax 91.20 92.97 88.15 90.34 Table 9: Impact of the improved morphology on the quality of the dependency parser for Czech and German.</S>
			<S sid ="306" ssid = "13">tween the two parsing models with respect to grammatical functions that are morphologically marked.</S>
			<S sid ="307" ssid = "14">For example, in German, performance on subjects and accusative objects improves while performance for dative objects and genitives decreases.</S>
			<S sid ="308" ssid = "15">This suggests different strengths in the two parsing models.</S>
			<S sid ="309" ssid = "16">However, the question how to make use of the improved morphology in parsing clearly needs more research in the future.</S>
			<S sid ="310" ssid = "17">A promising avenue may be the approach by Hohensee and Bender (2012).</S>
	</SECTION>
	<SECTION title="Related Work. " number = "5">
			<S sid ="311" ssid = "1">Morphological taggers have been developed for many languages.</S>
			<S sid ="312" ssid = "2">The most common approach is the combination of a morphological lexicon with a statistical disambiguation model (HakkaniTu¨ r et al., 2002; Hajicˇ, 2004; Smith et al., 2005; Spoustova´ et al., 2009; Zsibrita et al., 2013).</S>
			<S sid ="313" ssid = "3">Our work has been inspired by Versley et al.</S>
			<S sid ="314" ssid = "4">(2010), who annotate a treebank with morphological information after the syntax had been annotated already.</S>
			<S sid ="315" ssid = "5">The system used a finite-state morphology to propose a set of candidate tags for each word, which is then further restricted using handcrafted rules over the already available syntax tree.</S>
			<S sid ="316" ssid = "6">Lee et al.</S>
			<S sid ="317" ssid = "7">(2011) pursue the idea of jointly predicting syntax and morphology, out of the motivation that joint models should model the problem more faithfully.</S>
			<S sid ="318" ssid = "8">They demonstrate that both sides can use information from each other.</S>
			<S sid ="319" ssid = "9">However, their model is computationally quite demanding and its overall performance falls far behind the standard pipeline approach where both tasks are done in sequence.</S>
			<S sid ="320" ssid = "10">The problem of modeling the interaction between morphology and syntax has recently attracted some attention in the SPMRL workshops (Tsarfaty et al., 2010).</S>
			<S sid ="321" ssid = "11">Modeling morphosyntactic relations explicitly has been shown to improve statistical parsing models (Tsarfaty and Sima’an, 2010; Goldberg and Elhadad, 2010; Seeker and Kuhn, 2013), but the codependency between morphology and syntax makes it a difficult problem, and linguistic intuition is often contradicted by the empirical findings.</S>
			<S sid ="322" ssid = "12">For example, Marton et al.</S>
			<S sid ="323" ssid = "13">(2013) show that case information is the most helpful morphological feature for parsing Arabic, but only if it is given as gold information, whereas using case information from an automatic system may even harm the performance.</S>
			<S sid ="324" ssid = "14">Morphologically rich languages pose different challenges for automatic systems.</S>
			<S sid ="325" ssid = "15">In this paper, we work with European languages, where the problem of predicting morphology can be reduced to a tagging problem.</S>
			<S sid ="326" ssid = "16">In languages like Arabic, Hebrew, or Turkish, widespread ambiguity in segmentation of single words into meaningful morphemes adds an additional complexity.</S>
			<S sid ="327" ssid = "17">Given a good segmentation tool that takes care of this, our approach is applicable to these languages as well.</S>
			<S sid ="328" ssid = "18">For Hebrew, this problem has also been addressed by jointly modeling segmentation, morphological prediction, and syntax (Cohen and Smith, 2007; Goldberg and Tsar- faty, 2008; Goldberg and Elhadad, 2013).</S>
	</SECTION>
	<SECTION title="Conclusion. " number = "6">
			<S sid ="329" ssid = "1">In this paper, we have demonstrated that using syntactic information for predicting morphological information is helpful if the language shows form syncretism in combination with morphosyntactic phenomena like agreement.</S>
			<S sid ="330" ssid = "2">A model that uses syntactic information is superior to a sequence model because it leverages the syntactic dependencies that may hold between morphologically dependent words as suggested by linguistic theory.</S>
			<S sid ="331" ssid = "3">We also showed that only small amounts of training data for a statistical parser would be needed to improve the morphological tagger.</S>
			<S sid ="332" ssid = "4">Making use of the improved morphology in the dependency parser is not straightforward and requires more investigation in the future.</S>
			<S sid ="333" ssid = "5">Modeling the interaction between morphology and syntax is important for building successful parsing pipelines for languages with free word order and rich morphology.</S>
			<S sid ="334" ssid = "6">Moreover, our experiments show that paying attention to the individual properties of a language can help us explain and predict the behavior of automatic tools.</S>
			<S sid ="335" ssid = "7">Thus, the term ”morphologically rich language” should be viewed as a broad term that covers many different languages, whose differences among each other may be as important as the difference with languages with a less rich morphology.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="336" ssid = "8">We would like to thank Jan Hajicˇ and Jan Sˇ teˇpa´nek for their kind help with the Czech morphology and featurama.</S>
			<S sid ="337" ssid = "9">We would also like to thank Thomas Mu¨ ller for sharing resources and thoughts with us, and Anders Bjo¨ rkelund for commenting on earlier versions of this paper.</S>
			<S sid ="338" ssid = "10">This work was funded by the Deutsche Forschungsgemeinschaft (DFG) via SFB 732 ”Incremental Specification in Context”, project D8.</S>
	</SECTION>
</PAPER>
