<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">We present novel kernels based on structured and unstructured features for reranking the N-best hypotheses of conditional random fields (CRFs) applied to entity extraction.</S>
		<S sid ="2" ssid = "2">The former features are generated by a polynomial kernel encoding entity features whereas tree kernels are used to model dependencies amongst tagged candidate examples.</S>
		<S sid ="3" ssid = "3">The experiments on two standard corpora in two languages, i.e. the Italian EVALITA 2009 and the English CoNLL 2003 datasets, show a large improvement on CRFs in F-measure, i.e. from 80.34% to 84.33% and from 84.86% to 88.16%, respectively.</S>
		<S sid ="4" ssid = "4">Our analysis reveals that both kernels provide a comparable improvement over the CRFs baseline.</S>
		<S sid ="5" ssid = "5">Additionally, their combination improves CRFs much more than the sum of the individual contributions, suggesting an interesting kernel synergy.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="6" ssid = "6">Reranking is a promising computational framework, which has drawn special attention in the Natural Language Processing (NLP) community.</S>
			<S sid ="7" ssid = "7">Basically, this method first employs a probabilistic model to generate a list of top-n candidates and then reranks this n-best list with additional features.</S>
			<S sid ="8" ssid = "8">One appeal of this approach is its flexibility of incorporating arbitrary features into a model.</S>
			<S sid ="9" ssid = "9">These features help in discriminating good from bad hypotheses and consequently their automatic learning.</S>
			<S sid ="10" ssid = "10">Various algorithms have been applied for reranking in NLP applications (Huang, 2008; Shen et al., 2004; Collins, 2002b; Collins and Koo, 2000), including parsing, name tagging and machine translation.</S>
			<S sid ="11" ssid = "11">This work has exploited the disciminative property as one of the key criterion of the reranking algorithm.</S>
			<S sid ="12" ssid = "12">Reranking appears extremely interesting if coupled with kernel methods (Dinarelli et al., 2009; Moschitti, 2004; Collins and Duffy, 2001), as the latter allow for extracting from the ranking hypotheses a huge amount of features along with their dependencies.</S>
			<S sid ="13" ssid = "13">Indeed, while feature-based learning algorithms involve only the dot-product between feature vectors, kernel methods allow for a higher generalization by replacing the dot- product with a function between pairs of linguistic objects.</S>
			<S sid ="14" ssid = "14">Such functions are a kind of similarity measure satisfying certain properties.</S>
			<S sid ="15" ssid = "15">An example is the tree kernel (Collins and Duffy, 2001), where the objects are syntactic trees that encode grammatical derivations and the kernel function computes the number of common subtrees.</S>
			<S sid ="16" ssid = "16">Similarly, sequence kernels (Lodhi et al., 2002) count the number of common subsequences shared by two input strings.</S>
			<S sid ="17" ssid = "17">Named-entities (NEs) are essential for defining the semantics of a document.</S>
			<S sid ="18" ssid = "18">NEs are objects that can be referred by names (Chinchor and Robinson, 1998), such as people, organizations, and locations.</S>
			<S sid ="19" ssid = "19">The research on NER has been promoted by the Message Understanding Conferences (MUCs, 19871998), the shared task of the Conference on Natural Language Learning (CoNLL, 20022003), and the Automatic Content Extraction program (ACE, 20022005).</S>
			<S sid ="20" ssid = "20">In the literature, there exist various learning approaches to extract named-entities from text.</S>
			<S sid ="21" ssid = "21">A NER sys 901 Coling 2010: Poster Volume, pages 901–909, Beijing, August 2010 tem often builds some generative/discriminative model, then, either uses only one classifier (Car- reras et al., 2002) or combines many classifiers using some heuristics (Florian et al., 2003).</S>
			<S sid ="22" ssid = "22">To the best of our knowledge, reranking has not been applied to NER except for the reranking algorithms defined in (Collins, 2002b; Collins, 2002a), which only targeted the entity detection (and not entity classification) task.</S>
			<S sid ="23" ssid = "23">Besides, since kernel methods offer a natural way to exploit linguistic properties, applying kernels for NE reranking is worthwhile.</S>
			<S sid ="24" ssid = "24">In this paper, we describe how kernel methods can be applied for reranking, i.e. detection and classification of named-entities, in standard corpora for Italian and English.</S>
			<S sid ="25" ssid = "25">The key aspect of our reranking approach is how structured and flat features can be employed in discriminating candidate tagged sequences.</S>
			<S sid ="26" ssid = "26">For this purpose, we apply tree kernels to a tree structure encoding NE tags of a sentence and combined them with a polynomial kernel, which efficiently exploits global features.</S>
			<S sid ="27" ssid = "27">Our main contribution is to show that (a) tree kernels can be used to define general features (not merely syntactic) and (b) using appropriate algorithms and features, reranking can be very effective for named-entity recognition.</S>
			<S sid ="28" ssid = "28">Our study demonstrates that the composite kernel is very effective for reranking named-entity sequences.</S>
			<S sid ="29" ssid = "29">Without the need of producing and heuristically combining learning models like previous work on NER, the composite kernel not only captures most of the flat features but also efficiently exploits structured features.</S>
			<S sid ="30" ssid = "30">More interestingly, this kernel yields significant improvement when applied to two corpora of two different languages.</S>
			<S sid ="31" ssid = "31">The evaluation in the Italian corpus shows that our method outperforms the best reported methods whereas on the English data it reaches the state-of-the-art.</S>
	</SECTION>
	<SECTION title="Background. " number = "2">
			<S sid ="32" ssid = "1">2.1 The data.</S>
			<S sid ="33" ssid = "2">Different languages exhibit different linguistic phenomena and challenges.</S>
			<S sid ="34" ssid = "3">A robust NER system is expected to be well-adapted to multiple domains and languages.</S>
			<S sid ="35" ssid = "4">Therefore, we experimented with two datasets: the EVALITA 2009 Italian corpus and the well-known CoNLL 2003 English shared task corpus.</S>
			<S sid ="36" ssid = "5">The EVALITA 2009 Italian dataset is based on I-CAB, the Italian Content Annotation Bank (Magnini et al., 2006), annotated with four entity types: Person (PER), Organization (ORG), GeoPolitical Entity (GPE) and Location (LOC).</S>
			<S sid ="37" ssid = "6">The training data, taken from the local newspaper “L’Adige”, consists of 525 news stories which belong to five categories: News Stories, Cultural News, Economic News, Sports News and Local News.</S>
			<S sid ="38" ssid = "7">Test data, on the other hand, consist of completely new data, taken from the same newspaper and consists of 180 news stories.</S>
			<S sid ="39" ssid = "8">The CoNLL 2003 English dataset is created within the shared task of CoNLL2003 (Sang and Meulder, 2003).</S>
			<S sid ="40" ssid = "9">It is a collection of news wire articles from the Reuters Corpus, annotated with four entity types: Person (PER), Location (LOC), Organization (ORG) and Miscellaneous name (MISC).</S>
			<S sid ="41" ssid = "10">The training and the development datasets are news feeds from August 1996, while the test set contains news feeds from December 1996.</S>
			<S sid ="42" ssid = "11">Accordingly, the named entities in the test dataset are considerably different from those that appear in the training or the development set.</S>
			<S sid ="43" ssid = "12">Italian GPE LOC ORG PER Train 2813 24.65% 362 3.17% 3658 32.06% 4577 40.11% Test 1143 23.02% 156 3.14% 1289 25.96% 2378 47.89% English LOC MISC ORG PER Train 7140 30.38% 3438 14.63% 6321 26.90% 6600 28.09% Dev 1837 30.92% 922 15.52% 1341 22.57% 1842 31.00% Test 1668 29.53% 702 12.43% 1661 29.41% 1617 28.63% Table 1: Statistics on the Italian EVALITA 2009 and English CoNLL 2003 corpora.</S>
			<S sid ="44" ssid = "13">2.2 The baseline algorithm.</S>
			<S sid ="45" ssid = "14">We selected Conditional Random Fields (Lafferty et al., 2001) as the baseline model.</S>
			<S sid ="46" ssid = "15">Conditional random fields (CRFs) are a probabilistic framework for labeling and segmenting sequence data.</S>
			<S sid ="47" ssid = "16">They present several advantages over other purely generative models such as Hidden Markov models (HMMs) by relaxing the independence assumptions required by HMMs.</S>
			<S sid ="48" ssid = "17">Besides, HMMs and other discriminative Markov models are prone to the label bias problem, which is effectively solved by CRFs.</S>
			<S sid ="49" ssid = "18">The named-entity recognition (NER) task is framed as assigning label sequences to a set of observation sequences.</S>
			<S sid ="50" ssid = "19">We follow the IOB notation where the NE tags have the format B-TYPE, I-TYPE or O, which mean that the word is a beginning, a continuation of an entity, or not part of an entity at all.</S>
			<S sid ="51" ssid = "20">For example, consider the sentence with their corresponding NE tags, each word is la The gazetteer lists are built with names imported from different sources.</S>
			<S sid ="52" ssid = "21">For English, the geographic features are imported from NIMA’s GEOnet Names Server (GNS)2, The Alexandria Digital Library (ADL) gazetteer3.</S>
			<S sid ="53" ssid = "22">The company data is included with all the publicly traded companies listed in Google directory4, the European business directory5.</S>
			<S sid ="54" ssid = "23">For Italian, the generic proper nouns are extracted from Wikipedia and various Italian sites.</S>
			<S sid ="55" ssid = "24">2.3 Support Vector Machines (SVMs).</S>
			<S sid ="56" ssid = "25">Support Vector Machines refer to a supervised machine learning technique based on the latest results of the statistical learning theory.</S>
			<S sid ="57" ssid = "26">Given a vector space and a set of training points, i.e. positive and negative examples, SVMs find a separatbeled with a tag indicating its appropriate named ing hyperplane H ( x) = ω × x + b = 0 where entity, resulting in annotated text, such as: Il/O presidente/O della/O Fifa/B-ORG Sepp/B-PER Blatter/I-PER affermando/O che/O il/O torneo/O era/O stato/O ottimo/O (FIFA president Sepp Blatter says that the tournament was excellent) For our experiments, we used CRF++ 1 to build our recognizer, which is a model trained discriminatively with the unigram and bigram features.</S>
			<S sid ="58" ssid = "27">These are extracted from a window at k words centered in the target word w (i.e. the one we want to classify with the B, O, I tags).</S>
			<S sid ="59" ssid = "28">More in detail such features are: • The word itself, its prefixes, suffixes, and part-of-speech • Orthographic/Word features.</S>
			<S sid ="60" ssid = "29">These are binary and mutually exclusive features that test whether a word contains all upper-cased, initial letter upper-cased, all lower-cased, roman-number, dots, hyphens, acronym, lonely initial, punctuation mark, single-char, and functional-word.</S>
			<S sid ="61" ssid = "30">• Gazetteer features.</S>
			<S sid ="62" ssid = "31">Class (geographical, ω ∈ Rn and b ∈ R are learned by applying the Structural Risk Minimization principle (Vapnik, 1998).</S>
			<S sid ="63" ssid = "32">SVMs are a binary classifier, but they can be easily extended to multi-class classifier, e.g. by means of the one-vs-all method (Rifkin and Poggio, 2002).</S>
			<S sid ="64" ssid = "33">One strong point of SVMs is the possibility to apply kernel methods to implicitly map data in a new space where the examples are more easily separable as described in the next section.</S>
			<S sid ="65" ssid = "34">2.4 Kernel methods.</S>
			<S sid ="66" ssid = "35">Kernel methods (Scho¨ lkopf and Smola, 2001) are an attractive alternative to feature-based methods since the applied learning algorithm only needs to compute a product between a pair of objects (by means of kernel functions), avoiding the explicit feature representation.</S>
			<S sid ="67" ssid = "36">A kernel function is a scalar product in a possibly unknown feature space.</S>
			<S sid ="68" ssid = "37">More precisely, The object o is mapped in x with a feature function φ : O → &apos;Rn, where O is the set of the objects.</S>
			<S sid ="69" ssid = "38">The kernel trick allows us to rewrite the decision hyperplane as:first name, surname, organization prefix, lo cation prefix) of words in the window.</S>
			<S sid ="70" ssid = "39">H ( x) = i=1..l yiαi xi · x + b = • Left Predictions.</S>
			<S sid ="71" ssid = "40">The predicted tags on the left of the word in the current classification.</S>
			<S sid ="72" ssid = "41">1 http://crfpp.sourceforge.net 2 http://www.nima.mil/gns/html 3 http://www.alexandria.ucsb.edu 4 http://directory.google.com/Top/Business 5 http://www.europages.net i=1..l yiαixi · x + b = i=1..l yiαiφ (oi) · φ(o) + b, where yi is equal to 1 for positive and -1 for negative examples, αi ∈ &apos;R with αi ≥ 0, oi ∀i ∈ {1, .., l} are the training instances and the product K (oi, o) = φ(oi) · φ(o)) is the kernel function associated with the mapping φ.</S>
			<S sid ="73" ssid = "42">Kernel engineering can be carried out by combining basic kernels with additive or multiplicative operators or by designing specific data objects (vectors, sequences and tree structures) for the target tasks.</S>
			<S sid ="74" ssid = "43">Regarding NLP applications, kernel methods have attracted much interest due to the ability of implicitly exploring huge amounts of structural features.</S>
			<S sid ="75" ssid = "44">The parse tree kernel (Collins and Duffy, 2001) and string kernel (Lodhi et al., 2002) are examples of the well-known convolution kernels used in various NLP tasks.</S>
			<S sid ="76" ssid = "45">2.5 Tree Kernels.</S>
			<S sid ="77" ssid = "46">Tree kernels represent trees in terms of their substructures (called tree fragments).</S>
			<S sid ="78" ssid = "47">Such fragments form a feature space which, in turn, is mapped into a vector space.</S>
			<S sid ="79" ssid = "48">Tree kernels measure the similarity between pair of trees by counting the number of fragments in common.</S>
			<S sid ="80" ssid = "49">There are three important characterizations of fragment type: the Sub- Trees (ST), the SubSet Trees (SST) and the Partial Trees (PT).</S>
			<S sid ="81" ssid = "50">For sake of space, we do not report the mathematical description of them, which is available in (Vishwanathan and Smola, 2002), (Collins and Duffy, 2001) and (Moschitti, 2006), respectively.</S>
			<S sid ="82" ssid = "51">In contrast, we report some descriptions in terms of feature space that may be useful to understand the new engineered kernels.</S>
			<S sid ="83" ssid = "52">In principle, a SubTree (ST) is defined by taking any node along with its descendants.</S>
			<S sid ="84" ssid = "53">A SubSet Tree (SST) is a more general structure which does not necessarily include all the descendants.</S>
			<S sid ="85" ssid = "54">The distinction is that an SST must be generated by applying the same grammatical rule set which generated the original tree, as pointed out in (Collins and Duffy, 2001).</S>
			<S sid ="86" ssid = "55">A Partial Tree (PT) is a more general form of substructures obtained by relaxing constraints over the SSTs.</S>
			<S sid ="87" ssid = "56">Figure 1 shows the overall fragment set of the ST, SST and PT kernels for the syntactic parse tree of the sentence frag Figure 1: Three kinds of tree kernels.</S>
			<S sid ="88" ssid = "57">ment: gives a talk . In the next section, we will define new structures for tagged sequences of NEs which along with the application of the PT kernel produce innovative tagging kernels for reranking.</S>
	</SECTION>
	<SECTION title="Reranking Method. " number = "3">
			<S sid ="89" ssid = "1">3.1 Reranking Strategy.</S>
			<S sid ="90" ssid = "2">As a baseline we trained the CRFs model to generate 10-best candidates per sentence, along with their probabilities.</S>
			<S sid ="91" ssid = "3">Each candidate was then represented by a semantic tree together with a feature vector.</S>
			<S sid ="92" ssid = "4">We consider our reranking task as a binary classification problem where examples are pairs of hypotheses &lt; Hi, Hj &gt;.</S>
			<S sid ="93" ssid = "5">Given a sentence “South African Breweries Ltd bought stakes in the Lech and Tychy brewers” and three of its candidate tagged sequences: H1 B-ORG I-ORG I-ORG I-ORG O O O O B-ORG O B-ORG O (the correct sequence) H2 B-MISC I-MISC B-ORG I-ORG O O O O B-ORG I-ORG I-ORG O H3 B-ORG I-ORG I-ORG I-ORG O O O O B-ORG O BLOC O where B-ORG, I-ORG, BLOC, O are the generated NE tags according to IOB notation as described in Section 3.2.</S>
			<S sid ="94" ssid = "6">With the above data (an original sentence together with a list of candidate tagged sequences), the following pairs of hypotheses will be gener ated &lt; H1, H2 &gt;, &lt; H1, H3 &gt;,&lt; H2, H1 &gt; and &lt; H3, H1 &gt;, where the first two pairs are positive and the latter pairs are negative instances.</S>
			<S sid ="95" ssid = "7">Then a binary classifier based on SVMs and kernel methods can be trained to discriminate between the best hypothesis, i.e. &lt; H1 &gt; and the others.</S>
			<S sid ="96" ssid = "8">At testing time the hypothesis receiving the highest score is selected (Collins and Duffy, 2001).</S>
			<S sid ="97" ssid = "9">3.2 Representation of Tagged Sequences in.</S>
			<S sid ="98" ssid = "10">Semantic Trees We now consider the representation that exploits the most discriminative aspects of candidate structures.</S>
			<S sid ="99" ssid = "11">As in the case of NER, an input candidate is a sequence of word/tag pairs x = {w1/t1...wn/tn} where wi is the i th word andti is the i th NE tag for that word.</S>
			<S sid ="100" ssid = "12">The first repre sentation we consider is the tree structure.</S>
			<S sid ="101" ssid = "13">See figure 2 as an example of candidate tagged sequence and its semantic tree.</S>
			<S sid ="102" ssid = "14">With the sentence “South African Breweries Ltd bought stakes in the Lech and Tychy brewers” and three of its candidate tagged sequences in the previous section, the training algorithm considers to construct a tree for each sequence, with the named- entity tags as pre-terminals and the words as leaves.</S>
			<S sid ="103" ssid = "15">See figure 2 for an example of the semantic tree for the first tagged sequence.</S>
			<S sid ="104" ssid = "16">With this tree representation, for a word wi, the target NE tag would be set at parent and the features for this word are at child nodes.</S>
			<S sid ="105" ssid = "17">This allows us to best exploit the inner product between competing candidates.</S>
			<S sid ="106" ssid = "18">Indeed, in the kernel space, the inner product counts the number of common subtrees thus sequences with similar NE tags are likely to have higher score.</S>
			<S sid ="107" ssid = "19">For example, the similarity between H1 and H3 will be higher than the similarity of the previous hypotheses with H2; this is reasonable since these two also have higher F1.It is worth noting that another useful modifica tion is the flexibility of incorporate diverse, arbitrary features into this tree structure by adding children to the parent node that contains entity tag.</S>
			<S sid ="108" ssid = "20">These characteristics can be exploited efficiently with the PT kernel, which relaxes constraints of production rules.</S>
			<S sid ="109" ssid = "21">The inner product can implicitly include these features and deal better with sparse data.</S>
			<S sid ="110" ssid = "22">3.3 Global features.</S>
			<S sid ="111" ssid = "23">Mixed n-grams features In previous works, some global features have been used (Collins, 2002b; Collins, 2002a) but the employed algorithm just exploited arbitrary information regarding word types and linguistic patterns.</S>
			<S sid ="112" ssid = "24">In contrast, we define and study diverse features by also considering n-grams patterns preceding, and following the target entity.</S>
			<S sid ="113" ssid = "25">Complementary context In supervised learning, NER systems often suffer from low recall, which is caused by lack of both resource and context.</S>
			<S sid ="114" ssid = "26">For example, a word like “Arkansas” may not appear in the training set and in the test set, there may not be enough context to infer its NE tag.</S>
			<S sid ="115" ssid = "27">In such cases, neither global features (Chieu and Ng, 2002) nor aggregated contexts (Chieu and Ng, 2003) can help.</S>
			<S sid ="116" ssid = "28">To overcome this deficiency, we employed the following unsupervised procedure: first, the baseline NER is applied to the target un-annotated corpus.</S>
			<S sid ="117" ssid = "29">Second, we associate each word of the corpus with the most frequent NE category assigned in the previous step.</S>
			<S sid ="118" ssid = "30">Finally, the above tags are used as features during the training of the improved NER and also for building the feature representation for a new classification instance.</S>
			<S sid ="119" ssid = "31">This way, for any unknown word w of the test set, we can rely on the most probable NE category as feature.</S>
			<S sid ="120" ssid = "32">The advantage is that we derived it by using the average over many possible contexts of w, which are in the different instances of the unnanotated corpus.</S>
			<S sid ="121" ssid = "33">The unlabeled corpus for Italian was collected from La Repubblica 6 and it contains over 20 millions words.</S>
			<S sid ="122" ssid = "34">Whereas the unlabeled corpus for English was collected mainly from The New York Times 7 and BBC news stories 8 with more than 35 millions words.</S>
			<S sid ="123" ssid = "35">Head word As the head word of an entity plays an important role in information extraction (Bunescu and Mooney, 2005a; Surdeanu et al., 2003), it is in 6 http://www.repubblica.it/ 7 http://www.nytimes.com/ 8 http://news.bbc.co.uk/ Figure 2: Semantic structure of the first sequence cluded in the global set together with its orthographic feature.</S>
			<S sid ="124" ssid = "36">We now describe some primitives for our global feature framework.</S>
			<S sid ="125" ssid = "37">1.</S>
			<S sid ="126" ssid = "38">wi for i = 1 . . .</S>
			<S sid ="127" ssid = "39">n is the i th word 2.</S>
			<S sid ="128" ssid = "40">ti is the NE tag of wi 3.</S>
			<S sid ="129" ssid = "41">gi is the gazetteer feature of the word wi 3.4 Reranking with Composite Kernel.</S>
			<S sid ="130" ssid = "42">In this section we describe our novel tagging kernels based on diverse global features as well as semantic trees for reranking candidate tagged sequences.</S>
			<S sid ="131" ssid = "43">As mentioned in the previous section, we can engineer kernels by combining tree and entity kernels.</S>
			<S sid ="132" ssid = "44">Thus we focus on the problem to define structure embedding the desired relational information among tagged sequences.</S>
			<S sid ="133" ssid = "45">The Partial Tree Kernel 4.</S>
			<S sid ="134" ssid = "46">fi is the most frequent NE tag seen in a large corpus of wi Let F = f1, f2, . . .</S>
			<S sid ="135" ssid = "47">, f |F | be a tree fragment 5.</S>
			<S sid ="136" ssid = "48">hi is the head word of the entity.</S>
			<S sid ="137" ssid = "49">We normally set the head word of an entity as its last space of type PTs and let the indicator function Ii(n) be equal to 1 if the target f1 is rooted at node n and 0 otherwise, we define the PT kernel as: word.</S>
			<S sid ="138" ssid = "50">However, when a preposition exists in the entity string, its head word is set as the last word before the preposition.</S>
			<S sid ="139" ssid = "51">For exam K (T1, T2) = n1 ∈NT1 n2 ∈NT2 ∆(n1, n2) ple, the head word of the entity “University of Pennsylvania” is “University”.</S>
			<S sid ="140" ssid = "52">6.</S>
			<S sid ="141" ssid = "53">Mixed n-grams features of the words and.</S>
			<S sid ="142" ssid = "54">their gazetteers/frequent-tag before/after the start/end of an entity.</S>
			<S sid ="143" ssid = "55">In addition to the normal n-grams solely based on words, we mixed words with gazetteers/frequent-tag seen from a large corpus and create mixed n-grams features.</S>
			<S sid ="144" ssid = "56">Table 2 shows the full set of global features in our reranking framework.</S>
			<S sid ="145" ssid = "57">Features are anchored to each entity instance and adapted to entity types.</S>
			<S sid ="146" ssid = "58">This helps to discriminate different entities with the same surface forms.</S>
			<S sid ="147" ssid = "59">Moreover, they can be combined with n-grams patterns to learn and explicitly push the score of the correct sequence above the score of competing sequences.</S>
			<S sid ="148" ssid = "60">where NT1 and NT2 are the set of nodes in T1 and T2 respectively and ∆(n1, n2) = i=1 Ii(n1)Ii(n2), i.e. the number of common fragments rooted at the n1 and n2 nodes of the type shown in Figure 1.c. The Polynomial Kernel The polynomial kernel between two candidate tagged sequences is defined as: K (x, y) = (1 + x1 · x2)2, where x1 and x2 are two feature vectors extracted from the two sequences with the global feature template.</S>
			<S sid ="149" ssid = "61">The Tagging Kernels In our reranking framework, we incorporate the probability from the original model with the tree structure as well as the feature vectors.</S>
			<S sid ="150" ssid = "62">Let us consider the following notations: Feature Description ws ws+1 . . .</S>
			<S sid ="151" ssid = "63">we Entity string gs gs+1 . . .</S>
			<S sid ="152" ssid = "64">ge The gazetteer feature within the entity fs fs+1 . . .</S>
			<S sid ="153" ssid = "65">fe The most frequent NE tag feature (seen from a large corpus) within the entity hw The head word of the entity lhw Indicates whether the head word is lower-cased ws−1 ws ; ws−1 gs ; gs−1 ws ; gs−1 gs Mixed bigrams of the words/gazetteer features before/after the start of the entity we we+1 ; we ge+1 ; ge we+1 ; ge ge+1 Mixed bigrams of the words/gazetteer features before/after the end of the entity ws−1 ws ; ws−1 fs ; fs−1 ws ; fs−1 fsMixed bigrams of the words/frequent-tag fea tures before/after the start of the entity we we+1 ; we fe+1 ; fe we+1 ; fe fe+1Mixed bigrams of the words/frequent-tag fea tures before/after the end of the entity ws−2 ws−1 ws ; ws−1 ws ws+1 ; we−1 we we+1 ; we−2 we−1 we Trigram features of the words before/after the start/end of the entity ws−2 ws−1 gs ; ws−2 gs−1 ws ; ws−2 gs−1 gs ; gs−2 ws−1 ws ; gs−2 ws−1 gs ; gs−2 gs−1 ws ; gs−2 gs−1 gs ; ws−1 ws gs+1 ; ws−1 gs ws+1 ; ws−1 gs gs+1 ; gs−1 ws ws+1 ; gs−1 ws gs+1 ; gs−1 gs ws+1 ; gs−1 gs gs+1 Mixed trigrams of the words/gazetteer features before/after the start of the entity we−1 we ge+1 ; we−1 ge we+1 ; we−1 ge ge+1 ; ge−1 we we+1 ; ge−1 we ge+1 ; ge−1 ge we+1 ; ge−1 ge ge+1 ; we−2 we−1 ge ; we−2 ge−1 we ; we−2 ge−1 ge ; ge−2 we−1 we ; ge−2 we−1 ge ; ge−2 ge−1 we ; ge−2 ge−1 ge Mixed trigrams of the words/gazetteer features before/after the end of the entity ws−2 ws−1 fs ; ws−2 fs−1 ws ; ws−2 fs−1 fs ; fs−2 ws−1 ws ; fs−2 ws−1 fs ; fs−2 fs−1 ws ; fs−2 fs−1 fs ; ws−1 ws fs+1 ; ws−1 fs ws+1 ; ws−1 fs fs+1 ; fs−1 ws ws+1 ; fs−1 ws fs+1 ; fs−1 fs ws+1 ; fs−1 fs fs+1Mixed trigrams of the words/frequent-tag fea tures before/after the start of the entity we−1 we fe+1 ; we−1 fe we+1 ; we−1 fe fe+1 ; fe−1 we we+1 ; fe−1 we fe+1 ; fe−1 fe we+1 ; fe−1 fe fe+1 ; we−2 we−1 fe ; we−2 fe−1 we ; we−2 fe−1 fe ; fe−2 we−1 we ; fe−2 we−1 fe ; fe−2 fe−1 we ; fe−2 fe−1 feMixed trigrams of the words/frequent-tag fea tures before/after the end of the entity Table 2: Global features in the entity kernel for reranking.</S>
			<S sid ="154" ssid = "66">These features are anchored for each entity instance and adapted to entity categories.</S>
			<S sid ="155" ssid = "67">For example, the entity string (first feature) of the entity “United Nations” with entity type “ORG” is “ORG United Nations”.</S>
			<S sid ="156" ssid = "68">• K (x, y) = L(x) · L(y) is the basic kernelwhere L(x) is the log probability of a can didate tagged sequence x under the original probability model.</S>
			<S sid ="157" ssid = "69">• T K (x, y) = t(x) · t(y) is the partial tree kernel under the structure representation • F K (x, y) = f (x) · f (y) is the polynomial kernel under the global features The tagging kernels between two tagged sequences are defined in the following combinations: 1.</S>
			<S sid ="158" ssid = "70">C T K = α · K + (1 − α) · T K 2.</S>
			<S sid ="159" ssid = "71">C F K = β · K + (1 − β) · F K 3.</S>
			<S sid ="160" ssid = "72">C T F K = γ · K + (1 − γ) · (T K + F K ) where α, β, γ are parameters weighting the two participating terms.</S>
			<S sid ="161" ssid = "73">Experiments on the validation set showed that these combinations yield the best performance with α = 0.2 for both languages, β = 0.4 for English and β = 0.3 for and Italian, γ = 0.24 for English and γ = 0.2 for Italian.</S>
	</SECTION>
	<SECTION title="Experimens and Results. " number = "4">
			<S sid ="162" ssid = "1">4.1 Experimental Setup.</S>
			<S sid ="163" ssid = "2">As a baseline we trained the CRFs classifier on the full training portion (11,227 sentences in the Italian and 14,987 sentences in the English corpus).</S>
			<S sid ="164" ssid = "3">In developing a reranking strategy for both English and Italian, the training data was split into 5 sections, and in each case the baseline classifier was trained on 4/5 of the data, then used to decode the remaining 1/5.</S>
			<S sid ="165" ssid = "4">The top 10 hypotheses together with their log probabilities were recovered for each training sentence.</S>
			<S sid ="166" ssid = "5">Similarly, a model trained on the whole training data was used to produce 10 hypotheses for each sentence in the development set.</S>
			<S sid ="167" ssid = "6">For the reranking experiments, we applied different kernel setups to the two corpora described in Section 2.1.</S>
			<S sid ="168" ssid = "7">The three kernels were trained on the training.</S>
			<S sid ="169" ssid = "8">portion.</S>
			<S sid ="170" ssid = "9">Italian Test P R F C RF s 83.43 77.48 80.34 C T K 84.97 78.03 81.35 C F K 84.93 79.13 81.93 CTFK 85.99 82.73 84.33 (Zanoli et al., 2009) 84.07 80.02 82.00 English Test P R F C RF s 85.37 84.35 84.86 C T K 87.19 84.79 85.97 C F K 86.53 86.75 86.64 CTFK 88.07 88.25 88.16 (Ratinov and Roth, ) N/A N/A 90.57 Table 3: Reranking results of the three tagging kernels on the Italian and English testset.</S>
			<S sid ="171" ssid = "10">4.2 Discussion.</S>
			<S sid ="172" ssid = "11">Table 3 presents the reranking results on the test data of both corpora.</S>
			<S sid ="173" ssid = "12">The results show a 20.29% relative improvement in F-measure for Italian and 21.79% for English.</S>
			<S sid ="174" ssid = "13">C F K based on unstructured features achieves higher accuracy than C T K based on structured features.</S>
			<S sid ="175" ssid = "14">However, the huge amount of subtrees generated by the PT kernel may limit the expressivity of some structural features, e.g. many fragments may only generate noise.</S>
			<S sid ="176" ssid = "15">This problem is less important with the polynomial kernel where global features are tailored for individual entities.</S>
			<S sid ="177" ssid = "16">In any case, the experiments demonstrate that both tagging kernels C T K and C F K give improvement over the CRFs baseline in both languages.</S>
			<S sid ="178" ssid = "17">This suggests that structured and unstructured features are effective in discriminating between competing NE annotations.</S>
			<S sid ="179" ssid = "18">Furthermore, the combination of the two tagging kernels on both standard corpora shows a large improvement in F-measure from 80.34% to 84.33% for Italian and from 84.86% to 88.16% for English data.</S>
			<S sid ="180" ssid = "19">This suggests that these two kernels, corresponding to two kinds of feature, complement each other.</S>
			<S sid ="181" ssid = "20">To better collocate our results with previous work, we report the best NER outcome on the Italian (Zanoli et al., 2009) and the English (Ratinov and Roth, ) datasets, in the last row (in italic) of each table.</S>
			<S sid ="182" ssid = "21">This shows that our model outperforms the best Italian NER system and it is close to the state-of-art model for English, which exploits many complex features9.</S>
			<S sid ="183" ssid = "22">Also note that we are very close to the F1 achieved by the best system of CoNLL 2003, i.e. 88.8.</S>
	</SECTION>
	<SECTION title="Conclusion. " number = "5">
			<S sid ="184" ssid = "1">We analyzed the impact of kernel-based approaches for modeling dependencies between tagged sequences for NER.</S>
			<S sid ="185" ssid = "2">Our study illustrates that each individual kernel, either with structured or with flat features clearly gives improvement to the base model.</S>
			<S sid ="186" ssid = "3">Most interestingly, as we showed, these contributions are independent and, the approaches can be used together to yield better results.</S>
			<S sid ="187" ssid = "4">The composite kernel, which combines both kinds of features, can outperform the state-of-the- art.</S>
			<S sid ="188" ssid = "5">In the future, it will be very interesting to use syntactic/semantic kernels, as for example in (Basili et al., 2005; Bloehdorn and Moschitti, 2007a; Bloehdorn and Moschitti, 2007b).</S>
			<S sid ="189" ssid = "6">Another promising direction is the use of syntactic trees, feature sequences and pairs of instances, e.g.</S>
			<S sid ="190" ssid = "7">(Nguyen et al., 2009; Moschitti, 2008).</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="191" ssid = "8">We would like to thank Roberto Zanoli and Marco Dinarelli for helpful explanation about their work.</S>
			<S sid ="192" ssid = "9">This work has been partially funded by the LiveMemories project (http://www.livememories.org/) and Expert System (http://www.expertsystem.net/) research grant.</S>
			<S sid ="193" ssid = "10">9 In the future we will be able to integrate them with the authors collaboration.</S>
	</SECTION>
</PAPER>
