<PAPER>
<S sid ="0" ssid = "0">Finite-State Non-Concatenative Morphotactics</S>
	<ABSTRACT>
		<S sid ="1" ssid = "1">Finite-state morphology in the general tradition of the Two-Level and Xerox implementations has proved very successful in the production of robust morphological analyzer-generators, including many large-scale commercial systems.</S>
		<S sid ="2" ssid = "2">However, it has long been recognized that these implementations have serious limitations in handling non-concatenative phenomena.</S>
		<S sid ="3" ssid = "3">We describe a new technique for constructing finite- state transducers that involves reapplying the regular-expression compiler to its own output.</S>
		<S sid ="4" ssid = "4">Implemented in an algorithm called compile- replace, this technique has proved useful for handling non-concatenative phenomena; and we demonstrate it on Malay full-stem reduplication and Arabic stem interdigitation.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="5" ssid = "5">Most natural languages construct words by concatenating morphemes together in strict orders.</S>
			<S sid ="6" ssid = "6">Such “concatenative morphotactics” can be impressively productive, especially in agglutinative languages like Aymara (Figure 11) or Turkish, and in agglutinative/polysynthetic languages like Inuktitut (Figure 2)(Mallon, 1999, 2).</S>
			<S sid ="7" ssid = "7">In such languages a single word may contain as many morphemes as an average-length English sentence.</S>
			<S sid ="8" ssid = "8">Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, includ ing the commercially important European languages and non-Indo-European examples like 1 I wish to thank Stuart Newton for this example.</S>
			<S sid ="9" ssid = "9">Finnish, Turkish and Hungarian.</S>
			<S sid ="10" ssid = "10">However, Koskenniemi himself understood that his initial implementation had significant limitations in handling non-concatenative morphotactic processes: “Only restricted infixation and reduplication can be handled adequately with the present system.</S>
			<S sid ="11" ssid = "11">Some extensions or revisions will be necessary for an adequate description of languages possessing extensive infixation or reduplication” (Koskenniemi, 1983, 27).</S>
			<S sid ="12" ssid = "12">This limitation has of course not escaped the notice of various reviewers, e.g. Sproat(1992).</S>
			<S sid ="13" ssid = "13">We shall argue that the morphotactic limitations of the traditional implementations are the direct result of relying solely on the concatenation operation in morphotactic description.</S>
			<S sid ="14" ssid = "14">We describe a technique, within the Xerox implementation of finite-state morphology, that corrects the limitations at the source, going beyond concatenation to allow the full range of finite-state operations to be used in morphotac- tic description.</S>
			<S sid ="15" ssid = "15">Regular-expression descriptions are compiled into finite-state automata or transducers (collectively called networks) as usual, and then the compiler is reapplied to its own output, producing a modified but still finite- state network.</S>
			<S sid ="16" ssid = "16">This technique, implemented in an algorithm called compile-replace, has already proved useful for handling Malay full- stem reduplication and Arabic stem interdigitation, which will be described below.</S>
			<S sid ="17" ssid = "17">Before illustrating these applications, we will first outline our general approach to finite-state morphology.</S>
	</SECTION>
	<SECTION title="Finite-State  Morphology. " number = "2">
			<S sid ="18" ssid = "1">Lexical: uta+ma+naka+p+xa+samacha-i+wa Surface: uta ma n ka p xa samach i wa uta = house (root) +ma = 2nd person possessive +na = in -ka = (locative, verbalizer) +p = plural +xa = perfect aspect +samacha = &quot;apparently&quot; -i = 3rd person +wa = topic marker Figure 1: Aymara: utamankapxasamachiwa = ”it appears that they are in your house” Lexical: Paris+mut+nngau+juma+niraq+lauq+sima+nngit+junga Surface: Pari mu nngau juma nira lauq sima nngit tunga Paris = (root = Paris) +mut = terminalis case ending +nngau = go (verbalizer) +juma = want +niraq = declare (that) +lauq = past +sima = (added to -lauq- indicates &quot;distant past&quot;) +nngit = negative +junga = 1st person sing.</S>
			<S sid ="19" ssid = "2">present indic (nonspecific) Figure 2: Inuktitut: Parimunngaujumaniralauqsimanngittunga = “I never said I wanted to go to Paris” 2.1 Analysis and Generation.</S>
			<S sid ="20" ssid = "3">In the most theory- and implementation-neutral form, morphological analysis and generation of written words can be modeled as a relation between the words themselves and analyses of those words.</S>
			<S sid ="21" ssid = "4">Computationally, as shown in Figure 3, a black-box module maps from words to analyses to effect Analysis, and from analyses to words to effect Generation.</S>
			<S sid ="22" ssid = "5">ANALYSES ANALYZER/ GENERATOR WORDS Figure 3: Morphological Analysis/Generation as a Relation between Analyses and Words The basic claim or hope of the finite-state approach to natural-language morphology is that relations like that represented in Figure 3 are in fact regular relations, i.e. relations between two regular languages.</S>
			<S sid ="23" ssid = "6">The surface language consists of strings (= words = sequences of symbols) written according to some defined orthography.</S>
			<S sid ="24" ssid = "7">In a commercial application for a natural language, the surface language to be modeled is usually a given, e.g. the set of valid French words as written according to standard French orthography.</S>
			<S sid ="25" ssid = "8">The lexical language again consists of strings, but strings designed according to the needs and taste of the linguist, representing analyses of the surface words.</S>
			<S sid ="26" ssid = "9">It is sometimes convenient to design these lexical strings to show all the constituent morphemes in their morphophonemic form, separated and identified as in Figures 1 and 2.</S>
			<S sid ="27" ssid = "10">In other applications, it may be useful to design the lexical strings to contain the traditional dictionary citation form, together with linguist-selected “tag” sym Analysis Strings Regular Expression Compiler F S T Word Strings Figure 4: Compilation of a Regular Expression into an fst that Maps between Two Regular Languages bols like +Noun, +Verb, +SG, +PL, that convey category, person, number, tense, mood, case, etc. Thus the lexical string representing paie, the first-person singular, present indicative form of the French verb payer (“to pay”), might be spelled payer+IndP+SG+P1+Verb.</S>
			<S sid ="28" ssid = "11">The tag symbols are stored and manipulated just like alphabetic symbols, but they have multicharacter print names.</S>
			<S sid ="29" ssid = "12">If the relation is finite-state, then it can be defined using the metalanguage of regular expressions; and, with a suitable compiler, the regular expression source code can be compiled into a finite-state transducer (fst), as shown in Figure 4, that implements the relation computationally.</S>
			<S sid ="30" ssid = "13">Following convention, we will often refer to the upper projection of the fst, representing analyses, as the lexical language, a set of lexical strings; and we will refer to the lower projection as the surface language, consisting of surface strings.</S>
			<S sid ="31" ssid = "14">There are compelling advantages to computing with such finite-state machines, including mathematical elegance, flexibility, and for most natural-language applications, high efficiency and data-compaction.</S>
			<S sid ="32" ssid = "15">One computes with fsts by applying them, in either direction, to an input string.</S>
			<S sid ="33" ssid = "16">When one such fst that was written for French is applied in an upward direction to the surface word maisons (“houses”), it returns the related string maison+Fem+PL+Noun, consisting of the citation form and tag symbols chosen by a linguist to convey that the surface form is a feminine noun in the plural form.</S>
			<S sid ="34" ssid = "17">A single surface string can be related to multiple lexical strings, e.g. applying this fst in an upward direction to surface string suis produces the four related lexical strings shown in Figure 5.</S>
			<S sid ="35" ssid = "18">Such ambiguity of surface strings is very common.</S>
			<S sid ="36" ssid = "19">^etre+IndP+SG+P1+Verb suivre+IndP+SG+P2+Verb suivre+IndP+SG+P1+Verb suivre+Imp+SG+P2+Verb Figure 5: Multiple Analyses for suis Conversely, the very same fst can be applied in a downward direction to a lexical string like ^etre+IndP+SG+P1+Verb to return the related surface string suis ; such transducers are inherently bidirectional.</S>
			<S sid ="37" ssid = "20">Ambiguity in the downward direction is also possible, as in the relation of the lexical string payer+IndP+SG+P1+Verb (“I pay”) to the surface strings paie and paye, which are in fact valid alternate spellings in standard French orthography.</S>
			<S sid ="38" ssid = "21">2.2 Morphotactics and Alternations.</S>
			<S sid ="39" ssid = "22">There are two challenges in modeling natural language morphology: • Morphotactics • Phonological/Orthographical Alternations Finite-state morphology models both using regular expressions.</S>
			<S sid ="40" ssid = "23">The source descriptions may also be written in higher-level notations (e.g. lexc (Karttunen, 1993), twolc (Karttunen and Beesley, 1992) and Replace Rules (Karttunen, 1995; Karttunen, 1996; Kempe and Karttunen, 1996)) that are simply helpful short- hands for regular expressions and that compile, using their dedicated compilers, into finite-state networks.</S>
			<S sid ="41" ssid = "24">In practice, the most commonly separated modules are a lexicon fst, containing lexical strings, and a separately written set of Lexicon Regular Expression Rule Regular Expression Compiler Lexicon FST .o. Rule FST Lexical Transducer (a single FST) Figure 6: Creation of a Lexical Transducer rule fsts that map from the strings in the lexicon to properly spelled surface strings.</S>
			<S sid ="42" ssid = "25">The lexicon description defines the morphotactics of the language, and the rules define the alternations.</S>
			<S sid ="43" ssid = "26">The separately compiled lexicon and rule fsts can subsequently be composed together as in Figure 6 to form a single “lexical transducer” (Karttunen et al., 1992) that could have been defined equivalently, but perhaps less perspicuously and less efficiently, with a single regular expression.</S>
			<S sid ="44" ssid = "27">In the lexical transducers built at Xerox, the strings on the lower side of the transducer are inflected surface forms of the language.</S>
			<S sid ="45" ssid = "28">The strings on upper side of the transducer contain the citation forms of each morpheme and any number of tag symbols that indicate the inflections and derivations of the corresponding surface form.</S>
			<S sid ="46" ssid = "29">For example, the information that the comparative of the adjective big is bigger might be represented in the English lexical transducer by the path (= sequence of states and arcs) in Figure 7 where the zeros represent epsilon symbols.2 The gemination of g and Lexical side: For the sake of clarity, Figure 7 represents the upper (= lexical) and the lower (= surface) side of the arc label separately on the opposite sides of the arc. In the remaining diagrams, we use a more compact notation: the upper and the lower symbol are combined into a single label of the form upper:lower if the symbols are distinct.</S>
			<S sid ="47" ssid = "30">A single symbol is used for an identity pair.</S>
			<S sid ="48" ssid = "31">In the standard notation, the path in Figure 7 is labeled as b i g 0:g +Adj:0 0:e +Comp:r. Lexical transducers are more efficient for analysis and generation than the classical two- level systems (Koskenniemi, 1983) because the morphotactics and the morphological alternations have been precompiled and need not be consulted at runtime.</S>
			<S sid ="49" ssid = "32">But it would be possible in principle, and perhaps advantageous for some purposes, to view the regular expressions defining the morphology of a language as an un- compiled “virtual network”.</S>
			<S sid ="50" ssid = "33">All the finite-state operations (concatenation, union, intersection, composition, etc.) can be simulated by an apply routine at runtime.</S>
			<S sid ="51" ssid = "34">Most languages build words by simply stringing morphemes (prefixes, roots and suffixes) b i g b i g 0 +Adj g 0 0 +Comp e r together in strict orders.</S>
			<S sid ="52" ssid = "35">The morphotactic (word building) processes of prefixation and suffixation can be straightforwardly Surface side: Figure 7: A Path in a Transducer for English the epenthetical e in the surface form bigger result from the composition of the original lexicon fst with the rule fst representing the regular morphological alternations in English.</S>
			<S sid ="53" ssid = "36">2 The epsilon symbols and their placement in the string are not significant.</S>
			<S sid ="54" ssid = "37">We will ignore them whenever it is convenient.</S>
			<S sid ="55" ssid = "38">modeled in finite state terms as concatenation.</S>
			<S sid ="56" ssid = "39">But some natural languages also exhibit non-concatenative morphotactics.</S>
			<S sid ="57" ssid = "40">Some times the languages themselves are called “non- concatenative languages”, but most employ significant concatenation as well, so the term “not completely concatenative” (Lavie et al., 1988) is usually more appropriate.</S>
			<S sid ="58" ssid = "41">In Arabic, for example, prefixes and suffixes attach to stems in the usual concatenative way, but stems themselves are formed by a process known informally as interdigitation; while in Malay, noun plurals are formed by a process known as full-stem reduplication.</S>
			<S sid ="59" ssid = "42">Although Arabic and Malay also include prefixation and suffixation that are modeled straightforwardly by concatenation, a complete lexicon cannot be a a:0 *:a *:0 *:0 0:a obtained without non-concatenative processes.</S>
			<S sid ="60" ssid = "43">We will proceed with descriptions of how Malay reduplication and Semitic stem interdigitation are handled in finite-state morphology using the new compile-replace algorithm.</S>
	</SECTION>
	<SECTION title="Compile-Replace. " number = "3">
			<S sid ="61" ssid = "1">The central idea in our approach to the modeling of non-concatenative processes is to define networks using regular expressions, as before; but we now define the strings of an intermediate network so that they contain appropriate substrings that are themselves in the format of regular expressions.</S>
			<S sid ="62" ssid = "2">The compile- replace algorithm then reapplies the regular- expression compiler to its own output, compiling the regular-expression substrings in the intermediate network and replacing them with the result of the compilation.</S>
			<S sid ="63" ssid = "3">To take a simple non-linguistic example, Figure 8 represents a network that maps the regular expression a* into ^[a*^]; that is, the same expression enclosed between two special delimiters, ^[ and ^], that mark it as a regular- expression substring.Figure 9: After the Application of Compile Replace lower) of the network.</S>
			<S sid ="64" ssid = "4">Until an opening delimiter ^[ is encountered, the algorithm constructs a copy of the path it is following.</S>
			<S sid ="65" ssid = "5">If the network contains no regular-expression substrings, the result will be a copy of the original network.</S>
			<S sid ="66" ssid = "6">When a ^[ is encountered, the algorithm looks for a closing ^] and extracts the path between the delimiters to be handled in a special way: 1.</S>
			<S sid ="67" ssid = "7">The symbols along the indicated side of the.</S>
			<S sid ="68" ssid = "8">path are concatenated into a string and eliminated from the path leaving just the symbols on the opposite side.</S>
			<S sid ="69" ssid = "9">2.</S>
			<S sid ="70" ssid = "10">A separate network is created that contains the modified path.</S>
			<S sid ="71" ssid = "11">3.</S>
			<S sid ="72" ssid = "12">The extracted string is compiled into a. second network with the standard regular- expression compiler.</S>
	</SECTION>
	<SECTION title="The two networks are combined into a sin-. " number = "4">
			<S sid ="73" ssid = "1">gle one using the crossproduct operation.</S>
	</SECTION>
	<SECTION title="The result is spliced between the states rep-. " number = "5">
			<S sid ="74" ssid = "1">resenting the origin and the destination of 0:^[ a * 0:^] the regular-expression path.</S>
			<S sid ="75" ssid = "2">Figure 8: A Network with a Regular-Expression Substring on the Lower Side The application of the compile-replace algorithm to the lower side of the network eliminates the markers, compiles the regular expression a* and maps the upper side of the path to the language resulting from the compilation.</S>
			<S sid ="76" ssid = "3">The network created by the operation is shown in Figure 9.</S>
			<S sid ="77" ssid = "4">When applied in the “upward” direction, the transducer in Figure 9 maps any string of the infinite a* language into the regular expression from which the language was compiled.</S>
			<S sid ="78" ssid = "5">The compile-replace algorithm is essentially a variant of a simple recursive-descent copyingroutine.</S>
			<S sid ="79" ssid = "6">It expects to find delimited regular expression substrings on a given side (upper or After the special treatment of the regular- expression path is finished, normal processing is resumed in the destination state of the closing ^] arc. For example, the result shown in Figure 9 represents the crossproduct of the two networks shown in Figure 10.</S>
			<S sid ="80" ssid = "7">a * a Figure 10: Networks Illustrating Steps 2 and 3 of the Compile-Replace Algorithm In this simple example, the upper language of the original network in Figure 8 is identical to the regular expression that is compiled and replaced.</S>
			<S sid ="81" ssid = "8">In the linguistic applications presented Lexical: b a g i +Noun +Plural Surface: ^[ { b a g i } ^ 2 ^] Lexical: p e l a b u h a n +Noun +Plural Surface: ^[ { p e l a b u h a n } ^ 2 ^] Figure 11: Two Paths in the Initial Malay Transducer Defined via Concatenation in the next sections, the two sides of a regular- expression path contain different strings.</S>
			<S sid ="82" ssid = "9">The upper side contains morphological information; the regular-expression operators appear only on the lower side and are not present in the final result.</S>
			<S sid ="83" ssid = "10">3.1 Reduplication.</S>
			<S sid ="84" ssid = "11">Traditional Two-Level implementations are already capable of describing some limited reduplication and infixation as in Tagalog (Antworth, 1990, 156–162).</S>
			<S sid ="85" ssid = "12">The more challenging phenomenon is variable-length redupli- cation, as found in Malay and the closely related Indonesian language.</S>
			<S sid ="86" ssid = "13">An example of variable-length full-stem reduplication occurs with the Malay stem bagi, which means “bag” or “suitcase”; this form is in fact number-neutral and can translate as the plural.</S>
			<S sid ="87" ssid = "14">Its overt plural is phonologically bagibagi,3 formed by repeating the stem twice in a row.</S>
			<S sid ="88" ssid = "15">Although this pluralization process may appear concatenative, it does not involve concatenating a predictable pluralizing morpheme, but rather copying the preceding stem, whatever it may be and however long it may be.</S>
			<S sid ="89" ssid = "16">Thus the overt plural of pelabuhan (“port”), itself a derived form, is phonologically pelabuhanpelabuhan.</S>
			<S sid ="90" ssid = "17">Productive reduplication cannot be described by finite-state or even context-free formalisms.</S>
			<S sid ="91" ssid = "18">It is well known that the copy language, {ww | w ǫ L}, where each word contains two copies of the same string, is a context-sensitive language.</S>
			<S sid ="92" ssid = "19">However, if the “base” language L is finite, we can construct a finite-state network that encodes L and the reduplications of all the strings in L. On the assumption that there are only a finite number of words subject to reduplication (no free compounding), it is possible to construct a lexical transducer for languages 3 In the standard orthography, such reduplicated words are written with a hyphen, e.g. bagibagi, that we will ignore for this example.</S>
			<S sid ="93" ssid = "20">such as Malay.</S>
			<S sid ="94" ssid = "21">We will show a simple and elegant way to do this with strictly finite-state operations.</S>
			<S sid ="95" ssid = "22">To understand the general solution to full- stem reduplication using the compile-replace algorithm requires a bit of background.</S>
			<S sid ="96" ssid = "23">In the regular expression calculus there are several operators that involve concatenation.</S>
			<S sid ="97" ssid = "24">For example, if A is a regular expression denoting a language or a relation, A* denotes zero or more and A+ denotes one or more concatenations of A with itself.</S>
			<S sid ="98" ssid = "25">There are also operators that express a fixed number of concatenations.</S>
			<S sid ="99" ssid = "26">In the Xerox calculus, expressions of the form A^n, where n is an integer, denote n concatenations of A. {abc} denotes the concatenation of symbols a, b, and c. We also employ ^[ and ^] as delimiter symbols around regular-expression substrings.</S>
			<S sid ="100" ssid = "27">The reduplication of any string w can then be notated as {w}^2, and we start by defining a network where the lower-side strings are built by simple concatenation of a prefix ^[, a root enclosed in braces, and an overt-plural suffix ^2 followed by the closing ^].</S>
			<S sid ="101" ssid = "28">Figure 11 shows the paths for two Malay plurals in the initial network.</S>
			<S sid ="102" ssid = "29">The compile-replace algorithm, applied to the lower-side of this network, recognizes each individual delimited regular-expression substring like ^[{bagi}^2^], compiles it, and replaces it with the result of the compilation, here bagibagi.</S>
			<S sid ="103" ssid = "30">The same process applies to the entire lower-side language, resulting in a network that relates pairs of strings such as the ones in Figure 12.</S>
			<S sid ="104" ssid = "31">This provides the desired solution, still finite-state, for analyzing and generating full- stem reduplication in Malay.4 4 It is well-known (McCarthy and Prince, 1995) that reduplication can be a more complex phenomenon than it is in Malay.</S>
			<S sid ="105" ssid = "32">In some languages only a part of the stem is reduplicated and there may be systematic differences between the reduplicate and the base form.</S>
			<S sid ="106" ssid = "33">We believe that our approach to reduplication can account for these complex phenomena as well but we cannot discuss the Lexical: b a g i +Noun +Plural Surface: b a g i b a g i Lexical: p e l a b u h a n +Noun +Plural Surface: p e l a b u h a n p e l a b u h a n Figure 12: The Malay fst After the Application of Compile-Replace to the Lower-Side Language The special delimiters ^[ and ^] can be used to surround any appropriate regular- expression substring, using any necessary regular-expression operators, and compile- replace may be applied to the lower-side and/or upper-side of the network as desired.</S>
			<S sid ="107" ssid = "34">There is nothing to stop the linguist from inserting delimiters multiple times, including via composition, and reapplying compile-replace multiple times (see the Appendix).</S>
			<S sid ="108" ssid = "35">The technique implemented in compile-replace is a general way of allowing the regular-expression compiler to reapply to and modify its own output.</S>
			<S sid ="109" ssid = "36">3.2 Semitic Stem Interdigitation.</S>
			<S sid ="110" ssid = "37">3.2.1 Review of Earlier Work Much of the work in non-concatenative finite- state morphotactics has been dedicated to handling Semitic stem interdigitation.</S>
			<S sid ="111" ssid = "38">An example of interdigitation occurs with the Arabic stem katab, which means “wrote”.</S>
			<S sid ="112" ssid = "39">According to an influential autosegmental analysis (McCarthy, 1981), this stem consists of an all-consonant root ktb whose general meaning has to do with writing, an abstract consonant-vowel template CVCVC, and a voweling or vocalization that he symbolized simply as a, signifying perfect aspect and active voice.</S>
			<S sid ="113" ssid = "40">The root consonants are associated with the C slots of the template and the vowel or vowels with the V slots, producing a complete stem katab.</S>
			<S sid ="114" ssid = "41">If the root and the vocalization are thought of as morphemes, neither morpheme occurs continuously in the stem.</S>
			<S sid ="115" ssid = "42">The same root ktb can combine with the template CVCVC and a different vocalization ui, signifying perfect aspect and passive voice, producing the stem kutib, which means “was written”.</S>
			<S sid ="116" ssid = "43">Similarly, the root ktb can combine with template CVVCVC and ui to produce kuutib, the root drs can combine with CVCVC and ui to form duris, and so forth.</S>
			<S sid ="117" ssid = "44">tiers of McCarthy (1981) as projections of a multi-level transducer and wrote a small Prolog- based prototype that handled the interdigitation of roots, CV-templates and vocalizations into abstract Arabic stems; this general approach, with multi-tape transducers, has been explored and extended by Kiraz in several papers (1994a; 1996; 1994b; 2000) with respect to Syriac and Arabic.</S>
			<S sid ="118" ssid = "45">The implementation is described in Kiraz and GrimleyEvans (1999).</S>
			<S sid ="119" ssid = "46">In work more directly related to the current solution, it was Kataja and Koskenniemi (1988) who first demonstrated that Semitic (Akkadian) roots and patterns5 could be formalized as regular languages, and that the non-concatenative interdigitation of stems could be elegantly formalized as the intersection of those regular languages.</S>
			<S sid ="120" ssid = "47">Thus Akkadian words were formalized as consisting of morphemes, some of which were combined together by intersection and others of which were combined via concatenation.</S>
			<S sid ="121" ssid = "48">This was the key insight: morphotactic description could employ various finite-state operations, not just concatenation; and languages that required only concatenation were just special cases.</S>
			<S sid ="122" ssid = "49">By extension, the widely noticed limitations of early finite-state implementations in dealing with non-concatenative morphotactics could be traced to their dependence on the concatenation operation in morphotactic descriptions.</S>
			<S sid ="123" ssid = "50">This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime.</S>
			<S sid ="124" ssid = "51">Kay (1987) reformalized the autosegmental 5 These patterns combine what McCarthy (1981).</S>
			<S sid ="125" ssid = "52">issue here due to lack of space.</S>
			<S sid ="126" ssid = "53">would call templates and vocalizations.</S>
			<S sid ="127" ssid = "54">The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle about 90,000 stems on a SUN Ultra workstation.</S>
			<S sid ="128" ssid = "55">The compile-replace algorithm is a vast improvement in both generality and efficiency, producing the same result in a few minutes.</S>
			<S sid ="129" ssid = "56">Following the lines of Kataja and Koskenniemi (1988), we could define intermediate networks with regular-expression substrings that indicate the intersection of suitably encoded roots, templates, and vocalizations (for a formal description of what such regular-expression substrings would look like, see Beesley (1998c; 1998b)).</S>
			<S sid ="130" ssid = "57">However, the general-purpose intersection algorithm would be expensive in any nontrivial application, and the interdigitation of stems represents a special case of intersection that we achieve in practice by a much more efficient finite-state algorithm called merge.</S>
			<S sid ="131" ssid = "58">3.2.2 Merge The merge algorithm is a pattern-filling operation that combines two regular languages, a template and a filler, into a single one.</S>
			<S sid ="132" ssid = "59">The strings of the filler language consist of ordinary symbols such as d, r, s, u, i. The template expressions may contain special class symbols such as C (= consonant) or V (= vowel) that represent a predefined set of ordinary symbols.</S>
			<S sid ="133" ssid = "60">The objective of the merge operation is to align the template strings with the filler strings and to instantiate the class symbols of the template as the matching filler symbols.</S>
			<S sid ="134" ssid = "61">Like intersection, the merge algorithm operates by following two paths, one in the template network, the other in the filler network, and it constructs the corresponding single path in the result network.</S>
			<S sid ="135" ssid = "62">Every state in the result corresponds to two original states, one in template, the other in the filler.</S>
			<S sid ="136" ssid = "63">If the original states are both final, the resulting state is also final; otherwise it is non-final.</S>
			<S sid ="137" ssid = "64">In other words, in order to construct a successful path, the algorithm must reach a final state in both of the original networks.</S>
			<S sid ="138" ssid = "65">If the new path terminates in a non-final state, it represents a failure and will eventually be pruned out.</S>
			<S sid ="139" ssid = "66">The operation starts in the initial state of the original networks.</S>
			<S sid ="140" ssid = "67">At each point, the algorithm tries to find all the successful matches between the template arcs and filler arcs.</S>
			<S sid ="141" ssid = "68">A match is successful if the filler arc symbol is included in the class designated by the template arc symbol.</S>
			<S sid ="142" ssid = "69">The main difference between merge and classical intersection is in Conditions 1 and 2 below: 1.</S>
			<S sid ="143" ssid = "70">If a successful match is found, a new arc is. added to the current result state.</S>
			<S sid ="144" ssid = "71">The arc is labeled with the filler arc symbol; its destination is the result state that corresponds to the two original destinations.</S>
			<S sid ="145" ssid = "72">2.</S>
			<S sid ="146" ssid = "73">If no successful match is found for a given.</S>
			<S sid ="147" ssid = "74">template arc, the arc is copied into the current result state.</S>
			<S sid ="148" ssid = "75">Its destination is the result state that corresponds to the destination of the template arc and the current filler state.</S>
			<S sid ="149" ssid = "76">In effect, Condition 2 preserves any template arc that does not find a match.</S>
			<S sid ="150" ssid = "77">In that case, the path in the template network advances to a new state while the path in the filler network stays at the current state.</S>
			<S sid ="151" ssid = "78">We use the networks in Figure 13 to illustrate the effect of the merge algorithm.</S>
			<S sid ="152" ssid = "79">Figure 13 shows a linear template network and two filler networks, one of which is cyclic.</S>
			<S sid ="153" ssid = "80">C V V C V C d r s i u Figure 13: A Template Network and Two Filler Networks It is easy to see that the merge of the drs network with the template network yields the result shown in Figure 14.</S>
			<S sid ="154" ssid = "81">The three symbols of the filler string are instantiated in the three consonant slots in the CVVCVC template.</S>
			<S sid ="155" ssid = "82">d V V r V s Figure 14: Intermediate Result.</S>
			<S sid ="156" ssid = "83">Figure 15 presents the final result in which the second filler network in Figure 13 is merged with the intermediate result shown in Figure 14.</S>
			<S sid ="157" ssid = "84">Lexical: k t b =Root C V C V C =Template a + =Voc Surface: ^[ k t b .m&gt;.</S>
			<S sid ="158" ssid = "85">C V C V C .&lt;m. a + ^] Lexical: k t b =Root C V C V C =Template u * i =Voc Surface: ^[ k t b .m&gt;.</S>
			<S sid ="159" ssid = "86">C V C V C .&lt;m. u * i ^] Lexical: d r s =Root C V V C V C =Template u * i =Voc Surface: ^[ d r s .m&gt;.</S>
			<S sid ="160" ssid = "87">C V V C V C .&lt;m. u * i ^] Figure 16: Initial paths d u u r i s Figure 15: Final Result In this case, the filler language contains an infinite set of strings, but only one successful path can be constructed.</S>
			<S sid ="161" ssid = "88">Because the filler string ends with a single i, the first two V symbols can be instantiated only as u. Note that ordinary symbols in the partially filled template are treated like the class symbols that do not find a match.</S>
			<S sid ="162" ssid = "89">That is, they are copied into the result in their current position without consuming a filler symbol.</S>
			<S sid ="163" ssid = "90">To introduce the merge operation into the Xerox regular expression calculus we need to choose an operator symbol.</S>
			<S sid ="164" ssid = "91">Because merge, like subtraction, is a non-commutative operation, we also must distinguish between the template and the filler.</S>
			<S sid ="165" ssid = "92">For example, we could choose .m. as the operator and decide by convention which of the two operands plays which role in expressions such as [A .m. B].</S>
			<S sid ="166" ssid = "93">What we actually have done, perhaps without a sufficiently good motivation, is to introduce two variants of the merge operator, .&lt;m. and .m&gt;., that differ only with respect to whether the template is to the left (.&lt;m.) or to the right (.m&gt;.)</S>
			<S sid ="167" ssid = "94">of the filler.</S>
			<S sid ="168" ssid = "95">The expression [A .&lt;m. B] represents the same merge operation as [B .m&gt;.</S>
			<S sid ="169" ssid = "96">A].</S>
			<S sid ="170" ssid = "97">In both cases, A denotes the template, B denotes the filler, and the result is the same.</S>
			<S sid ="171" ssid = "98">With these new operators, the network in Figure 15 can be compiled from an expression such as d r s .m&gt;.</S>
			<S sid ="172" ssid = "99">C V V C V C .&lt;m. u* i As we have defined them, .&lt;m. and .m&gt;.</S>
			<S sid ="173" ssid = "100">are weakly binding left-associative operators.</S>
			<S sid ="174" ssid = "101">In this example, the first merge instantiates the filler consonants, the second operation fills the vowel slots.</S>
			<S sid ="175" ssid = "102">However, the order in which the merge operations are performed is irrelevant in this case because the two filler languages do not provide competing instantiations for the same class symbols.</S>
			<S sid ="176" ssid = "103">3.2.3 Merging Roots and Vocalizations with Templates Following the tradition, we can represent the lexical forms of Arabic stems as consisting of three components, a consonantal root, a CV template and a vocalization, possibly preceded and followed by additional affixes.</S>
			<S sid ="177" ssid = "104">In contrast to McCarthy, Kay, and Kiraz, we combine the three components into a single projection.</S>
			<S sid ="178" ssid = "105">In a sense, McCarthy’s three tiers are conflated into a single one with three distinct parts.</S>
			<S sid ="179" ssid = "106">In our opinion, there is no substantive difference from a computational point of view.</S>
			<S sid ="180" ssid = "107">For example, the initial lexical representation of the surface forms katab, kutib, and duuris, may be represented as a concatenation of the three components shown in Figure 16.</S>
			<S sid ="181" ssid = "108">We use the symbols =Root, =Template, and =Voc to designate the three components of the lexical form.</S>
			<S sid ="182" ssid = "109">The corresponding initial surface form is a regular-expression substring, containing two merge operators, that will be compiled and replaced by the interdigitated surface form.</S>
			<S sid ="183" ssid = "110">The application of the compile-replace operation to the lower side of the initial lexicon yields a transducer that maps the Arabic interdigitated forms directly into their corresponding tripartite analyses and vice versa, as illustrated in Figure 17.</S>
			<S sid ="184" ssid = "111">Alternation rules are subsequently composed on the lower side of the result to map the in- terdigitated, but still morphophonemic, strings into real surface strings.</S>
			<S sid ="185" ssid = "112">Although many Arabic templates are widely considered to be pure CV-patterns, it has been argued that certain templates also contain Lexical: k t b =Root C V C V C =Template a + =Voc Surface: k a t a b Lexical: k t b =Root C V C V C =Template u * i =Voc Surface: k u t i b Lexical: d r s =Root C V V C V C =Template u * i =Voc Surface: d u u r i s Figure 17: After Applying Compile-Replace to the Lower Side “hard-wired” specific vowels and consonants.6 For example, the so-called “FormVIII” template is considered, by some linguists, to contain an embedded t: CtVCVC.</S>
			<S sid ="186" ssid = "113">The presence of ordinary symbols in the template does not pose any problem for the analysis adopted here.</S>
			<S sid ="187" ssid = "114">As we already mentioned in discussing the intermediate representation in Figure 14, the merge operation treats ordinary symbols in a partially filled template in the same manner as it treats unmatched class symbols.</S>
			<S sid ="188" ssid = "115">The merge of a root such as ktb with the presumed FormVIII template and the a+ vocal- ism, k t b .m&gt;.</S>
			<S sid ="189" ssid = "116">C t V C V C .&lt;m. a+ produces the desired result, ktatab, without any additional mechanism.</S>
			<S sid ="190" ssid = "117">4 Status of the Implementations.</S>
			<S sid ="191" ssid = "118">4.1 Malay Morphological.</S>
			<S sid ="192" ssid = "119">Analyzer/Generator Malay and Indonesian are closely-related languages characterized by rich derivation and little or nothing that could be called inflection.</S>
			<S sid ="193" ssid = "120">The Malay morphological analyzer prototype, written using lexc, Replace Rules, and compile-replace, implements approximately 50 different derivational processes, including pre- fixation, suffixation, prefix-suffix pairs (circum- fixation), reduplication, some infixation, and combinations of these processes.</S>
			<S sid ="194" ssid = "121">Each root is marked manually in the source dictionary to indicate the idiosyncratic subset of derivational processes that it undergoes.</S>
			<S sid ="195" ssid = "122">The small prototype dictionary, stored in an XML format, contains approximately 1000 roots, with about 1500 derivational subentries (i.e. an average of 1.5 derivational processes per root).</S>
			<S sid ="196" ssid = "123">At compile time, the XML dictionary is parsed and “downtranslated” into the source format required for the lexc compiler.</S>
			<S sid ="197" ssid = "124">The XML dictionary could be expanded by any competent Malay lexicographer.</S>
			<S sid ="198" ssid = "125">4.2 Arabic Morphological.</S>
			<S sid ="199" ssid = "126">Analyzer/Generator The current Arabic system has been described in some detail in previous publications (Beesley, 1996; Beesley, 1998a; Beesley, 1998b) and is available for testing on the Internet.7 The modification of the system to use the compile-replace algorithm has not changed the size or the behavior of the system in any way, but it has reduced the compilation time from hours to minutes.</S>
			<S sid ="200" ssid = "127">5 Conclusion.</S>
			<S sid ="201" ssid = "128">The well-founded criticism of traditional implementations of finite-state morphology, that they are limited to handling concatenative morpho- tactics, is a direct result of their dependence on the concatenation operation in morphotactic description.</S>
			<S sid ="202" ssid = "129">The technique described here, implemented in the compile-replace algorithm, allows the regular-expression compiler to reapply to and modify its own output, effectively freeing morphotactic description to use any finite-state operation.</S>
			<S sid ="203" ssid = "130">Significant experiments with Malay and a much larger application in Arabic have shown the value of this technique in handling two classic examples of non-concatenative morphotactics: full-stem reduplication and Semitic stem interdigitation.</S>
			<S sid ="204" ssid = "131">Work remains to be done in applying the technique to other known varieties of non-concatenative morphotactics.</S>
			<S sid ="205" ssid = "132">The compile-replace algorithm and the merge operator introduced in this paper are general techniques not limited to handling the specific</S>
	</SECTION>
	<SECTION title="See Beesley (1998c) for a discussion of this contro-. " number = "6">
			<S sid ="206" ssid = "1">versial issue.</S>
			<S sid ="207" ssid = "2">7 http://www.x rce.xerox.com /research/mlt t/arabic/ morphotactic problems we have discussed.</S>
			<S sid ="208" ssid = "3">We expect that they will have many other useful applications.</S>
			<S sid ="209" ssid = "4">One illustration is given in the Appendix.</S>
			<S sid ="210" ssid = "5">6 Appendix: Palindrome Extraction.</S>
			<S sid ="211" ssid = "6">To demonstrate the power of the compile- replace method, let us show how it can be applied to solve another “hard” problem: identifying and extracting all the palindromes from a lexicon.</S>
			<S sid ="212" ssid = "7">Like reduplication, palindrome identification appears at first to require more powerful tools than a finite-state calculus.</S>
			<S sid ="213" ssid = "8">But this task can be accomplished, in fact quite efficiently, by using the compile-replace technique.</S>
			<S sid ="214" ssid = "9">Let us assume that L is a simple network constructed from an English wordlist.</S>
			<S sid ="215" ssid = "10">We start by extracting from L all the words with a property that is necessary but not sufficient for being a palindrome, namely, the words whose inverse is also an English word.</S>
			<S sid ="216" ssid = "11">This step can be accomplished by redefining L as [L &amp; L.r] where &amp; represents intersection and .r is the reverse operator.</S>
			<S sid ="217" ssid = "12">The resulting network contains palindromes such as madam as well non-palindromes such as dog and god.</S>
			<S sid ="218" ssid = "13">The remaining task is to eliminate all the words like dog that are not identical to their own inverse.</S>
			<S sid ="219" ssid = "14">This can be done in three steps.</S>
			<S sid ="220" ssid = "15">We first apply the technique used for Malay reduplication.</S>
			<S sid ="221" ssid = "16">That is, we redefine L as &quot;^[&quot; &quot;[&quot; L XX &quot;]&quot; &quot;^&quot; 2 &quot;^]&quot;, and apply the compile-replace operation.</S>
			<S sid ="222" ssid = "17">At this point the lower-side of L contains strings such as dogXXdogXX and madamXXmadamXX where XX is a specially introduced symbol to mark the middle (and the end) of each string.</S>
			<S sid ="223" ssid = "18">The next, and somewhat delicate, step is to replace the XX markers by the desired operators, intersection and reverse, and to wrap the special regular expression delimiters ^[ and ^] around the whole lexicon.</S>
			<S sid ="224" ssid = "19">This can be done by composing L with one or several replace transducers to yield a network consisting of expressions such as ^[ d o g &amp; [d o g].r ^] and ^[ m a d a m &amp; [m a d a m].r ^] In the third and final step, the application of compile-replace eliminates words like dog because the intersection of dog with the inverted form god is empty.</S>
			<S sid ="225" ssid = "20">Only the palindromes survive the operation.</S>
			<S sid ="226" ssid = "21">The extrac tion of all the palindromes from the 25K Unix /usr/dict/words file by this method takes a couple of seconds.</S>
	</SECTION>
</PAPER>
