<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">This paper describes a finite-state morphological analyzer of Modern Standard Arabic words that can be tested on the Internet.</S>
		<S sid ="2" ssid = "2">An overview of the system is provided, including the history, the finite-state technology, and the dictionary coverage.</S>
		<S sid ="3" ssid = "3">This research system is scheduled for testing and commercial development in 2001.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="4" ssid = "4">In 1996, the Xerox Research Centre Europe produced a morphological analyzer for Modern Standard Arabic, henceforth Arabic (Beesley, 1996).</S>
			<S sid ="5" ssid = "5">In 1997 a Javaapplet interface was added to allow testing on the Internet using standard Arabic orthography.</S>
			<S sid ="6" ssid = "6">The analyzer-generator is based on dictionaries from an earlier project at ALPNET (Beesley, 1990; Buckwalter, 1990), but the system was extensively redesigned and rebuilt using Xerox finite-state technology (Beesley and Karttunen, 2001).</S>
			<S sid ="7" ssid = "7">The system analyzes orthographical words that may include full, partial, or no diacritics; and if diacritics are present, they automatically constrain the ambiguity of the output.</S>
			<S sid ="8" ssid = "8">A fully- voweled spelling and a terse English gloss are also returned with each analysis.</S>
			<S sid ="9" ssid = "9">The system is intended to serve as a pedagogical aid, a comprehension-assistance tool, and as a component in larger natural-language-processing systems.</S>
			<S sid ="10" ssid = "10">morphological analyses Morphological Analyzer word Figure 1: A Generic Morphological Analyzer as a Black Box</S>
	</SECTION>
	<SECTION title="Challenges of the Arabic System. " number = "2">
			<S sid ="11" ssid = "1">2.1 General Morphological Analysis.</S>
			<S sid ="12" ssid = "2">In its simplest diagrammatic form, a morphological analyzer can be characterized as a black-box module (see Figure 1) that accepts words and outputs morphological analyses.</S>
			<S sid ="13" ssid = "3">Such black boxes might be implemented in any number of ways.</S>
			<S sid ="14" ssid = "4">In computer analysis of Arabic, or of any other language, the input words are in digital form, with the characters in standard encodings like ASMO88596 and Unicode.</S>
			<S sid ="15" ssid = "5">As for the content of the morphological analyses, they will always be somewhat theory- and application-dependent.</S>
			<S sid ="16" ssid = "6">In the broadest terms, a morphological analyzer should separate and identify the component morphemes of the input word, labeling them somehow with sufficient information to be useful for the tasks at hand.</S>
			<S sid ="17" ssid = "7">2.2 Arabic Morphological Analysis.</S>
			<S sid ="18" ssid = "8">In the case of Arabic, one would certainly expect a morphological analyzer to separate and identify prefixed word-like morphemes such as the conjunctions wa– and fa–, prefixed prepositions such as bi– and li–, the definite article, verbal prefixes and suffixes, nominal case suffixes, and enclitic direct-object and possessive-pronoun suffixes.</S>
			<S sid ="19" ssid = "9">Where things become more complicated is in the formal analysis of the Arabic or, more generally, the Semitic STEM; various lexicographers and linguists have proposed: 1.</S>
			<S sid ="20" ssid = "10">Stems as one-part structures: i.e. a stem is. simply treated as a single monolithic morpheme.</S>
			<S sid ="21" ssid = "11">2.</S>
			<S sid ="22" ssid = "12">Stems as two-part constructs of a ROOT mor-.</S>
			<S sid ="23" ssid = "13">In what follows, I shall assume that Semitic stems are built from at least two morpheme components, including a root usually consisting of three (but sometimes two or four) radicals like ktb ( ), drs ( ), f l ( ), klkl ( ), sm ( ) or tm ( ).5 I shall also assume that a crucial task for a morphological analyzer is to separate and identify these underly ing roots, even if they are obscured in the surface word by morphophonological or orthographical alternations.In addition to the arguments for the linguis 6 pheme and a PATTERN morpheme: e.g. root tic reality of Semitic roots, an entirely practical ktb ( )1 and a pattern spelled u i or CuCiC, where the underscores or C symbols represent slots for the root consonants,sometimes termed RADICALS.</S>
			<S sid ="24" ssid = "14">In such a sys tem, the root and pattern morphemes are said informally to “interdigitate” together to form stems like kutib ( ).2</S>
	</SECTION>
	<SECTION title="Stems as three-part constructs of a ROOT,. " number = "3">
			<S sid ="25" ssid = "1">a consonant-vowel (CV) TEMPLATE, and a VOCALIZAT IO N: e.g. ktb and template CVCVC and vocalization ui to form kutib ( ).</S>
			<S sid ="26" ssid = "2">The templates are drawn from a set of perhaps dozens, and the radicals and vowels are associated with the C and V slots via controversial association rules.</S>
			<S sid ="27" ssid = "3">Such a three- way division was popularized by some of the early work of McCarthy (1981).3</S>
	</SECTION>
	<SECTION title="Stems  as  multi-part constructs of  a  root,. " number = "4">
			<S sid ="28" ssid = "1">a prosodically motivated pattern (from a severely limited set), a vocalization, and various affixes.</S>
			<S sid ="29" ssid = "2">This approach characterizes some of the more recent work of McCarthy (1993).4 motivation for identifying roots is that traditional Arabic dictionaries, such as the authoritative Hans Wehr dictionary (Wehr, 1979), are organized with root headings.</S>
			<S sid ="30" ssid = "3">To look up a word in such a dictionary, the student must know or somehow identify the root; and this is a notoriously difficult task for students as well as for many natives.</S>
			<S sid ="31" ssid = "4">3 System.</S>
			<S sid ="32" ssid = "5">Description Users access the web-based demo via the Arabic homepage.7 The Arabic entry page (see Figure 2) is mostly filled up with a Java applet that displays a virtual Arabic keyboard.</S>
			<S sid ="33" ssid = "6">Users can type in words either by mouse-clicking on the virtual- key objects or by typing the corresponding keys on their physical keyboard.</S>
			<S sid ="34" ssid = "7">Four alternate Arabic keyboard layouts are currently provided: PC like, Mac-like, and the implementors’ preferred Buck- walter Transliteration8 laid out on both English and French keyboards.</S>
			<S sid ="35" ssid = "8">As words are typed, the appropriate Unicode Arabic characters are added to an internal buffer.</S>
			<S sid ="36" ssid = "9">This buffer is “observed” by an Arabic Canvas object that renders the appropriate Arabic glyphs right-to-left on the screen, updating the display interactively each time the buffer is changed in any way.</S>
			<S sid ="37" ssid = "10">Another related in 1 Arabic-script displays in this paper were encoded using.</S>
			<S sid ="38" ssid = "11">the ArabTeX package for TEX and LATEX by Prof. Dr. Klaus Lagally of the University of Stuttgart.</S>
			<S sid ="39" ssid = "12">2 For such a two-part analysis of Hebrew stems, see.</S>
			<S sid ="40" ssid = "13">Harris (1941) and Lavie et al.</S>
			<S sid ="41" ssid = "14">(1988); for Akkadian, see Kataja and Koskenniemi (1988); for Arabic, see the papers cited by Beesley and Buckwalter.</S>
			<S sid ="42" ssid = "15">3 Kay (1987) took McCarthy’s Arabic data and reformalized it using multi-level finite-state transducers.</S>
			<S sid ="43" ssid = "16">4 Kiraz (2000) has formalized several stages of McCarthy’s theories, using multi-level finite-state transducers and applying them to Syriac.</S>
			<S sid ="44" ssid = "17">5Depending on one’s theory, a root like tm may also be formalized as an abstract triliteral tmm or tmX, where X indicates the copying or spreading of the previous consonant (Beesley, 1998c).</S>
			<S sid ="45" ssid = "18">6For example, McCarthy (1981) cites the charming example of a Hijazi Bedouin play language wherein speakers freely scramble the order of the radicals within a root.</S>
			<S sid ="46" ssid = "19">7http://www.xrce.xerox.com/research/mlt t/ arabic 8http://www.xrce.xerox.com/research/mlt t/ arabic/info/translit-chart.html . ..</S>
			<S sid ="47" ssid = "20">Start kaaf, taa’, baa’ Observable Buffer Object End a n a l y s i s 1 a n a l y s i s 2 UNICODE UNICODE Mouse Click Events Key Press Events analysis3 analysisn Morphological Morphological English Analyzer Generator Gloss FST FST Buffer Virtual Keyboard Java Object Physical Keyboard fully voweled input word glossesFigure 2: User Interface with Arabic Script Dis play in Java.</S>
			<S sid ="48" ssid = "21">Mouse clicks on the virtual keyboard or key presses on the physical keyboard are intercepted, converted to Arabic Unicode characters, and stored in a buffer, which has a start and an end but no inherent ordering.</S>
			<S sid ="49" ssid = "22">The Arabic Canvas Object observes the buffer and contains an Arabic Scribe object that renders the string of Unicode characters right-to-left as connected Arabic glyphs.</S>
			<S sid ="50" ssid = "23">Web Browser with Java Applet Output HTML Input words CGI Script in Perl running on a Xerox server put page allows the user to cut and paste words from other Arabic-language webpages, including those encoded in MS 1256.</S>
			<S sid ="51" ssid = "24">When the user presses the Enter key the buffer contents are sent to a Perl CGI script running on a server in Grenoble, France.</S>
			<S sid ="52" ssid = "25">The script passes each input word to the morphological analyzer (Figure 3), which is implemented as a finite-state transducer (FST).</S>
			<S sid ="53" ssid = "26">Typically there are several output strings, each representing a possible analysis of the input word.9 When presenting the various solutions back to the user, it is valuable to display the fully-voweled (full diacritics) spelling of each solution.</S>
			<S sid ="54" ssid = "27">So each solution is passed to a morphological generator FST, which is exactly the same as the an 9 The terms string and word are used interchangeably..</S>
			<S sid ="55" ssid = "28">Figure 3: Information Flow in the Xerox Arabic Demo.</S>
			<S sid ="56" ssid = "29">Input words from the user interface are transmitted across the Internet (dotted lines) and analyzed by a server, typically producing multiple analysis strings.</S>
			<S sid ="57" ssid = "30">Each analysis string is then generated in fully voweled form, combined with English glosses and then reformatted as HTML before being sent back across the Internet to the user’s browser for display.</S>
			<S sid ="58" ssid = "31">The analyzer and generator finite-state transducers (FSTs) are identical except that the lower side language of the generator is limited to contain only fully-voweled words.</S>
			<S sid ="59" ssid = "32">alyzer except for having a lower-level language that is restricted to fully-voweled strings.</S>
			<S sid ="60" ssid = "33">The various solutions are also tokenized into morphemes, which are looked up in a dictionary of English glosses.</S>
			<S sid ="61" ssid = "34">The Perl script incorporates the analyses, the generated fully-voweled strings, and the English glosses into an HTML page that is sent back to the user’s Internet browser for display.</S>
			<S sid ="62" ssid = "35">4 Finite-State Morphological Processing.</S>
			<S sid ="63" ssid = "36">4.1 General Finite-State Theory and.</S>
			<S sid ="64" ssid = "37">Techniques The Arabic Morphological Analyzer is built using finite-state compilers and algorithms, and the results are stored and run as finite-state transducers.</S>
			<S sid ="65" ssid = "38">The finite-state approach to morphology, using a variety of software implementations, has become very popular around the world, having been used to create morphological analyzers for all the commercially important European languages, including Hungarian and Finnish, as well as Japanese, Korean, Swahili, Aymara, Malay, Klingon, etc. While the original Two-Level implementation (Koskenniemi, 1983; Antworth, 1990) of finite- state theory was not particularly well-suited to Semitic languages, modification of the two-level paradigm and more advanced finite-state implementations have been applied successfully to a variety of Semitic languages, including Ancient Akkadian (Kataja and Koskenniemi, 1988), Hebrew (Lavie et al., 1988), Syriac (Kiraz, 2000), and Arabic.</S>
			<S sid ="66" ssid = "39">4.2 Xerox Finite-State Tools and Techniques.</S>
			<S sid ="67" ssid = "40">The Xerox approach to finite-state morphology is well described elsewhere, and only an outline is possible and appropriate here.</S>
			<S sid ="68" ssid = "41">Lexicons and morphotactic information are encoded in the lexc language (Karttunen, 1993), which is a kind of right- recursive phrase-structure grammar, and are compiled into finite-state transducers.</S>
			<S sid ="69" ssid = "42">Finite-state transducers (FSTs) are data structures that encode REGULAR RELATIO NS (Kaplan and Kay, 1994), which are mappings between two regular languages.10 For our human convenience, we can visualize a finite-state relation as having 10 Some authors use the term R ATI O NA L instead of.</S>
			<S sid ="70" ssid = "43">R EG U LA R. Language of Analysis Strings Finite State Transducer Language of Surface Strings Figure 5: A morphological analyzer-generator can be implemented elegantly and efficiently as a finite-state transducer.</S>
			<S sid ="71" ssid = "44">By Xerox convention, the lower-side language consists of surface strings (words), and the upper-side language consists of strings representing analyses of the lower-side words.</S>
			<S sid ="72" ssid = "45">Such a transducer is a data structure rather than code, and the runtime code that applies such a transducer to input strings, in either direction, is completely language-independent.</S>
			<S sid ="73" ssid = "46">an upper-side regular language and a lower-side regular language; and each string in one language is related to one or more strings in the other language.</S>
			<S sid ="74" ssid = "47">By convention, the upper-side or analysis strings of an FST compiled from a lexc description consist of underlying morphemes (strings of phonemes and morphophonemes) and multicharacter-symbol TAGS like +Noun, +Verb, +Adj[jective], +Conj[unction], +VPref (verbal prefix), +Masc[culine], +Fem[inine], +Sing[ular], +Plur[al], etc. that identify the morphemes.</S>
			<S sid ="75" ssid = "48">These tags have multicharacter print names that are chosen and spelled according to the taste and needs of the developers, but they are manipulated internally exactly like the other typable characters.</S>
			<S sid ="76" ssid = "49">The related lower-side language consists of surface strings or at least more “surfacy” strings; they may still represent underlying strings requiring the application of alternation rules to map them into properly spelled surface strings.</S>
			<S sid ="77" ssid = "50">Alternation rules to perform deletion, epenthe- sis, assimilation and metathesis are written in the twolc language (Karttunen and Beesley, 1992) and/or in a newer notation known as REPLACE Dictionaries and Morphotactics Alternation Rules Compiler Lexical Transducer (a single FST) Figure 4: Creation of a Lexical Transducer.</S>
			<S sid ="78" ssid = "51">The .o. operator represents the composition operation.</S>
			<S sid ="79" ssid = "52">RULES (Karttunen, 1995; Kempe and Karttunen, 1996).</S>
			<S sid ="80" ssid = "53">These rules also compile into finite-state transducers, and all the components of the grammar are combined into a single LEXICAL TRANSDUCER (Karttunen et al., 1992) using the finite- state composition algorithm, as shown in Figure 4.</S>
			<S sid ="81" ssid = "54">Such a lexical transducer then implements the Black Box morphological analyzer sketched above in Figure 1, mapping directly between surface strings and analysis strings as shown in Figure 5.</S>
			<S sid ="82" ssid = "55">4.3 Arabic Finite-State Morphological.</S>
			<S sid ="83" ssid = "56">Analysis At Xerox, the treatment of Arabic starts with a lexc grammar where prefixes and suffixes concatenate to stems in the usual way, and where stems also are represented as a concatenation of a root and a pattern as shown in Figure 6.</S>
			<S sid ="84" ssid = "57">The first step in the modification of such strings is to interdigitate the roots and patterns to form stems, but only on the lower side of the relation.</S>
			<S sid ="85" ssid = "58">The interdigitation is formalized in finite-state terms as intersection (Beesley, 1998b; Beesley, 1998a), but it in fact represents a special case of intersection that is performed much more efficiently by a finite-state algorithm called MERGE.</S>
			<S sid ="86" ssid = "59">The application of the merge algorithm to the lower-side of the relation is performed by the COMPILER EPL ACE algorithm (Beesley and Karttunen, 2000),11 and the result is shown in Figure 7.</S>
			<S sid ="87" ssid = "60">Once compile-replace has been performed on the lower side, the necessary alternation rules can 11 Before merge and compile-replace became available, a much less efficient algorithm produced the same result by automatically generating alternation rules, compiling them, and applying them to the lower side of the transducer.</S>
			<S sid ="88" ssid = "61">be compiled and applied, via composition, in the usual way shown in Figure 4.</S>
			<S sid ="89" ssid = "62">Not surprisingly, to anyone who has studied Arabic, the rules controlling the realization of w, y and the hamza (the glottal stop) are particularly complicated.</S>
			<S sid ="90" ssid = "63">In the examples shown here, katabat is finished and can be displayed as ; the underlying final y radi cal of banayat disappears on the surface, leaving banat ( ), and the underlying medial radical w of qawula disappears as well, leaving qaala ( ), with a lengthened vowel.</S>
			<S sid ="91" ssid = "64">The state of the string pairs, after composition of the alternation rules, isshown in Figure 8.</S>
			<S sid ="92" ssid = "65">Further composition of “relax ation” rules allowing the optional deletion of short vowels and other diacritics completes the picture.</S>
			<S sid ="93" ssid = "66">The final transducer will directly map from katabat ( ) or ktbt ( ) or any partially voweled variation of the spelling to the upper- side string [ktb&amp;CaCaC]+Verb+FormI+Perf+Act+at+3P+Fem+Sg.12 In the web demo, the vari ous morphemes and tags in the analysis string are separated and reformatted in HTML for more perspicuous display to the user.</S>
			<S sid ="94" ssid = "67">4.4 Advantages and Availability of.</S>
			<S sid ="95" ssid = "68">Finite-State Implementations Wherever it is possible, computing with finite- state machines is extremely attractive.</S>
			<S sid ="96" ssid = "69">By keeping within the finite-state domain, grammatical components can be defined, combined and modified using standard finite-state operations.</S>
			<S sid ="97" ssid = "70">Lexical transducers can be run forwards to generate or backwards to analyze, and they are computationally very efficient for natural-language prob 12 The surface string ktbt ( ) is ambiguous, and the analyzer returns all the possible solutions.</S>
			<S sid ="98" ssid = "71">upper: [ktb&amp;CaCaC]+Verb+FormI+Perf+Act+at+3P+Fem+Sg lower: [ktb&amp;CaCaC] at upper: [bny&amp;CaCaC]+Verb+FormI+Perf+Act+at+3P+Fem+Sg lower: [bny&amp;CaCaC] at upper: [qwl&amp;CaCuC]+Verb+FormI+Perf+Act+a+3P+Masc+Sg lower: [qwl&amp;CaCuC] a Figure 6: Three pairs of strings in the lexicon FST compiled from the lexc description.</S>
			<S sid ="99" ssid = "72">These examples correspond to the words that will eventually be katabat ( ), banat ( ) and qaala ( ).</S>
			<S sid ="100" ssid = "73">The upper- side analysis strings contain the roots ktb, bny and qwl respectively, the verbal form I perfect active pattern CaCaC or CaCuC and the third-person feminine singular suffix at or the third-person masculine singular suffix a. The square brackets are used for convenience to delimit the stem components from the rest of the word, and the ampersand serves here as just a delimiter between the root and the pattern, which are simply concatenated together.</S>
			<S sid ="101" ssid = "74">In the upper-side strings, the various morphemes are separate and are identified with multicharacter tags and bracketing conventions.</S>
			<S sid ="102" ssid = "75">The lower-side strings, still abstract here, will be mapped via finite-state algorithms and alternation rules into properly spelled surface strings.</S>
			<S sid ="103" ssid = "76">upper: [ktb&amp;CaCaC]+Verb+FormI+Perf+Act+at+3P+Fem+Sg lower: katab at upper: [bny&amp;CaCaC]+Verb+FormI+Perf+Act+at+3P+Fem+Sg lower: banay at upper: [qwl&amp;CaCuC]+Verb+FormI+Perf+Act+a+3P+Masc+Sg lower: qawul a Figure 7: Pairs of strings from the lexicon FST after application of the compile-replace algorithm to the lower side.</S>
			<S sid ="104" ssid = "77">The lower-side strings, ignoring gaps or epsilons, are now katabat, which is essentially finished ( ), and banayat and qawula, which involve weak radicals and await the application of alternation rules to map them into their final orthographical forms and , respectively.</S>
			<S sid ="105" ssid = "78">Note that the upper-side strings have not been modified.</S>
			<S sid ="106" ssid = "79">upper: [ktb&amp;CaCaC]+Verb+FormI+Perf+Act+at+3P+Fem+Sg lower: katabat upper: [bny&amp;CaCaC]+Verb+FormI+Perf+Act+at+3P+Fem+Sg lower: banat upper: [qwl&amp;CaCuC]+Verb+FormI+Perf+Act+a+3P+Masc+Sg lower: qaala Figure 8: Pairs of strings from the lexicon FST after composition of the alternation rules on the lower side.</S>
			<S sid ="107" ssid = "80">The lower-side strings are here displayed contiguously.</S>
			<S sid ="108" ssid = "81">lems.</S>
			<S sid ="109" ssid = "82">Xerox finite-state morphological analyzers, running on modern PC and workstations, typically analyze thousands of words per second.13 The runtime code that applies lexical transducers to input strings is also completely language- independent.</S>
			<S sid ="110" ssid = "83">Thus the code that runs the Arabic morphological analyzer is exactly the same code that runs German, French, Spanish, Portuguese, Aymara, etc. Xerox’s implementation of finite-state theory has been used extensively in its own research and commercial work, and these software tools have been licensed to over 70 universities and noncommercial research centers.</S>
			<S sid ="111" ssid = "84">And Xerox is hardly alone in its enthusiasm for finite-state computing; several similar implementations of finite- state theory are now available, notably from the Summer Institute of Linguistics, AT&amp;T and the University of Gronigen.14</S>
	</SECTION>
	<SECTION title="Conclusion. " number = "5">
			<S sid ="112" ssid = "1">5.1 Status.</S>
			<S sid ="113" ssid = "2">The current underlying lexicons include about 4930 roots, each one hand-encoded to indicate the subset of patterns with which it can combine.</S>
			<S sid ="114" ssid = "3">The pattern dictionary contains about 400 phonologically distinct entries, many of them ambiguous.</S>
			<S sid ="115" ssid = "4">In practice, the average root participates in about18 morphotactically distinct stems, yielding ap proximately 90,000 stems based on roots and patterns.</S>
			<S sid ="116" ssid = "5">Some of these are phonologically indistinguishable on the lower side, resulting in approximately 70,000 root-pattern intersections to be performed just once at compile time.</S>
			<S sid ="117" ssid = "6">Various combinations of prefixes and suffixes, concatenated to the intersected stems, and filtered by composition, yield over 72,000,000 abstract words.</S>
			<S sid ="118" ssid = "7">Sixty-six finite-state alternation rules map these abstract strings into fully-voweled ortho- graphical strings, and additional orthographical 13 Performance of finite-state morphological analyzers varies linearly with the length of words and with the amount of lexical ambiguity.</S>
			<S sid ="119" ssid = "8">Arabic will be slower than our European systems, in terms of input words analyzed per second, because of the unusually large number of solutions to be computed.</S>
			<S sid ="120" ssid = "9">14 http://www.sil.org/computing/catalog/ pckimmo.html, relaxation rules are then applied to optionally delete short vowels and other diacritics, allowing the system to analyze unvoweled, partially vow- eled, and fully-voweled variant spellings of the 72,000,000 abstract words.</S>
			<S sid ="121" ssid = "10">5.2 Plans.</S>
			<S sid ="122" ssid = "11">After several years of inactivity, a new project was begun in April 2001 to test, update, and redevelop this system for commercial use.</S>
			<S sid ="123" ssid = "12">This will involve modernization of the system to incorporate improvements in finite-state algorithms and techniques developed after 1996, extensive testing on real corpora, and augmentation of the underlying dictionary, especially with proper names.</S>
			<S sid ="124" ssid = "13">Testing will no doubt uncover other omissions and infelicities.</S>
	</SECTION>
</PAPER>
