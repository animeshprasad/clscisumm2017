<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">We explore the contribution of lexical and inflectional morphology features to dependency parsing of Arabic, a morphologically rich language with complex agreement patterns.</S>
		<S sid ="2" ssid = "2">Using controlled experiments, we contrast the contribution of different part-of-speech (POS) tag sets and morphological features in two input conditions: machine-predicted condition (in which POS tags and morphological feature values are automatically assigned), and gold condition (in which their true values are known).</S>
		<S sid ="3" ssid = "3">We find that more informative (fine-grained) tag sets are useful in the gold condition, but may be detrimental in the predicted condition, where they are outperformed by simpler but more accurately predicted tag sets.</S>
		<S sid ="4" ssid = "4">We identify a set of features (definiteness, person, number, gender, and undiacritized lemma) that improve parsing quality in the predicted condition, whereas other features are more useful in gold.</S>
		<S sid ="5" ssid = "5">We are the first to show that functional features for gender and number (e.g., “broken plurals”), and optionally the related rationality (“humanness”) feature, are more helpful for parsing than form-based gender and number.</S>
		<S sid ="6" ssid = "6">We finally show that parsing quality in the predicted condition can dramatically improve by training in a combined gold+predicted condition.</S>
		<S sid ="7" ssid = "7">We experimented with two transition-based parsers, MaltParser and Easy-First Parser.</S>
		<S sid ="8" ssid = "8">Our findings are robust across parsers, models, and input conditions.</S>
		<S sid ="9" ssid = "9">This suggests that the contribution of the linguistic knowledge in the tag sets and features we identified goes beyond particular experimental settings, and may be informative for other parsers and morphologically rich languages.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="10" ssid = "10">For Arabic—as for other morphologically rich languages—the role of morphology is often expected to be essential in syntactic modeling, and the role of word order is less important than in morphologically poorer languages such as English.</S>
			<S sid ="11" ssid = "11">Morphology ∗ Nuance Communications, 505 First Ave. S, Suite 700, Seattle, WA 98104.</S>
			<S sid ="12" ssid = "12">Email: yuvalmarton@gmail.com.</S>
			<S sid ="13" ssid = "13">∗∗ Center for Computational Learning, Columbia University.</S>
			<S sid ="14" ssid = "14">Email: habash@ccls.columbia.edu.</S>
			<S sid ="15" ssid = "15">† Center for Computational Learning, Columbia University.</S>
			<S sid ="16" ssid = "16">Email: rambow@ccls.columbia.edu.</S>
			<S sid ="17" ssid = "17">Submission received: October 1, 2011; revised submission received: June 16, 2012; accepted for publication: August 3, 2012.</S>
			<S sid ="18" ssid = "18">© 2013 Association for Computational Linguistics interacts with syntax in two ways: agreement and assignment.</S>
			<S sid ="19" ssid = "19">In agreement, there is coordination between the morphological features of two words in a sentence based on their syntactic configuration (e.g., subject–verb or noun–adjective agreement in GENDER and/or NUMBER).</S>
			<S sid ="20" ssid = "20">In assignment, specific morphological feature values are assigned in certain syntactic configurations (e.g., CASE assignment for the subject or direct object of a verb).1 Parsing model design aims to come up with features that best help parsers learn the syntax and choose among different parses.</S>
			<S sid ="21" ssid = "21">The choice of optimal linguistic features depends on three factors: relevance, redundancy, and accuracy.</S>
			<S sid ="22" ssid = "22">A feature has relevance if it is useful in making an attachment (or labeling) decision.</S>
			<S sid ="23" ssid = "23">A particular feature may or may not be relevant to parsing.</S>
			<S sid ="24" ssid = "24">For example, the GENDER feature may help parse the Arabic phrase ....v....&gt;.J 1 / ..v....&gt;.J 1 ...J .L...J1 &apos;-&apos;.</S>
			<S sid ="25" ssid = "25">v. bAb AlsyArn Aljdyd/Aljdydn (‘door the-car the-newmasc.sg/fem.sg [lit.]),2 using syntactic agreement: if the-new is masculine ( ..v....&gt;.J 1), it should attach to the masculine door, resulting in the meaning ‘the car ’s new door ’; if the-new is feminine ( ....v....&gt;.J 1), it should attach to the feminine the-car, resulting in ‘the door of the new car.’ Conversely, the ASPECT feature does not constrain any syntactic decision.</S>
			<S sid ="26" ssid = "26">Even if relevant, a feature may not necessarily contribute to optimal performance because it may be redundant with other features that surpass it in relevance.</S>
			<S sid ="27" ssid = "27">For example, as we will see, the DET and STAT E features alone both help parsing because they help identify the idafa construction, but they are redundant with each other and the DET feature is more helpful because it also helps with adjectival modification of nouns.</S>
			<S sid ="28" ssid = "28">Finally, the accuracy of automatically predicting the feature values (ratio of correct predictions out of all predictions) of course affects the value of a feature on unseen text.</S>
			<S sid ="29" ssid = "29">Even if relevant and non-redundent, a feature may be hard to predict with sufficient accuracy by current technology, in which case it will be of little or no help for parsing, even if helpful when its gold values are provided.</S>
			<S sid ="30" ssid = "30">As we will see, the CASE feature is very relevant and not redundant, but it cannot be predicted with high accuracy and overall it is not useful.</S>
			<S sid ="31" ssid = "31">Different languages vary with respect to which features may be most helpful given various tradeoffs among these three factors.</S>
			<S sid ="32" ssid = "32">In the past, it has been shown that if we can recognize the relevant morphological features in assignment configurations well enough, then they contribute to parsing accuracy.</S>
			<S sid ="33" ssid = "33">For example, modeling CASE in Czech improves Czech parsing (Collins et al. 1999): CASE is relevant, not redundant, and can be predicted with sufficient accuracy.</S>
			<S sid ="34" ssid = "34">It has been more difficult showing that agreement morphology helps parsing, however, with negative results for dependency parsing in several languages (Eryigit, Nivre, and Oflazer 2008; Nivre, Boguslavsky, and Iomdin 2008; Nivre 2009).</S>
			<S sid ="35" ssid = "35">In this article we investigate morphological features for dependency parsing of Modern Standard Arabic (MSA).</S>
			<S sid ="36" ssid = "36">For MSA, the space of possible morphological features is fairly large.</S>
			<S sid ="37" ssid = "37">We determine which morphological features help and why.</S>
			<S sid ="38" ssid = "38">We further determine the upper bound for their contribution to parsing quality.</S>
			<S sid ="39" ssid = "39">Similar to previous 1 Other morphological features, such as MOOD or ASPECT, do not interact with syntax at all.</S>
			<S sid ="40" ssid = "40">Note also that.</S>
			<S sid ="41" ssid = "41">we do not commit to a specific linguistic theory with these terms; hence, other theoretical terms such as the Minimalist feature checking may be used here just as well.</S>
			<S sid ="42" ssid = "42">2 All Arabic transliterations are presented in the HSB transliteration scheme (Habash, Soudi, and.</S>
			<S sid ="43" ssid = "43">Buckwalter 2007): (alphabetically) AbtθjHxdðrzsšSDTDˇ ς γfqklmnhwy and the additional symbols: ’ .,Â , Aˇ 1, A¯ , wˆ , yˆ . , n ..,ý ,a ,u ,i , 1 ,ã , u˜ , ˜ı . 1 ∼ 162 results, assignment features, specifically CASE, are very helpful in MSA, though only under gold conditions: Because CASE is rarely explicit in the typically undiacritized written MSA, it has a dismal accuracy rate, which makes it useless when used in a machine-predicted (real, non-gold) condition.</S>
			<S sid ="44" ssid = "44">In contrast with previous results, we show agreement features are quite helpful in both gold and predicted conditions.</S>
			<S sid ="45" ssid = "45">This is likely a result of MSA having a rich agreement system, covering both verb–subject and noun–adjective relations.</S>
			<S sid ="46" ssid = "46">The result holds for both the MaltParser (Nivre 2008) and the Easy-First Parser (Goldberg and Elhadad 2010).</S>
			<S sid ="47" ssid = "47">Additionally, almost all work to date in MSA morphological analysis and part-of- speech (POS) tagging has concentrated on the morphemic form of the words.</S>
			<S sid ="48" ssid = "48">Often, however, the functional morphology (which is relevant to agreement, and relates to the meaning of the word) is at odds with the “surface” (form-based) morphology; a well-known example of this are the “broken” (irregular) plurals of nominals.</S>
			<S sid ="49" ssid = "49">We show that by modeling the functional morphology rather than the form-based morphology, we obtain a further increase in parsing performance (again, both when using gold and when using predicted POS and morphological features).</S>
			<S sid ="50" ssid = "50">To our knowledge, this work is the first to use functional morphology features in MSA processing.</S>
			<S sid ="51" ssid = "51">As a further contribution of this article, we show that for parsing with predicted POS and morphological features, training on a combination of gold and predicted POS and morphological feature values outperforms the alternative training scenarios.</S>
			<S sid ="52" ssid = "52">The article is structured as follows.</S>
			<S sid ="53" ssid = "53">We first present relevant Arabic linguistic facts, their representation in the annotated corpus we use, and variations of abstraction thereof in several POS tag sets (Section 2).</S>
			<S sid ="54" ssid = "54">We follow with a survey of related work (Section 3), and describe our basic experiments in Section 4.</S>
			<S sid ="55" ssid = "55">We first explore the contribution of various POS tag sets, (form-based) morphological features, and promising combinations thereof, to Arabic dependency parsing quality—in straightforward feature engineering design and combination heuristics.</S>
			<S sid ="56" ssid = "56">We also explore more sophisticated feature engineering for the determiner (DET) feature.</S>
			<S sid ="57" ssid = "57">In Section 5, we proceed to an extended exploration of functional features.</S>
			<S sid ="58" ssid = "58">This includes using functional NUMBER and GENDER feature values, instead of form-based values; using the non-form-based rationality (RAT) feature; and combinations thereof.</S>
			<S sid ="59" ssid = "59">We additionally consider the applicability of our results to a different parser (Section 6) and consider combining gold and predicted data for training (Section 7).</S>
			<S sid ="60" ssid = "60">Section 8 presents a result validation on unseen test data, as well as an analysis of parsing error types under different conditions.</S>
			<S sid ="61" ssid = "61">We conclude and provide a download link to our model in Section 9.</S>
			<S sid ="62" ssid = "62">Last, we include an appendix with further explorations of PERSON feature engineering, “binning” of Arabic number constructions according to their complex syntactic patterns, and embedding useful morphological features in the POS tag set.</S>
			<S sid ="63" ssid = "63">Much of Sections 2–5 was presented in two previous publications (Marton, Habash, and Rambow 2010, 2011).</S>
			<S sid ="64" ssid = "64">This article extends that previous work by: 1.</S>
			<S sid ="65" ssid = "65">evaluating all our parsing models in both gold and non-gold conditions (where before this was true for only select models in Sections 4–5), 2.</S>
			<S sid ="66" ssid = "66">using a newer version of our Arabic functional morphology resource (Section 5), 3.</S>
			<S sid ="67" ssid = "67">evaluating several of our most notable parsing models with an additional parser (Section 6), 4.</S>
			<S sid ="68" ssid = "68">exploring two additional training methods, as already mentioned above (Section 7), and 163 5.</S>
			<S sid ="69" ssid = "69">providing an extended discussion and comparison of several notable and best performing models, including analyses of their performance per dependency tag (Section 8).</S>
	</SECTION>
	<SECTION title="Experimental Data and Relevant Linguistic Concepts. " number = "2">
			<S sid ="70" ssid = "1">In this section, we present the linguistic concepts relevant to our discussion of Arabic parsing, and the data we use for our experiments.</S>
			<S sid ="71" ssid = "2">We start with the central concept of the morpheme followed by the more abstract concepts of the lexeme and lexical and inflectional features.</S>
			<S sid ="72" ssid = "3">Throughout this section, we use the term feature in its linguistic sense, as opposed to its machine learning sense that we use in Section 4.</S>
			<S sid ="73" ssid = "4">Discussions of the challenges of form-based (morpheme-based) versus functional features on the one hand, and morpho-syntactic interactions on the other hand, follow.</S>
			<S sid ="74" ssid = "5">Finally, we present the annotated corpus we use, and the various POS tag sets, that are extracted from this corpus (in varying degrees of abstraction and lexicalization), and which we use in the rest of the article.</S>
			<S sid ="75" ssid = "6">2.1 Morphemes.</S>
			<S sid ="76" ssid = "7">Words can be described in terms of their morphemes (atomic units bearing meaning); in Arabic, in addition to concatenative prefixes and suffixes, there are templatic (non-contiguous) morphemes called root and pattern.</S>
			<S sid ="77" ssid = "8">The root is typically a triplet of consonants (a.k.a. radicals).</S>
			<S sid ="78" ssid = "9">The pattern is a template made of vowels, sometimes additional consonants, and place-holders for the root radicals.</S>
			<S sid ="79" ssid = "10">The root conveys some base meaning, which patterns may modify in various ways.</S>
			<S sid ="80" ssid = "11">A combination of a root and a pattern is called a stem.</S>
			<S sid ="81" ssid = "12">More on root and pattern can be found in Section 2.2.</S>
			<S sid ="82" ssid = "13">Arabic also includes a set of clitics that are tokenized in all Arabic treebanks, with the exception of the Arabic definite article, J1 Al+ (‘the’), which is kept attached to the stem.</S>
			<S sid ="83" ssid = "14">We consider the definite article a prefix, and its presence affects the value of the DET feature in models containing it (see Section 4.3).</S>
			<S sid ="84" ssid = "15">An example of morphological analysis to the level of morphemes is the word .u _L..v s.v yu+kAtib+uwn (‘they correspond’); it has one prefix and one suffix (which at a deeper level may be viewed together as one circumfix), in addition to a stem composed of the root &apos;-&apos;&apos;-&apos;.</S>
			<S sid ="85" ssid = "16">� k-t-b (‘writing related’) and the pattern 1A2i3.3 2.2 Lexeme, Lexical Features, and Inflectional Features.</S>
			<S sid ="86" ssid = "17">Arabic words can also be described in terms of lexemes and inflectional features.</S>
			<S sid ="87" ssid = "18">We define the lexeme as the set of word forms that only vary inflectionally among each other.</S>
			<S sid ="88" ssid = "19">A lemma is one of these word forms, used for representing the lexeme word set.</S>
			<S sid ="89" ssid = "20">For example, Arabic verb lemmas are third-person masculine singular perfective.</S>
			<S sid ="90" ssid = "21">We explore using both a diacritized LEMMA feature, and an undiacritized lemma (hereafter LMM).</S>
			<S sid ="91" ssid = "22">Just as the lemma abstracts over inflectional morphology, the root abstracts over both inflectional and derivational morphology and thus provides a deeper level of lexical abstraction, indicating the “core” meaning of the word.</S>
			<S sid ="92" ssid = "23">The pattern is a generally complementary abstraction, sometimes indicating semantic notions such as 3 The digits in the pattern correspond to the positions where root radicals are inserted..</S>
			<S sid ="93" ssid = "24">164 causation and reflexiveness, among other things.</S>
			<S sid ="94" ssid = "25">We use the pattern of the lemma, not of the word form.</S>
			<S sid ="95" ssid = "26">We group the ROOT, PATTERN, LEMMA, and LMM in our discussion as lexical features (see Section 4.4).</S>
			<S sid ="96" ssid = "27">Nominal lexemes can be further classified into two groups: denoting rational (i.e., human) entities, or irrational (i.e., nonhuman) entities.</S>
			<S sid ="97" ssid = "28">The rationality (or RAT) feature interacts with syntactic agreement and other inflectional features (discussed next); as such, we group it with those features in this article.</S>
			<S sid ="98" ssid = "29">The inflectional features define the space of variations of the word forms associated with a lexeme.</S>
			<S sid ="99" ssid = "30">Words4 vary along nine dimensions: GENDER, NUMBER, and PERSON (for nominals and verbs); ASPECT, VOICE, and MOOD (for verbs); and CASE, STAT E (construct state, idafa), and the attached definite article proclitic DET (for nominals).</S>
			<S sid ="100" ssid = "31">Inflectional features abstract away from the specifics of morpheme forms.</S>
			<S sid ="101" ssid = "32">Some inflectional features affect more than one morpheme in the same word.</S>
			<S sid ="102" ssid = "33">For example, changing the value of the ASPECT feature in the earlier example from imperfective to perfective yields the word form 1_L..v &lt; kAtab+uwA (‘they corresponded’), which differs in terms of prefix, suffix, and pattern.</S>
			<S sid ="103" ssid = "34">2.3 Form-Based vs. Functional Features.</S>
			<S sid ="104" ssid = "35">Some inflectional features, specifically gender and number, are expressed using different morphemes in different words (even within the same POS).</S>
			<S sid ="105" ssid = "36">There are four sound gender-number suffixes in Arabic:5 +φ (null morpheme) for masculine singular, ..+ +n for feminine singular, .u + +wn for masculine plural, and &apos;-&apos;.</S>
			<S sid ="106" ssid = "37">1+ +At for feminine plural.</S>
			<S sid ="107" ssid = "38">Form-based GENDER and NUMBER feature values are set only according to these four morphemes (and a few others, ignored for simplicity).</S>
			<S sid ="108" ssid = "39">There are exceptions and alternative ways to express GENDER and NUMBER, however, and functional feature values take them into account: Depending on the lexeme, plurality can be expressed using sound plural suffixes or using a pattern change together with singular suffixes.A sound plural example is the word pair &apos;-&apos;.</S>
			<S sid ="109" ssid = "40">1...L.A&gt;/ .....L.A&gt; Hafiyd+an/Hafiyd+At (‘grand daughter/granddaughters.)</S>
			<S sid ="110" ssid = "41">On the other hand, the plural of the inflectionally and morphemically feminine singular word &quot;.�.J.... madras+an (‘school’) is the word V&quot;.J1.... madAris+φ (‘schools’), which is feminine and plural inflectionally, but has a masculine singular suffix.</S>
			<S sid ="111" ssid = "42">This irregular inflection, known as broken plural, is similar to the English mouse/mice, but is much more common in Arabic (over 50% of plurals in our training data).</S>
			<S sid ="112" ssid = "43">A similar inconsistency appears in feminine nominals that are not inflected using sound gender suffixes, for example, the feminine form of the masculine singu lar adjective _..J.J1 Âzraq+φ (‘blue’) is . ..J.J zarqA’+φ not &quot;.</S>
			<S sid ="113" ssid = "44">..J.J1* *Âzraq+an.</S>
			<S sid ="114" ssid = "45">To address this inconsistency in the correspondence between inflectional features and morphemes, and inspired by Smrž (2007), we distinguish between two types of inflectional features: form- based (a.k.a. surface, or illusory) features and functional features.6 Most available Arabic NLP tools and resources model morphology using form- based (“surface”) inflectional features, and do not mark rationality; this includes the Penn Arabic Treebank (PATB) (Maamouri et al. 2004), the Buckwalter morphological analyzer (Buckwalter 2004), and tools using them such as the Morphological Analysis and Disambiguation for Arabic (MADA) toolkit (Habash and Rambow 2005; Habash, Rambow, and Roth 2012).</S>
			<S sid ="115" ssid = "46">The Elixir-FM analyzer (Smrž 2007) readily provides the 4 PATBtokenized words; see Section 2.5..</S>
			<S sid ="116" ssid = "47">5 We ignore duals, which are regular in Arabic, and case/state variations in this discussion for simplicity..</S>
			<S sid ="117" ssid = "48">6 Note that the functional and form-based feature values for verbs always coincide..</S>
			<S sid ="118" ssid = "49">165 functional inflectional number feature, but not full functional gender (only for adjectives and verbs but not for nouns), nor rationality.</S>
			<S sid ="119" ssid = "50">In this article, we use an in-house system which provides functional gender, number, and rationality features (Alkuhlani and Habash 2012).</S>
			<S sid ="120" ssid = "51">See Section 5.2 for more details.</S>
			<S sid ="121" ssid = "52">2.4 Morpho-Syntactic Interactions.</S>
			<S sid ="122" ssid = "53">Inflectional features and rationality interact with syntax in two ways.</S>
			<S sid ="123" ssid = "54">In agreement relations, two words in a specific syntactic configuration have coordinated values for specific sets of features.</S>
			<S sid ="124" ssid = "55">MSA has standard (i.e., matching value) agreement for subject– verb pairs on PERSON, GENDER, and NUMBER, and for noun–adjective pairs on NUMBER, GENDER, CASE, and DET. There are, however, three very common cases of exceptional agreement: Verbs preceding subjects are always singular, adjectives of irrational plural nouns are always feminine singular, and verbs whose subjects are irrational plural are also always feminine singular.</S>
			<S sid ="125" ssid = "56">See the example in Figure 1: the adjective, &apos;-&apos;.</S>
			<S sid ="126" ssid = "57">.L ..J1AlðkyAt (‘smart’), of the feminine plural (and rational) &apos;-&apos;.</S>
			<S sid ="127" ssid = "58">1...L.A&gt; HafiydAt (‘granddaugh ters’) is feminine plural; but the adjective, &quot;..L.._.s.&gt;J 1 AlHkwmyn (‘the-governmental’), of the feminine plural (and irrational) V&quot;.J1.... madAris (‘schools’) is feminine singular.</S>
			<S sid ="128" ssid = "59">This exceptional agreement is orthogonal to the form-function inconsistency discussed earlier.</S>
			<S sid ="129" ssid = "60">In other words, having a sound or broken plural has no bearing on whether the noun is rational or not—and hence whether an adjectival modifier should agree with it by being feminine-singular or -plural.</S>
			<S sid ="130" ssid = "61">Note also that all agreement rules, including the exceptional agreement rules, refer to functional number and gender, not to form-based number and gender.</S>
			<S sid ="131" ssid = "62">VRB J.....v tς ml ‘work’ MOD SBJ PRT u fy ‘in’ N O M&apos; &apos; . 1 . ..</S>
			<S sid ="132" ssid = "63">L . A &gt; H f y d A t ‘ g r a n d d a u g h t e r s ’ OBJ NOM V&quot;.J1...�.</S>
			<S sid ="133" ssid = "64">1 AlmdArs MOD NOM . IDF NOM ‘the-schools’ MOD &apos;-&apos; L. ..J1 AlðkyAt ‘smart’ &apos;--.</S>
			<S sid ="134" ssid = "65">.v sJ1 AlkAtb ‘the-writer ’ NOM &quot;..L.._.s.&gt;J 1 AlHkwmyn ‘the-governmental’ Figure 1 CATiB Annotation example.</S>
			<S sid ="135" ssid = "66">&quot;..L.._.s.&gt;J 1 V&quot;.J1...�.</S>
			<S sid ="136" ssid = "67">1 u. &apos;-&apos;.</S>
			<S sid ="137" ssid = "68">L. ..J1 &apos;--.</S>
			<S sid ="138" ssid = "69">.v sJ1 &apos;-&apos;.</S>
			<S sid ="139" ssid = "70">1...L.A&gt; J.....v tς ml HfydAt AlkAtb AlðkyAt fy AlmdArs AlHkwmyn (‘The writer ’s smart granddaughters work for public schools’).</S>
			<S sid ="140" ssid = "71">The words in the tree are presented in the Arabic reading direction (from right to left).</S>
			<S sid ="141" ssid = "72">166 MSA exhibits assignment relations in CASE and STAT E marking.</S>
			<S sid ="142" ssid = "73">Different types of dependents have different CASE, for example, verbal subjects are always marked NOMINATIVE (for a discussion of case in MSA, see Habash et al. [2007]).</S>
			<S sid ="143" ssid = "74">STAT E is a marker on nouns; when a noun heads an idafa construction, its STAT E is (‘construct’).</S>
			<S sid ="144" ssid = "75">CASE and STAT E are rarely explicitly manifested in undiacritized MSA.</S>
			<S sid ="145" ssid = "76">The DET feature plays an important role in distinguishing between N-N construct (idafa), in which only the last noun bears the definite article,7 and N-A (noun-adjectival modifier), in which both elements generally exhibit agreement in definiteness (and agreement in other features, too).</S>
			<S sid ="146" ssid = "77">Although only N-N may be followed by additional N elements in Idafa relation, both constructions may be followed by one or more adjectival modifiers.</S>
			<S sid ="147" ssid = "78">Lexical features do not constrain syntactic structure as inflectional features do.</S>
			<S sid ="148" ssid = "79">Instead, bilexical dependencies are used to model semantic relations that often are the only way to disambiguate among different possible syntactic structures.</S>
			<S sid ="149" ssid = "80">2.5 Corpus, CATiB Format, and the CATIB6 POS Tag Set.</S>
			<S sid ="150" ssid = "81">We use the Columbia Arabic Treebank (CATiB) (Habash and Roth 2009).</S>
			<S sid ="151" ssid = "82">Specifically, we use the portion converted from Part 3 of the PATB to the CATiB format, which enriches the CATiB dependency trees with full PATB morphological information.</S>
			<S sid ="152" ssid = "83">CATiB’s dependency representation is based on traditional Arabic grammar and emphasizes syntactic case relations.</S>
			<S sid ="153" ssid = "84">It has a reduced POS tag set consisting of six tags only (henceforth CATIB 6).</S>
			<S sid ="154" ssid = "85">The tags are: NOM (non-proper nominals including nouns, pronouns, adjectives, and adverbs), PROP (proper nouns), VRB (active-voice verbs), VRB-PASS (passive-voice verbs), PRT (particles such as prepositions or conjunctions), and PNX (punctuation).</S>
			<S sid ="155" ssid = "86">CATiB uses a standard set of eight dependency relations: SBJ and OBJ for subject and (direct or indirect) object, respectively (whether they appear pre- or post- verbally); IDF for the idafa (possessive) relation; MOD for most other modifications; and other less common relations that we will not discuss here.</S>
			<S sid ="156" ssid = "87">For other PATB-based POS tag sets, see Sections 2.6 and 2.7.</S>
			<S sid ="157" ssid = "88">The CATiB Treebank uses the word segmentation of the PATB.</S>
			<S sid ="158" ssid = "89">It splits off several categories of orthographic clitics, but not the definite article + J1 Al+ (‘the’).</S>
			<S sid ="159" ssid = "90">In all of the experiments reported in this article, we use the gold segmentation.</S>
			<S sid ="160" ssid = "91">Tokenization involves further decisions on the segmented token forms, such as spelling normalization, which we only briefly touch on here (in Section 4.1).</S>
			<S sid ="161" ssid = "92">An example CATiB dependency tree is shown in Figure 1.</S>
			<S sid ="162" ssid = "93">For the corpus statistics, see Table 1.</S>
			<S sid ="163" ssid = "94">For more information on CATiB, see Habash and Roth (2009) and Habash, Faraj, and Roth (2009).</S>
			<S sid ="164" ssid = "95">2.6 Core POS Tag Sets.</S>
			<S sid ="165" ssid = "96">Linguistically, words have associated POS tags, e.g., “verb” or “noun,” which further abstract over morphologically and syntactically similar lexemes.</S>
			<S sid ="166" ssid = "97">Traditional Arabic grammars often describe a very general three-way distinction into verbs, nominals, and particles.</S>
			<S sid ="167" ssid = "98">In comparison, the tag set of the Buckwalter Morphological Analyzer (Buckwalter 2004) used in the PATB has a core POS set of 44 tags (CORE 44) before morphological extension.8 Cross-linguistically, a core set containing around 12 tags is often 7 We ignore the rare “false idafa” construction (Habash 2010, p. 102)..</S>
			<S sid ="168" ssid = "99">8 The 44 tags in CORE 44 are based on the tokenized version of Arabic words.</S>
			<S sid ="169" ssid = "100">There are 34 untokenized core.</S>
			<S sid ="170" ssid = "101">tags as used in MADA+TOKAN (Habash, Rambow, and Roth 2012).</S>
			<S sid ="171" ssid = "102">167 assumed as a “universal tag set” (Rambow et al. 2006; Petrov, Das, and McDonald 2012).</S>
			<S sid ="172" ssid = "103">We have adapted the list from Rambow et al.</S>
			<S sid ="173" ssid = "104">(2006) for Arabic, and call it here CORE 12.</S>
			<S sid ="174" ssid = "105">It contains the following tags: verb (V), noun (N), adjective (AJ), adverb (AV), proper noun (PN), pronoun (PRO), relative pronoun (REL), preposition (P), conjunction (C), particle (PRT), abbreviation (AB), and punctuation (PNX).</S>
			<S sid ="175" ssid = "106">The CATIB 6 tag set can be viewed as a further reduction, with the exception that CATIB 6 contains a passive voice tag (a morphological feature); this tag constitutes only 0.5% of the tags in the training, however.</S>
			<S sid ="176" ssid = "107">2.7 Extended POS Tag Sets.</S>
			<S sid ="177" ssid = "108">The notion of “POS tag set” in natural language processing usually does not refer to a core set.</S>
			<S sid ="178" ssid = "109">Instead, the Penn English Treebank (PTB) uses a set of 46 tags, including not only the core POS, but also the complete set of morphological features (this tag set is still fairly small since English is morphologically impoverished).</S>
			<S sid ="179" ssid = "110">In PATBtokenized MSA, the corresponding type of tag set (core POS extended with a complete description of morphology) would contain upwards of 2,000 tags, many of which are extremely rare (in our training corpus of about 300,000 words, we encounter only 430 POS tags with complete morphology).</S>
			<S sid ="180" ssid = "111">Therefore, researchers have proposed tag sets for MSA whose size is similar to that of the English PTB tag set, as this has proven to be a useful size computationally.</S>
			<S sid ="181" ssid = "112">These tag sets are hybrids in the sense that they are neither simply the core POS, nor the complete morphologically enriched tag set, but instead they selectively enrich the core POS tag set with only certain morphological features.</S>
			<S sid ="182" ssid = "113">A more detailed discussion of the various available Arabic tag sets can be found in Habash (2010).</S>
			<S sid ="183" ssid = "114">The following are the various tag sets we use in this article: (a) the core POS tag sets CORE 44 and the newly introduced CORE 12; (b) CATiB Treebank tag set (CATIB 6) (Habash and Roth 2009) and its newly introduced extension of CATIB EX created using simple regular expressions on word form, indicating particular morphemes such as the prefix J1 Al+ or the suffix .u +wn; this tag set is the best-performing tag set for Arabic on predicted values as reported in Section 4; (c) the PATB full tag set with complete morphological tag (BW) (Buckwalter 2004); and two extensions of the PATB reduced tag set (PENN POS, a.k.a. RTS, size 24 [Diab, Hacioglu, and Jurafsky 2004]), both outperforming it: (d) Kulick, Gabbard, and Marcus (2006)’s tag set (KULICK), size 43, one of whose most important extensions is the marking of the definite article clitic, and (e) Diab and Benajiba’s (in preparation) EXTENDED RTS tag set (ERTS), which marks gender, number, and definiteness, size 134.</S>
	</SECTION>
	<SECTION title="Related Work. " number = "3">
			<S sid ="184" ssid = "1">Much work has been done on the use of morphological features for parsing of morpho- logically rich languages.</S>
			<S sid ="185" ssid = "2">Collins et al.</S>
			<S sid ="186" ssid = "3">(1999) report that an optimal tag set for parsing Czech consists of a basic POS tag plus a CASE feature (when applicable).</S>
			<S sid ="187" ssid = "4">This tag set (size 58) outperforms the basic Czech POS tag set (size 13) and the complete tag set (size ≈3000+).</S>
			<S sid ="188" ssid = "5">They also report that the use of gender, number, and person features did not yield any improvements.</S>
			<S sid ="189" ssid = "6">The results for Czech are the opposite of our results for Arabic, as we will see.</S>
			<S sid ="190" ssid = "7">This may be due to CASE tagging having a lower error rate in Czech (5.0%) (Hajicˇ and Vidová-Hladká 1998) compared with Arabic (≈14.0%, see Table 3).</S>
			<S sid ="191" ssid = "8">Similarly, Cowan and Collins (2005) report that the use of a subset of Spanish morphological features (number for adjectives, determiners, nouns, pronouns, and verbs; and mode for verbs) outperforms other combinations.</S>
			<S sid ="192" ssid = "9">Our approach is 168 comparable to their work in terms of its systematic exploration of the space of morphological features.</S>
			<S sid ="193" ssid = "10">We also find that the number feature helps for Arabic.</S>
			<S sid ="194" ssid = "11">Looking at Hebrew, a Semitic language related to Arabic, Tsarfaty and Sima’an (2007) report that extending POS and phrase structure tags with definiteness information helps unlexicalized PCFG parsing.</S>
			<S sid ="195" ssid = "12">As for work on Arabic (MSA), results have been reported on the PATB (Kulick, Gabbard, and Marcus 2006; Diab 2007; Green and Manning 2010), the Prague Dependency Treebank (PADT) (Buchholz and Marsi 2006; Nivre 2008) and the CATiB (Habash and Roth 2009).</S>
			<S sid ="196" ssid = "13">Recently, Green and Manning (2010) analyzed the PATB for annotation consistency, and introduced an enhanced split-state constituency grammar, including labels for short idafa constructions and verbal or equational clauses.</S>
			<S sid ="197" ssid = "14">Nivre (2008) reports experiments on Arabic parsing using his MaltParser (Nivre et al. 2007), trained on the PADT.</S>
			<S sid ="198" ssid = "15">His results are not directly comparable to ours because of the different treebank representations, even though all the experiments reported here were performed using the MaltParser.</S>
			<S sid ="199" ssid = "16">Our results agree with previous work on Arabic and Hebrew in that marking the definite article is helpful for parsing.</S>
			<S sid ="200" ssid = "17">We go beyond previous work, however, and explore additional lexical and inflectional features.</S>
			<S sid ="201" ssid = "18">Previous work with MaltParser in Russian, Turkish, and Hindi showed gains with CASE but not with agreement features (Eryigit, Nivre, and Oflazer 2008; Nivre, Boguslavsky, and Iomdin 2008; Nivre 2009).</S>
			<S sid ="202" ssid = "19">Our work is the first to show gains using agreement in MaltParser and in Arabic dependency parsing, and the first to use functional features for this task.</S>
			<S sid ="203" ssid = "20">Furthermore, we demonstrate that our results carry over successfully to another parser, the Easy-First Parser (Goldberg and Elhadad 2010) (Section 6).</S>
			<S sid ="204" ssid = "21">Hohensee and Bender (2012) have conducted a study on dependency parsing for 21 languages using features that encode whether the values for certain attributes are equal or not for a node and its governor.</S>
			<S sid ="205" ssid = "22">These features are potentially powerful, because they generalize to the very notion of agreement, away from the specific values of the attributes on which agreement occurs.9 We expect this kind of feature to yield lower gains for Arabic, unless: • one uses functional feature values (such as those used here for the first time in Arabic NLP), • one uses yet another representation level to account for the otherwise non-identity agreement patterns of irrational plurals, • one handles the loss of overt number agreement in constructions such as VS (where the verb precedes its subject), and • one adequately represents the otherwise “inverse” number agreement (a phenomenon common to other Semitic languages, such as Hebrew, too).</S>
	</SECTION>
	<SECTION title="Basic Parsing Experiments. " number = "4">
			<S sid ="206" ssid = "1">We examined a large space of settings.</S>
			<S sid ="207" ssid = "2">In all our experiments, we contrasted the results obtained using machine-predicted input with the results obtained using gold input (the 9 We do not relate to specific results in their study because it has been brought to our attention that.</S>
			<S sid ="208" ssid = "3">Hohensee and Bender (2012) are in the process of rechecking their code for errors, and rerunning their experiments (personal communication).</S>
			<S sid ="209" ssid = "4">169 upper bound for using these features).</S>
			<S sid ="210" ssid = "5">We started by looking at individual features (including POS tag sets) and their prediction accuracy.</S>
			<S sid ="211" ssid = "6">We then explored various feature combinations in a hill-climbing fashion.</S>
			<S sid ="212" ssid = "7">We examined these issues in the following order: 1.</S>
			<S sid ="213" ssid = "8">the contribution of POS tag sets to the parsing quality, as a function of the amount of information encoded in the tag set, using (a) gold input, and (b) machine- predicted POS tags; 2.</S>
			<S sid ="214" ssid = "9">the contribution of numerous inflectional features in a controlled fashion, using (c) gold input and (d) machine-predicted input; (e) the prediction accuracy of each inflectional feature; 3.</S>
			<S sid ="215" ssid = "10">the contribution of the lexical features in a similar fashion, again using (f) gold input and (g) predicted input; (h) the prediction accuracy of each lexical feature; 4.</S>
			<S sid ="216" ssid = "11">(i) certain feature combinations and (j) the embedding of the best combination in the POS tag set; and 5.</S>
			<S sid ="217" ssid = "12">(k) further feature engineering of select useful features.</S>
			<S sid ="218" ssid = "13">In Section 5 we explore using functional (instead of form-based) feature values.</S>
			<S sid ="219" ssid = "14">In Section 6 we repeat key experiments with another parser, illustrating the robustness of our findings across these frameworks.</S>
			<S sid ="220" ssid = "15">In Section 7 we explore alternative training methods, and their impact on key models.</S>
			<S sid ="221" ssid = "16">All results are reported mainly in terms of labeled attachment accuracy score (the parent word and the type of dependency relation to it, abbreviated as LAS), which is also used for greedy (hill-climbing) decisions for feature combination.</S>
			<S sid ="222" ssid = "17">Unlabeled attachment accuracy score (UAS) and label accuracy (dependency relation regardless of parent, LS) are also given.</S>
			<S sid ="223" ssid = "18">For statistical significance, we use McNemar ’s test on non-gold LAS, as implemented by Nilsson and Nivre (2008).</S>
			<S sid ="224" ssid = "19">We denote p &lt; 0.05 and p &lt; 0.01 with + and ++, respectively.</S>
			<S sid ="225" ssid = "20">4.1 Data Sets and Parser.</S>
			<S sid ="226" ssid = "21">For all the experiments reported in this article, we used the training portion of PATB Part 3 v3.1 (Maamouri et al. 2004), converted to the CATiB Treebank format, as mentioned in Section 2.5.</S>
			<S sid ="227" ssid = "22">We used the same training / devtest split as in Zitouni, Sorensen, and Sarikaya (2006); and we further split the devtest into two equal parts: a development (dev) set and a blind test set.</S>
			<S sid ="228" ssid = "23">For all experiments, unless specified otherwise, we used the dev set.10 We kept the test unseen (“blind”) during training and model development.</S>
			<S sid ="229" ssid = "24">Statistics about this split (after conversion to the CATiB dependency format) are given in Table 1.</S>
			<S sid ="230" ssid = "25">For all experiments reported in this section we used the syntactic dependency parser MaltParser v1.3 (Nivre 2003, 2008; Kübler, McDonald, and Nivre 2009), a transition-based parser with an input buffer and a stack, which uses SVM classifiers 10 We use the term “dev set” to denote a non-blind test set, used for model development (feature selection.</S>
			<S sid ="231" ssid = "26">and feature engineering).</S>
			<S sid ="232" ssid = "27">We do not perform further weight optimization (which, if done, is done on a separate “tuning set”).</S>
			<S sid ="233" ssid = "28">170 Table 1 Penn Arabic Treebank part 3 v3.1 data split.</S>
			<S sid ="234" ssid = "29">spli t # tok ens # sen ten ces sen ten ce len gth (a vg.</S>
			<S sid ="235" ssid = "30"># to ke ns ) trai nin g 34 1,0 94 1 1 , 4 7 6 2 9 . 7 dev 3 1, 2 0 8 1 , 0 4 3 2 9 . 9 uns een test 2 9, 9 4 4 1 , 0 0 7 2 9 . 7 TO TA L 40 2,2 46 1 3 , 5 2 6 2 9 . 7 to predict the next state in the parse derivation.</S>
			<S sid ="236" ssid = "31">All experiments were done using the Nivre “eager ” algorithm.11 There are five default attributes in the MaltParser terminology for each token in the text: word ID (ordinal position in the sentence), word-form, POS tag, head (parent word ID), and deprel (the dependency relation between the current word and its parent).</S>
			<S sid ="237" ssid = "32">There are default MaltParser features (in the machine learning sense),12 which are the values of functions over these attributes, serving as input to the MaltParser internal classifiers.</S>
			<S sid ="238" ssid = "33">The most commonly used feature functions are the top of the input buffer (next word to process, denoted buf[0]), or top of the stack (denoted stk[0]); following items on buffer or stack are also accessible (buf[1], buf[2], stk[1], etc.).</S>
			<S sid ="239" ssid = "34">Hence MaltParser features are defined as POS tag at stk[0], word-form at buf[0], and so on.</S>
			<S sid ="240" ssid = "35">Kübler, McDonald, and Nivre (2009) describe a “typical” MaltParser model configuration of attributes and features.13 Starting with it, in a series of initial controlled experiments, we settled on using buf[01] + stk[01] for word-forms, and buf[03] + stk[02] for POS tags.</S>
			<S sid ="241" ssid = "36">For features of new MaltParser-attributes (discussed later), we used buf[0] + stk[0].</S>
			<S sid ="242" ssid = "37">We did not change the features for deprel: stk[0], ldep(stk[0]), rdep(stk[0]), ldep(buf[0]), rdep(buf[0]) (where ldep and rdep are the left and right, respectively, dependents of the specified argument).</S>
			<S sid ="243" ssid = "38">This new MaltParser configuration resulted in gains of 0.3–1.1% in labeled attachment accuracy (depending on the POS tag set) over the default MaltParser configuration.</S>
			<S sid ="244" ssid = "39">We also experimented with using normalized word-forms (Alif Maqsura conversion to Ya, and Hamza removal from each Alif ) as is common in parsing and statistical machine translation literature, but it resulted in a small decrease in performance, so we settled on using non-normalized word-forms.</S>
			<S sid ="245" ssid = "40">All experiments reported here were conducted using this new configuration.</S>
			<S sid ="246" ssid = "41">To recap, it has the following MaltParser attributes (machine learning features): 4 word-form attributes, 7 POS tag attributes, and 5 deprel attributes (some of which are not useful for the Nivre.</S>
			<S sid ="247" ssid = "42">“eager ” algorithm), totaling 16 attributes and two more for every new feature described in Section 4.3 and on (e.g., CASE).</S>
			<S sid ="248" ssid = "43">11 Nivre (2008) reports that non-projective and pseudo-projective algorithms outperform the “eager ”.</S>
			<S sid ="249" ssid = "44">projective algorithm in MaltParser, but our training data did not contain any non-projective dependencies.</S>
			<S sid ="250" ssid = "45">The Nivre “standard” algorithm is also reported there to do better on Arabic, but in a preliminary experimentation, it did slightly worse than the “eager ” one, perhaps due to the high percentage of right branching (left headed structures) in our Arabic training set—an observation already noted in Nivre (2008).</S>
			<S sid ="251" ssid = "46">12 The terms feature and attribute are overloaded in the literature.</S>
			<S sid ="252" ssid = "47">We use them in the linguistic sense, unless.</S>
			<S sid ="253" ssid = "48">specifically noted otherwise, e.g., MaltParser feature(s).</S>
			<S sid ="254" ssid = "49">13 It is slightly different from the default configuration..</S>
			<S sid ="255" ssid = "50">171 Table 2 Parsing performance with each POS tag set, on gold and predicted input.</S>
			<S sid ="256" ssid = "51">LAS = labeled attachment accuracy (dependency + relation).</S>
			<S sid ="257" ssid = "52">UAS = unlabeled attachment accuracy (dependency only).</S>
			<S sid ="258" ssid = "53">LS = relation label prediction accuracy.</S>
			<S sid ="259" ssid = "54">LAS diff = difference between labeled attachment accuracy on gold and predicted input.</S>
			<S sid ="260" ssid = "55">POS acc = POS tag prediction accuracy.</S>
			<S sid ="261" ssid = "56">AS UAS S AS UAS S acc.</S>
			<S sid ="262" ssid = "57">size 4.2 The Effect of POS Tag Richness on Parsing Quality.</S>
			<S sid ="263" ssid = "58">In this section, we compare the effect on parsing quality of a number of POS tag sets varying in their richness, in both gold and predicted settings.</S>
			<S sid ="264" ssid = "59">Gold POS tag values.</S>
			<S sid ="265" ssid = "60">We turn first to the contribution of POS information to parsing quality, as a function of the amount of information encoded in the POS tag set (i.e., the relevance of a tag set).</S>
			<S sid ="266" ssid = "61">A first rough estimation for the amount of information is the actual tag set size, as it appears in the training data.</S>
			<S sid ="267" ssid = "62">For this purpose we compared the POS tag sets discussed in sections 2.6 and 2.7.</S>
			<S sid ="268" ssid = "63">In optimal conditions (using gold POS tags), the richest tag set (BW) is indeed the best performer (84.0%), and the poorest (CATIB 6) is the worst (81.0%).</S>
			<S sid ="269" ssid = "64">Mid-size tag sets are in the high (82%), with the notable exception of KULICK, which does better than ERTS, in spite of having one fourth the tag set size; moreover, it is the best performer in unlabeled attachment accuracy (86.0%), in spite of being less than tenth the size of BW.</S>
			<S sid ="270" ssid = "65">Our extended mid-size tag set, CATIB EX, was a mid-level performer as expected.</S>
			<S sid ="271" ssid = "66">Columns 2–4 in Table 2 show results with gold input, and the rightmost column shows the number of tag types actually occurring in the training data.</S>
			<S sid ="272" ssid = "67">Predicted POS tag values.</S>
			<S sid ="273" ssid = "68">So far we discussed optimal (gold) conditions.</S>
			<S sid ="274" ssid = "69">But in practice, POS tags are annotated by automatic taggers, so parsers get predicted POS tags as input, as opposed to gold (human-annotated) tags.14 The more informative the tag set, the less accurate the tag prediction might be, so the effect on overall parsing quality is unclear.</S>
			<S sid ="275" ssid = "70">Put differently, we are interested in the tradeoff between relevance and accuracy.</S>
			<S sid ="276" ssid = "71">Therefore, we repeated the experiments with POS tags predicted by the MADA toolkit (Habash and Rambow 2005; Habash, Rambow, and Roth 2012)15 (see Table 2, 14 Some parsers predict POS tags internally, instead of receiving them as input, but this is not the case in this.</S>
			<S sid ="277" ssid = "72">article.</S>
			<S sid ="278" ssid = "73">15 We use MADA v3.1 in all of our experiments.</S>
			<S sid ="279" ssid = "74">We note that MADA v3.1 was tuned on the same.</S>
			<S sid ="280" ssid = "75">development set that we use for making our parsing model choices; ideally, we would have chosen a different development set for our work on parsing, but we thought it would be best to use MADA as a black box component (for past and future comparability), and did not have sufficient data to carve out from a second development set (while retaining a test set).</S>
			<S sid ="281" ssid = "76">We do not take this as a major concern for our results.</S>
			<S sid ="282" ssid = "77">In fact, although MADA was tuned to maximize its core POS accuracy (the untokenized version of CORE 44), CORE 44 did not yield best parsing quality on MADA-predicted input (see Table 2).</S>
			<S sid ="283" ssid = "78">172 columns 5–7).</S>
			<S sid ="284" ssid = "79">It turned out that BW, the best gold performer but with lowest POS prediction accuracy (81.8%), suffered the biggest drop (11.4%) and was the worst performer with predicted tags.</S>
			<S sid ="285" ssid = "80">The simplest tag set, CATIB 6, and its extension, CATIB EX, benefited from the highest POS prediction accuracy (97.7%), and their performance suffered the least.</S>
			<S sid ="286" ssid = "81">CAT IB EX was the best performer with predicted POS tags.</S>
			<S sid ="287" ssid = "82">Performance drop and POS prediction accuracy are given in columns 8 and 9.</S>
			<S sid ="288" ssid = "83">These results suggest that POS tag set accuracy is as important to parsing quality, if not more important, than its relevance.</S>
			<S sid ="289" ssid = "84">In other words, when designing a parsing model, one might want to consider that in the tradeoff, mediocre accuracy may be worse than mediocre relevance.</S>
			<S sid ="290" ssid = "85">Later we see a similar trend for other features as well (e.g., CASE in Section 4.3).</S>
			<S sid ="291" ssid = "86">In Section 7 we also present a training method that largely mitigates (but doesn’t resolve) this issue of mediocre accuracy of relevant features.</S>
			<S sid ="292" ssid = "87">4.3 Inflectional Features and Their Contribution to Parsing Quality.</S>
			<S sid ="293" ssid = "88">Experimenting with inflectional features is especially important in Arabic parsing, as it is morphologically rich.</S>
			<S sid ="294" ssid = "89">In order to explore the contribution of inflectional and lexical information in a controlled manner, we focused on the best performing core (“morphology-free”) POS tag set, CORE 12, as baseline; using three different setups, we added nine inflectional features (with either gold values, or with values predicted by MADA): DET (presence of determiner), PERSON, ASPECT, VOICE , MOOD, GENDER, NUMBER, STAT E, and CASE.</S>
			<S sid ="295" ssid = "90">For a brief reminder and examples for each feature, see the rightmost column in Table 3, or for more details refer back to Section 2.</S>
			<S sid ="296" ssid = "91">In setup All, we augmented the baseline model with all nine features (as nine additional MaltParser attributes); in setup Sep, we augmented the baseline model with each of these features, one at a time, separately; and in setup Greedy, we combined them in a greedy heuristic (since the entire feature space is too vast to exhaust): starting with the most gainful feature from Sep, adding the next most gainful feature, keeping it if it helped, or discarding it otherwise, and repeating this heuristics through the least gainful feature.</S>
			<S sid ="297" ssid = "92">See Table 4.</S>
			<S sid ="298" ssid = "93">Gold feature values.</S>
			<S sid ="299" ssid = "94">We applied the three setups (All, Sep, and Greedy ) with gold POS tags and gold morphological tags, to examine the contribution of the morphological features in optimal conditions.</S>
			<S sid ="300" ssid = "95">The top left section of Table 4 shows that applying all inflectional features together yields gains over the baseline.</S>
			<S sid ="301" ssid = "96">Examining the contribution of each feature separately (second top left Sep section), we see that CASE, followed by STAT E and DET, were the top contributors.</S>
			<S sid ="302" ssid = "97">Performance of CASE is the notable difference from the predicted conditions (see following discussion).</S>
			<S sid ="303" ssid = "98">No single feature outperformed the All setup in gold.</S>
			<S sid ="304" ssid = "99">Surprisingly, only CASE and STAT E helped in the Greedy setup (85.4%, our highest result in gold), although one might expect feature DET to have helped, too (since it is highly relevant: It participates in agreement, and interacts with the idafa construction).</S>
			<S sid ="305" ssid = "100">This shows that there is redundancy in the information provided by DET on the one hand and CASE and STAT E on the other, presumably because both sets of feature help identify the same construction, idafa.</S>
			<S sid ="306" ssid = "101">Predicted feature values.</S>
			<S sid ="307" ssid = "102">We reapplied the three setups with predicted feature values (right-hand side half of Table 4).</S>
			<S sid ="308" ssid = "103">Setup All hurts performance on the machine-predicted input.</S>
			<S sid ="309" ssid = "104">This can be explained if one examines the prediction accuracy of each feature (top half, third section of Table 3).</S>
			<S sid ="310" ssid = "105">Features which are not predicted with very high accuracy, such as CASE (86.3%), can dominate the negative contribution, even though they are 173 Table 3 Prediction accuracy, value set sizes, descriptions, and value examples of features used in this work.</S>
			<S sid ="311" ssid = "106">Accuracy was measured over the development set.</S>
			<S sid ="312" ssid = "107">* = The set includes a “N/A” value(s).</S>
			<S sid ="313" ssid = "108">feature acc.</S>
			<S sid ="314" ssid = "109">set size comments and examples normalized word-form non-normalized word-form LEMMA (diacritized) 99.3 29,737 collapse certain spelling variations into a single representation, e.g., uJ1 A¯ ly (‘ au to m ati c’ ) an d uJ1 Aˇ lý (‘t o’) ar e co lla ps ed int o uJ1 Al y 98.9 29,980 ‘raw’ input (except for PATB segmentation), e.g., the uncollapsed forms ab ov e 96.7 16,837 abstraction over inflected forms, e.g., the lemma of &apos;- . .v s..</S>
			<S sid ="315" ssid = "110">makAtib (‘offices’) is &apos;--.</S>
			<S sid ="316" ssid = "111">.L.s. . m akt ab (‘o ffi ce ’) LMM 98.3 15,305 undiacritized lemma (lemma with vowels and other diacritics removed), e.g., &apos;--.</S>
			<S sid ="317" ssid = "112">.L.s..</S>
			<S sid ="318" ssid = "113">mktb for the example above.</S>
			<S sid ="319" ssid = "114">ROOT 98.4 9,646 further abstraction over inflection and patterns; typically a consonant triplet, a.k.a. radicals, e.g., &apos;-&apos;.</S>
			<S sid ="320" ssid = "115">� ktb (‘writing-related’) e.g., ma12a3 (‘location-related’); typically a derivational modification to the basic meaning of the root, such as a location or instrument, but inflectional variations such as aspect, voice, number and gender also exist; we use the pattern of the lemma, not the inflected form, which may differ in cases such as broken plurals DET 99.6 3* presence of the determiner morpheme J1 Al PERSON 99.1 4* first, second, or third person (or N/A) ASPECT 99.1 5* perfective, imperfective and imperative for verbs (or N/A) VOICE 98.9 4* active or passive voice for verbs (or N/A) MOOD 98.6 5* indicative, subjunctive, jussive for verbs (or N/A) GENDER 99.3 3* (form-based) masculine or feminine (or N/A) NUMBER 99.5 4* (form-based) singular, dual, or plural (or N/A) STAT E 95.6 4* construct (head of idafa), definite, or indefinite (or N/A) CASE 86.3 5* nominative, accusative or genitive (or N/A) NUM DGT 99.5 7* a NUMBER feature with digit token representation; see Section A.3 NUM DGT BIN 99.5 12* a NUMBER feature with number ‘binning’ according to syntactic agreement patterns; see Section A.3 FN NUM 99.2 6* a functional NUMBER feature, using ElixirFM; see Section 5.1 FN NUM DGT 99.2 7* a functional NUMBER feature with digit token representation, using ElixirFM; see Sections 5.1 and A.3 FN NUM DGT BIN 99.2 12* a functional NUMBER feature with number ‘binning’ according to syntactic agreement patterns, using ElixirFM; see Sections 5.1 and A.3 FN *GENDER 98.6 6* a functional GENDER feature, using our in-house resource; see Section 5.2 FN *NUM 99.0 7* a functional NUMBER feature, using our in-house resource; see Section 5.2 FN *NUM DGT BIN 99.0 13* a functional NUMBER feature with number ‘binning’ according to syntactic agreement patterns, using our in-house resource; see Sections 5.2 and A.3 RAT 95.6 5* rationality (humanness) feature; rational, irrational, ambiguous, unknown or N/A; using our in-house resource; see Section 5.2 PNG – – abbrev.</S>
			<S sid ="321" ssid = "116">for PERSON , NUMBER , and GENDER (a.k.a. φ-features); similarly for PG FN *NGR – – abbrev.</S>
			<S sid ="322" ssid = "117">for functional NUMBER , GENDER, and RAT; similarly for FN *NG top contributors, that is, highly relevant, in optimal (gold) conditions (see previous paragraph).</S>
			<S sid ="323" ssid = "118">The determiner feature (DET), followed by the STAT E feature, were top individual contributors in setup Sep. Adding the features that participate in agreement, namely, DET and the PNG features (PERSON, NUMBER, GENDER), in the Greedy setup, yielded a 1.4% gain over the CORE 12 baseline.</S>
			<S sid ="324" ssid = "119">These results suggest that for a successful feature combination, one should take into account not only the relevance of the features, but also their accuracy.</S>
			<S sid ="325" ssid = "120">174 Table 4 CORE 12 POS tag set with morphological inflectional features.</S>
			<S sid ="326" ssid = "121">Left half: Using gold POS tag and feature values.</S>
			<S sid ="327" ssid = "122">In it: Top part (All ): Adding all nine inflectional features to CORE 12.</S>
			<S sid ="328" ssid = "123">Second part (Sep ): Adding each feature separately to CORE 12.</S>
			<S sid ="329" ssid = "124">Third part (Greedy ): Greedily adding next best feature from Sep, and keeping it if improving score.</S>
			<S sid ="330" ssid = "125">Right half: Same as left half, but with predicted POS tag and feature values.</S>
			<S sid ="331" ssid = "126">Statistical significance tested only on predicted (non-gold) input, against the CORE 12 baseline.</S>
			<S sid ="332" ssid = "127">g o l d P O S a n d f e a t u r e v a l u e s p r e d i c t e d P O S a n d f e a t u r e v a l u e sSet up CORE 12+...</S>
			<S sid ="333" ssid = "128">LAS UAS LS C O R E 1 2 + . . .</S>
			<S sid ="334" ssid = "129">L A S U A S L S ( b a s e l i n e r e p e a t e d ) 8 2 . 9 8 5 . 4 9 3 . 5 + a l l 9 i n f l . f e a t u r e s 8 5 . 2 8 6 . 6 9 5 . 3 + C A S E 8 4 . 6 8 6 . 3 9 5 . 0 + S T A T E 8 4 . 2 8 6 . 4 9 4 . 4 + D E T 8 4 . 0 8 6 . 2 9 4 . 2 + N U M B E R 8 3 . 1 8 5 . 5 9 3 . 6 + P E R S O N 8 3 . 1 8 5 . 4 9 3 . 7 + V O I C E 8 3 . 1 8 5 . 4 9 3 . 6 + M O O D 8 3 . 1 8 5 . 5 9 3 . 5 + A S P E C T 8 3 . 0 8 5 . 4 9 3 . 5 + G E N D E R 8 3 . 0 8 5 . 2 9 3 . 6 + C A S E + S T A T E 8 5 . 4 8 6 . 9 9 5 . 5 + C A S E + S T A T E + D E T 8 5 . 2 8 6 . 7 9 5 . 4 + C A S E + S T A T E + N U M B E R 8 5 . 4 8 6 . 9 9 5 . 5 + C A S E + S T A T E + P E R S O N 8 5 . 3 8 6 . 8 9 5 . 4 + C A S E + S T A T E + V O I C E 8 5 . 3 8 6 . 8 9 5 . 4 + C A S E + S T A T E + M O O D 8 5 . 2 8 6 . 7 9 5 . 4 + C A S E + S T A T E + A S P E C T 8 5 . 2 8 6 . 8 9 5 . 4 + C A S E + S T A T E + G E N D E R 8 5 . 3 8 6 . 8 9 5 . 4 (bas elin e rep eat ed) 78.7 82.5 90.6 + all 9 infl.</S>
			<S sid ="335" ssid = "130">feat ure s 77.9 82.1 90.0 +D ET 79.8++ 83.2 91.5 +ST AT E 79.4++ 82.9 91.2 +G EN DE R 78.8 82.4 90.8 +P ERS ON 78.7 82.5 90.7 +N UM BER 78.7 82.4 90.6 +V OIC E 78.6 82.4 90.6 +A SPE CT 78.6 82.4 90.5 +M OO D 78.5 82.4 90.5 +C ASE 75.8 80.2 88.5 +D ET +ST AT E 79.4++ 82.8 91.2 +D ET +G EN DE R 79.9++ 83.2 91.7 +D ET +G EN DE R +P ERS ON 79.9++ 83.2 91.7 +D ET +P NG 80.1++ 83.3 91.8 +D ET +P NG +V OIC E 80.0++ 83.2 91.7 +D ET +P NG +A SPE CT 80.0++ 83.2 91.8 +D ET +P NG +M OO D 80.0++ 83.2 91.8 — 4.4 Lexical Features and Their Contribution to Parsing Quality.</S>
			<S sid ="336" ssid = "131">Next, we experimented with adding the lexical features, which involve semantic abstraction to some degree: the diacritized LEMMA, the undiacritized lemma (LMM), the ROOT, and the PATTERN (which is the pattern of the LEMMA).</S>
			<S sid ="337" ssid = "132">A notable advantage of lexical abstraction is that it reduces data sparseness, and explicitly ties together semantically related words.</S>
			<S sid ="338" ssid = "133">We experimented with the same setups as above: All, Sep, and Greedy.</S>
			<S sid ="339" ssid = "134">Gold feature values.</S>
			<S sid ="340" ssid = "135">The left-hand side half of Table 5 shows that adding all four features yielded gains similar to adding a lemma feature separately.</S>
			<S sid ="341" ssid = "136">With gold tags, however, no proper subset of the lexical features beats the set of all lexical features.</S>
			<S sid ="342" ssid = "137">Predicted feature values.</S>
			<S sid ="343" ssid = "138">The right-hand side of Table 5 shows that adding all four features yielded a minor gain in setup All.</S>
			<S sid ="344" ssid = "139">LMM was the best single contributor, closely followed by ROOT in Sep. CORE 12+LMM+ROOT (with or without LEMMA) was the best greedy combination in setup Greedy, and also provides the best performance of all experiments with lexical features only.</S>
			<S sid ="345" ssid = "140">Due to the high redundancy of LEMMA and LMM (only 0.01% absolute gain when adding LEMMA in the Greedy setup, which appears larger only due to rounding in the table), we do not consider LEMMA in feature combinations from this point on.</S>
			<S sid ="346" ssid = "141">Note, however, that LEMMA—and all the lexical features—are predicted with high accuracy (top half, second section of Table 3).</S>
			<S sid ="347" ssid = "142">175 Table 5 Models with lexical morpho-semantic features.</S>
			<S sid ="348" ssid = "143">Top: Adding all lexical features together on top of the CORE 12 baseline.</S>
			<S sid ="349" ssid = "144">Center: Adding each feature separately.</S>
			<S sid ="350" ssid = "145">Bottom: Greedily adding best features from previous part, on predicted input.</S>
			<S sid ="351" ssid = "146">Statistical significance tested only on predicted (non-gold) input, against the CORE 12 baseline.</S>
			<S sid ="352" ssid = "147">setup CORE 12+... gold predicted LAS UAS LS LAS UAS LS CORE 12 (baseline repeated) 82.9 85.4 93.5 78.7 82.5 90.6 + all lexical features 83.4 85.5 93.9 78.9 82.5 90.8 +LMM (lemma without diacritics) 83.3 85.5 93.8 79.0+ 82.5 90.8 +ROOT 83.2 85.5 93.7 78.9+ 82.6 90.7 +LEMMA 83.4 85.5 93.8 78.8 82.4 90.7 +PATTERN 83.1 85.5 93.6 78.6 82.4 90.6 +L MM +R OOT 8 3 . 3 85 .5 93.</S>
			<S sid ="353" ssid = "148">9 79.</S>
			<S sid ="354" ssid = "149">0+ + 82.</S>
			<S sid ="355" ssid = "150">6 90.</S>
			<S sid ="356" ssid = "151">9 +L MM +R OOT +LE MM A 8 3 . 3 85 .4 93.</S>
			<S sid ="357" ssid = "152">8 79.</S>
			<S sid ="358" ssid = "153">1+ + 82.</S>
			<S sid ="359" ssid = "154">6 90.</S>
			<S sid ="360" ssid = "155">9 +L MM +R OOT +PA TTE RN 8 3 . 4 85 .5 93.</S>
			<S sid ="361" ssid = "156">9 78.</S>
			<S sid ="362" ssid = "157">9 82.6 90.</S>
			<S sid ="363" ssid = "158">8 4.5 Inflectional and Lexical Feature Combination and Its Contribution to.</S>
			<S sid ="364" ssid = "159">Parsing Quality We now combine morphological and lexical features.</S>
			<S sid ="365" ssid = "160">Following the same greedy heuristic as in the previous sections, we augmented the best inflection-based model CORE 12+DET +PNG with lexical features, and found that the undiacritized lemma (LMM) improved performance on predicted input (80.2%) (see Table 6).</S>
			<S sid ="366" ssid = "161">Adding more lexical features does not help, however, suggesting that some of the information in the lexical features is redundant with the information in the morphological features.</S>
			<S sid ="367" ssid = "162">See the Appendix, Section A.1, for our attempt to extend the tag set by embedding the best feature combination in it.</S>
			<S sid ="368" ssid = "163">4.6 Additional Feature Engineering.</S>
			<S sid ="369" ssid = "164">So far we have experimented with morphological feature values as extracted from the PATB (gold) or predicted by MADA; we also used the same MaltParser feature configuration for all added features (i.e., stk[0] + buf[0]).</S>
			<S sid ="370" ssid = "165">It is likely, however, that from a machine-learning perspective, representing similar categories with the same tag, or Table 6 Models with inflectional and lexical morphological features together (predicted value-guided heuristic).</S>
			<S sid ="371" ssid = "166">Statistical significance tested only on predicted input, against the CORE 12 baseline.</S>
			<S sid ="372" ssid = "167">tag set g o l d p r e d i c t e d L A S U A S L S L A S U A S L S CORE 12+DET +PNG (rep.) 84.2 CORE 12+DET +PNG +LMM 84.4 CORE 12+DET +PNG +LMM +ROOT 84.3 CORE 12+DET +PNG +LMM +PATTERN 84.4 86.2 94.5 80.1++ 83.3 91.8 86.4 94.6 80.2++ 83.3 91.9 86.3 94.6 80.1++ 83.3 91.8 86.3 94.6 80.0++ 83.2 91.8 176 Table 7 Models with re-engineered DET and PERSON inflectional features.</S>
			<S sid ="373" ssid = "168">Statistical significance tested only on predicted input, against the CORE 12 baseline.</S>
			<S sid ="374" ssid = "169">mod el (PO S tag set and infl.</S>
			<S sid ="375" ssid = "170">feat ure) g L A S old UA S LS p r e L AS dicte d UA S LS COR E 12+ DET (rep eate d) 8 4.</S>
			<S sid ="376" ssid = "171">0 86.</S>
			<S sid ="377" ssid = "172">2 94.</S>
			<S sid ="378" ssid = "173">2 79.</S>
			<S sid ="379" ssid = "174">8+ + 83.</S>
			<S sid ="380" ssid = "175">2 91.</S>
			<S sid ="381" ssid = "176">5 COR E 12+ DET 2 8 4.</S>
			<S sid ="382" ssid = "177">1 86.</S>
			<S sid ="383" ssid = "178">4 94.</S>
			<S sid ="384" ssid = "179">3 80.</S>
			<S sid ="385" ssid = "180">1+ + 83.</S>
			<S sid ="386" ssid = "181">5 91.</S>
			<S sid ="387" ssid = "182">7 COR E 12+ DET +PN G +LM M (rep eate d) 8 4.</S>
			<S sid ="388" ssid = "183">4 86.</S>
			<S sid ="389" ssid = "184">4 94.</S>
			<S sid ="390" ssid = "185">6 80.</S>
			<S sid ="391" ssid = "186">2+ + 83.</S>
			<S sid ="392" ssid = "187">3 91.</S>
			<S sid ="393" ssid = "188">9 COR E 12+ DET 2+P NG +L MM 8 4.</S>
			<S sid ="394" ssid = "189">6 86.</S>
			<S sid ="395" ssid = "190">5 94.</S>
			<S sid ="396" ssid = "191">7 80.</S>
			<S sid ="397" ssid = "192">2+ + 83.</S>
			<S sid ="398" ssid = "193">4 91.</S>
			<S sid ="399" ssid = "194">9 taking into account further-away tokens in the sentence, may be useful for learning.</S>
			<S sid ="400" ssid = "195">Therefore, we next experimented with modifying some inflectional features that proved most useful in predicted input.</S>
			<S sid ="401" ssid = "196">As DET may help disambiguate N-N / N-A constructions (and N-N-N, N-A-A, ..., see Section 2), we attempted modeling the DET values of previous and next elements (as MaltParser ’s stk[1] + buf[1], in addition to the modeled stk[0] + buf[0]).</S>
			<S sid ="402" ssid = "197">This variant, denoted DET 2, indeed helps: When added to the CORE 12 baseline model, DET 2 improves non-gold parsing quality by more than 0.3%, compared to DET, as shown in Table 7.</S>
			<S sid ="403" ssid = "198">This variant yields a small improvement also when used in combination with the PNG and LMM features, as shown in the second part of Table 7—but only in gold.</S>
			<S sid ="404" ssid = "199">These results suggest an intricate interaction between the extended relevance of the determiner feature, and its redundancy with the PNG features (and note that all features involved are predicted with high accuracy).</S>
			<S sid ="405" ssid = "200">A possible explanation might be that form-based feature representation is inherently inadequate here, and therefore its high accuracy may not be very indicative.</S>
			<S sid ="406" ssid = "201">We explore non-form-based (functional) feature representation in Section 5.</S>
			<S sid ="407" ssid = "202">For more on our feature engineering, see the Appendix, Section A.2.</S>
	</SECTION>
	<SECTION title="Parsing Experiments with Functional Features. " number = "5">
			<S sid ="408" ssid = "1">Section 4 explored the contribution of various POS tag sets, (form-based) morphological features, and promising combinations thereof, to Arabic dependency parsing quality— in straightforward feature engineering design and combination heuristics.</S>
			<S sid ="409" ssid = "2">This section explores more sophisticated feature engineering: using functional NUMBER and GENDER feature values, instead of form-based values; using the non-form-based rationality (RAT) feature; and combinations thereof.</S>
			<S sid ="410" ssid = "3">For additional experiments regarding alternative representation for digit tokens, and the “binning” Arabic number constructions according to their complex syntactic patterns, see the Appendix, Section A.3.</S>
			<S sid ="411" ssid = "4">5.1 Functional Feature Representation for Broken Plurals (using ElixirFM).</S>
			<S sid ="412" ssid = "5">The NUMBER feature we have thus far extracted from PATB with MADA only reflects form-based (as opposed to functional) values, namely, broken plurals are marked as singular.</S>
			<S sid ="413" ssid = "6">This might have a negative effect for learning generalizations over the complex agreement patterns in MSA, beyond memorization of word pairs seen together in 177 training.</S>
			<S sid ="414" ssid = "7">To address this issue, one can use the Arabic morphological tool ElixirFM16 (Smrž 2007).</S>
			<S sid ="415" ssid = "8">For each given word form, it outputs a list of possible analyses, each containing a lemma and a functional NUMBER (and other features).</S>
			<S sid ="416" ssid = "9">We replaced the surface NUMBER value for all nominals marked as singular in our data with ElixirFM’s functional value, using the MADA-predicted lemma to disambiguate multiple ElixirFM analyses.</S>
			<S sid ="417" ssid = "10">These experiments are denoted with FNNUM.</S>
			<S sid ="418" ssid = "11">In training, of the lemma types sent to ElixirFM for analysis, about 20% received no analysis (OOV).</S>
			<S sid ="419" ssid = "12">A manual observation of a small sample revealed that at least half of those were proper names (and hence their NUMBER value would have stayed singular).</S>
			<S sid ="420" ssid = "13">Almost 9% of the ElixirFM-analyzed types (over 7% of the tokens) changed their NUMBER value.</S>
			<S sid ="421" ssid = "14">In the dev set, the OOV rate was less than 9%, and almost 11% of the ElixirFM-analyzed types changed their NUMBER value.</S>
			<S sid ="422" ssid = "15">This amounts to 4.4% of all tokens.</S>
			<S sid ="423" ssid = "16">We used ElixirFM to determine the values for FNNUM, the functional number feature.</S>
			<S sid ="424" ssid = "17">We used this feature in our best model so far, CORE 12+DET +PNG +LMM, instead of the form-based NUMBER feature.17 The ElixirFM-based models yielded small gains of up to 0.1% over this best model on predicted input.</S>
			<S sid ="425" ssid = "18">We then modified the ElixirFM- based best model to use the enhanced DET 2 feature.</S>
			<S sid ="426" ssid = "19">This variation yielded a similarly small gain, altogether less than 0.2% from its ElixirFM-free counterparts.</S>
			<S sid ="427" ssid = "20">5.2 Functional Gender and Number Features, and the Rationality Feature.</S>
			<S sid ="428" ssid = "21">The ElixirFM lexical resource used previously provided functional NUMBER feature values but no functional GENDER values, nor RAT (rationality, or humanness) values.</S>
			<S sid ="429" ssid = "22">To address this issue, we use a version of the PATB3 training and dev sets manually annotated with functional gender, number, and rationality (Alkuhlani and Habash 2011).18 This is the first resource providing all three features (ElixirFm only provides functional number, and to some extent functional gender).</S>
			<S sid ="430" ssid = "23">We conducted experiments with gold features to assess the potential of these features, and with predicted features, obtained from training a simple maximum likelihood estimation classifier on this resource (Alkuhlani and Habash 2012).19 The first part of Table 8 shows that the RAT (rationality) feature is very relevant (in gold), but suffers from low accuracy (no gains in machine-predicted input).</S>
			<S sid ="431" ssid = "24">The next two parts show the advantages of functional gender and number (denoted with a FN* prefix) over their surface-based counterparts.</S>
			<S sid ="432" ssid = "25">The fourth part of the table shows the combination of these functional features with the other features that participated in the best combination so far (LMM, the extended DET 2, and PERSON); without RAT, this combination is at least as useful as its form-based counterpart, in both gold and predicted input; adding RAT to this combination yields 0.4% (absolute) gain in gold, offering further support to the relevance of the rationality feature, but a slight decrease in predicted input, presumably due to insufficient accuracy again.</S>
			<S sid ="433" ssid = "26">The last part of the table revalidates the gains achieved with the best controlled feature combination, using CATIB EX—the best performing tag set with predicted input.</S>
			<S sid ="434" ssid = "27">Note, however, that the 1% (absolute) advantage of CATIB EX (without additional features) over the morphology-free CORE 12 on machine-predicted input (Table 2) has 16 http://sourceforge.net/projects/elixir-fm.</S>
			<S sid ="435" ssid = "28">17 We also applied the manipulations described in Section A.3 to FN NUM, giving us the variants.</S>
			<S sid ="436" ssid = "29">FN NUM DGT and FN NUM DGT BIN, which we tested similarly.</S>
			<S sid ="437" ssid = "30">18 In this article, we use a newer version of the corpus by Alkuhlani and Habash (2011) than the one we.</S>
			<S sid ="438" ssid = "31">used in Marton, Habash, and Rambow (2011).</S>
			<S sid ="439" ssid = "32">19 The paper by Alkuhlani and Habash (2012) presents additional, more sophisticated models that we do.</S>
			<S sid ="440" ssid = "33">not use in this article.</S>
			<S sid ="441" ssid = "34">178 Table 8 Models with functional features: GENDER, NUMBER, rationality (RAT).</S>
			<S sid ="442" ssid = "35">FN * = functional feature(s) based on Alkuhlani and Habash (2011); GN = GENDER +NUMBER ; GNR = GENDER + NUMBER +RAT.</S>
			<S sid ="443" ssid = "36">Statistical significance tested only for CORE 12+.</S>
			<S sid ="444" ssid = "37">models on predicted input, against the CORE 12 baseline.</S>
			<S sid ="445" ssid = "38">mo del (PO S tag set and feat ure s) g L AS old UA S LS p r e L AS dicte d UA S LS COR E 12 (rep eate d) 82 .9 85.</S>
			<S sid ="446" ssid = "39">4 93.</S>
			<S sid ="447" ssid = "40">5 78.</S>
			<S sid ="448" ssid = "41">7 82.</S>
			<S sid ="449" ssid = "42">5 90.</S>
			<S sid ="450" ssid = "43">6 +FN *RA TIO NAL 83 .7 85.</S>
			<S sid ="451" ssid = "44">8 94.</S>
			<S sid ="452" ssid = "45">0 78.</S>
			<S sid ="453" ssid = "46">7 82.</S>
			<S sid ="454" ssid = "47">5 90.</S>
			<S sid ="455" ssid = "48">7 +GE NDE R (rep eate d) 83 .0 85.</S>
			<S sid ="456" ssid = "49">2 93.</S>
			<S sid ="457" ssid = "50">6 78.</S>
			<S sid ="458" ssid = "51">8 82.</S>
			<S sid ="459" ssid = "52">4 90.</S>
			<S sid ="460" ssid = "53">8 +FN *GE NDE R 83 .3 85.</S>
			<S sid ="461" ssid = "54">5 93.</S>
			<S sid ="462" ssid = "55">7 78.</S>
			<S sid ="463" ssid = "56">9+ 82.</S>
			<S sid ="464" ssid = "57">6 90.</S>
			<S sid ="465" ssid = "58">9 +N UM BER (rep eate d) 83 .1 85.</S>
			<S sid ="466" ssid = "59">5 93.</S>
			<S sid ="467" ssid = "60">6 78.</S>
			<S sid ="468" ssid = "61">7 82.</S>
			<S sid ="469" ssid = "62">4 90.</S>
			<S sid ="470" ssid = "63">6 +FN *NU MB ER 83 .3 85.</S>
			<S sid ="471" ssid = "64">6 93.</S>
			<S sid ="472" ssid = "65">7 78.</S>
			<S sid ="473" ssid = "66">9+ 82.</S>
			<S sid ="474" ssid = "67">5 90.</S>
			<S sid ="475" ssid = "68">7 +DE T 2+L MM +PN G (rep eate d) 84 .6 86.</S>
			<S sid ="476" ssid = "69">5 94.</S>
			<S sid ="477" ssid = "70">7 80.</S>
			<S sid ="478" ssid = "71">2+ + 83.</S>
			<S sid ="479" ssid = "72">4 91.</S>
			<S sid ="480" ssid = "73">9 +DE T 2+L MM +PE RSO N +F N *NG R 85 .0 86.</S>
			<S sid ="481" ssid = "74">7 94.</S>
			<S sid ="482" ssid = "75">9 80.</S>
			<S sid ="483" ssid = "76">3+ + 83.</S>
			<S sid ="484" ssid = "77">7 91.</S>
			<S sid ="485" ssid = "78">6 +DE T 2+L MM +PE RSO N +F N *NG 84 .6 86.</S>
			<S sid ="486" ssid = "79">5 94.</S>
			<S sid ="487" ssid = "80">7 80.</S>
			<S sid ="488" ssid = "81">4+ + 83.</S>
			<S sid ="489" ssid = "82">5 91.</S>
			<S sid ="490" ssid = "83">9 CAT I B EX+ DET 2+L MM +PE RSO N +F N *NG R 84 .1 85.</S>
			<S sid ="491" ssid = "84">9 94.</S>
			<S sid ="492" ssid = "85">4 80.</S>
			<S sid ="493" ssid = "86">7 84.</S>
			<S sid ="494" ssid = "87">0 91.</S>
			<S sid ="495" ssid = "88">9 CAT I B EX+ DET 2+L MM +PE RSO N +F N *NG 83 .5 85.</S>
			<S sid ="496" ssid = "89">4 94.</S>
			<S sid ="497" ssid = "90">1 80.</S>
			<S sid ="498" ssid = "91">7 83.</S>
			<S sid ="499" ssid = "92">7 92.</S>
			<S sid ="500" ssid = "93">2 shrunk with these functional feature combinations to 0.3%.</S>
			<S sid ="501" ssid = "94">We take it as further support to the relevance of our functional morphology features, and their partial redundancy with the form-based morphological information embedded in the CATIB EX POS tags.</S>
	</SECTION>
	<SECTION title="Evaluation of Results with Easy-First Parser. " number = "6">
			<S sid ="502" ssid = "1">In this section, we validate the contribution of key tag sets and morphological features— and combinations thereof—using a different parser: the Easy-First Parser (Goldberg and Elhadad 2010).</S>
			<S sid ="503" ssid = "2">As in Section 4, all models are evaluated on both gold and non-gold (machine-predicted) feature values.</S>
			<S sid ="504" ssid = "3">The Easy-First Parser is a shift-reduce parser (as is MaltParser).</S>
			<S sid ="505" ssid = "4">Unlike MaltParser, however, it does not attempt to attach arcs “eagerly” as early as possible (as in previous sections), or at the latest possible stage (an option we abandoned early on in preliminary experiments).</S>
			<S sid ="506" ssid = "5">Instead, the Easy-First Parser keeps a stack of partially built treelets, and attaches them to one another in order of confidence (from high confidence, “easy” attachment, to low, as estimated by the classifier).</S>
			<S sid ="507" ssid = "6">Labeling the relation arcs is done in a second pass, with a separate training step, after all attachments have been decided (the code for which was added after the publication of Goldberg and Elhadad (2010), which only included an unlabeled attachment version).</S>
			<S sid ="508" ssid = "7">Setting machine-learning features for Easy-First Parser is not as simple and elegant as for MaltParser, but it gives the feature designer greater flexibility.</S>
			<S sid ="509" ssid = "8">For example, the POS tag can be dynamically split (or not) according to the token’s word-form and/or the already-built attachment treelets, whereas in MaltParser, one can meld several features into a single complex feature only if applied unconditionally to all tokens.</S>
			<S sid ="510" ssid = "9">The Easy-First Parser ’s first version comes with the code for the features used in its first publication.</S>
			<S sid ="511" ssid = "10">These include POS tag splitting and feature melding for prepositional attachment chains (e.g., parent-preposition-child).</S>
			<S sid ="512" ssid = "11">For greater control of the contribution of the various POS tag and morphological features in the experiments, and for 179 a better “apples-to-apples” comparison with MaltParser (as used here), we disabled these features, and instead used features (and selected feature melding) that were as equivalent to MaltParser as possible.</S>
			<S sid ="513" ssid = "12">Table 9 shows results with Easy-First Parser.</S>
			<S sid ="514" ssid = "13">Results with Easy-First Parser are consistently higher than the corresponding results with MaltParser, with similar trends for the various features’ contribution: Functional GENDER and NUMBER features contribute more than their form-based counterparts, in both gold and predicted conditions; rationality (RAT) as a single feature on top of the POS tag set helps in gold (and with Easy-First Parser, also in predicted conditions)—but when used in combination with PERSON, LMM, functional GENDER, and NUMBER, it actually slightly lowers parsing scores in predicted conditions (but with Easy-First Parser, it helps in gold conditions); DET is the most useful single feature in predicted conditions (from those we tried here); and the best performing model in predicted conditions is the same as with MaltParser: CORE 12+DET +LMM+PERSON+FN*NG.20 As before, we see that the patterns of gain achieved with the “morphology-free” CORE 12 hold also for CAT IB EX, the best performing tag set on predicted input.</S>
			<S sid ="515" ssid = "14">Interestingly, with this parser, the greater 1.6% (absolute) advantage of CATIB EX (without additional features) over the morphology-free CORE 12 on machine-predicted input (compare with only 1% in MaltParser in Table 2) has shrunk completely with these functional feature combinations.</S>
			<S sid ="516" ssid = "15">This suggests that Easy-First Parser is more resilient to accuracy errors (presumably due to its design to make less ambiguous decisions earlier), and hence can take better advantage of the relevant information encoded in our functional morphology features.</S>
	</SECTION>
	<SECTION title="Combined Gold and Predicted Features for Training. " number = "7">
			<S sid ="517" ssid = "1">So far, we have only evaluated models trained on gold POS tag set and morphological feature values.</S>
			<S sid ="518" ssid = "2">Some researchers, however, including Goldberg and Elhadad (2010), train on predicted feature values instead.</S>
			<S sid ="519" ssid = "3">It makes sense that training on predicted features yields better scores for evaluation on predicted features, since the training better resembles the test.</S>
			<S sid ="520" ssid = "4">But we argue that it also makes sense that training on a combination of gold and predicted features (one copy of each) might do even better, because good predictions of feature values are reinforced (since they repeat the gold patterns), whereas noisy predicted feature values are still represented in training (in patterns that do not repeat the gold).21 To test our hypothesis, we start this section by comparing three variations: • Training on gold feature values (as has been the case so far) • Training on predicted feature values (as in Goldberg and Elhadad 2010) • Training on the novel combination of gold and predicted features (denoted below as g+p) 20 Recall that DET 2 was only defined for MaltParser, and not for the Easy-First Parser..</S>
			<S sid ="521" ssid = "5">21 Although conceived independently, this hypothesis resembles self-training (McClosky, Charniak, and.</S>
			<S sid ="522" ssid = "6">Johnson 2006), where the parser is retrained on its own predicted parsing output, together with the original labeled training data.</S>
			<S sid ="523" ssid = "7">Note, however, that we retrain on gold and predicted feature values (e.g., POS tag, GENDER, or NUMBER), but we always use gold training data for HEAD and DEPREL.</S>
			<S sid ="524" ssid = "8">In both cases the parsers seem to benefit from training data (features) that better resemble the test data, while retaining bias toward the gold and correctly predicted data.</S>
			<S sid ="525" ssid = "9">180 Table 9 Select models trained using the Easy-First Parser.</S>
			<S sid ="526" ssid = "10">Statistical significance tested only for CORE 12.</S>
			<S sid ="527" ssid = "11">models on predicted input: significance of the Easy-First Parser CORE 12 baseline model against its MaltParser counterpart; and significance of all other CORE 12+.</S>
			<S sid ="528" ssid = "12">models against the Easy-First Parser CORE 12 baseline model.</S>
			<S sid ="529" ssid = "13">mod el (PO S tag set and feat ures ) gold L AS U AS LS p r e d i c t e d L A S U A S L S COR E 12 (Ma ltPar ser basel ine, repe ated ) 82.9 85.4 93.5 COR E 12 (Easy First Pars er) 83.5 86.0 93.9 COR E 12+ NUM BER 83.3 85.7 94.0 COR E 12+ FN *NU MBE R 83.5 85.9 94.0 COR E 12+ GEN DER 83.5 86.0 94.0 COR E 12+ FN *GE NDE R 83.6 86.1 94.0 COR E 12+ RAT 84.2 86.4 94.4 COR E 12+ DET 84.3 86.7 94.5 COR E 12+ LMM 83.6 85.8 94.1 COR E 12+ DET +LM M +PN G 84.8 86.9 94.9 COR E 12+ DET +LM M +PE RSO N +FN *NG 84.9 86.9 94.8 COR E 12+ DET +LM M +PE RSO N +FN *N GR 85.1 87.1 94.9 78.</S>
			<S sid ="530" ssid = "14">7 82.5 90.6 79.</S>
			<S sid ="531" ssid = "15">6+ + 83.</S>
			<S sid ="532" ssid = "16">5 91.</S>
			<S sid ="533" ssid = "17">3 79.</S>
			<S sid ="534" ssid = "18">5 83.4 91.3 79.</S>
	</SECTION>
	<SECTION title="83.6   91.4" number = "8">
			<S sid ="535" ssid = "1">79.</S>
			<S sid ="536" ssid = "2">5 83.5 91.3 79.</S>
			<S sid ="537" ssid = "3">7 83.6 91.3 79.</S>
			<S sid ="538" ssid = "4">6 83.6 91.3 80.</S>
			<S sid ="539" ssid = "5">6+ + 84.</S>
			<S sid ="540" ssid = "6">1 92.</S>
			<S sid ="541" ssid = "7">2 79.</S>
			<S sid ="542" ssid = "8">7 83.5 91.5 81.</S>
			<S sid ="543" ssid = "9">1+ + 84.</S>
			<S sid ="544" ssid = "10">4 92.</S>
			<S sid ="545" ssid = "11">3 81.</S>
			<S sid ="546" ssid = "12">4+ + 84.</S>
			<S sid ="547" ssid = "13">7 92.</S>
			<S sid ="548" ssid = "14">4 81.</S>
			<S sid ="549" ssid = "15">2+ + 84.</S>
			<S sid ="550" ssid = "16">7 92.</S>
			<S sid ="551" ssid = "17">1 CAT I B EX 83.1 85.6 94.0 CAT I B EX+ DET +LM M +PE RSO N +FN *NG 83.5 85.8 94.2 CAT I B EX+ DET +LM M +PE RSO N +FN *N GR 83.9 85.9 94.7 81.</S>
			<S sid ="552" ssid = "18">2 84.6 92.5 81.</S>
			<S sid ="553" ssid = "19">4 84.6 92.7 81.</S>
			<S sid ="554" ssid = "20">1 84.6 92.5 The first two parts of Table 10 show that, as expected, training on gold feature values yields better scores when evaluated on gold, too (although later we see this is not always the case).</S>
			<S sid ="555" ssid = "21">More interestingly, when evaluated on predicted feature values, training on predicted feature values yields better parsing scores than when training on gold, and training on g+p yields best scores, in support of our hypothesis.</S>
			<S sid ="556" ssid = "22">Therefore, in the rest of the table (and in the rest of the experiments), we apply the g+p training variant to the best models so far, both in MaltParser and Easy-First Parser.</S>
			<S sid ="557" ssid = "23">The next part in Table 10 shows that this trend is consistent also with the best feature combinations so far.</S>
			<S sid ="558" ssid = "24">Interestingly, the RAT feature contributes to improvement only in the g+p condition, presumably because of its low prediction accuracy.</S>
			<S sid ="559" ssid = "25">In Table 11, we repeated most of these experiments with other tag sets: CAT IB EX and BW (best performers on predicted and gold input, respectively).</S>
			<S sid ="560" ssid = "26">We can see in this table that the same trends hold for these POS tag sets as well.</S>
			<S sid ="561" ssid = "27">Interestingly, the “morphology-free” CORE 12 (in Table 10) outperforms CAT IB EX here (Table 11), making CORE 12+DET 2+LMM+PERSON+FN*NGR our best MaltParser model on predicted feature values.</S>
			<S sid ="562" ssid = "28">Similarly, the Easy-First Parser model CORE 12+DET +LMM+PERSON+ FN*NG outperforms its CATIB EX counterpart (CATIB EX+DET +LMM+PERSON+FN*NG), resulting in our best model on the dev set in machine-predicted condition (82.7%).22 The richest POS tag set, BW, which is also the worst predicted tag set and worst performer on predicted input, had the most dramatic gains from using g+p: more than 22 See Section 9 for download information..</S>
			<S sid ="563" ssid = "29">181 Table 10 Alternatives to training on gold-only feature values.</S>
			<S sid ="564" ssid = "30">Top: Select MaltParser CORE 12+.</S>
			<S sid ="565" ssid = "31">models retrained on predicted or gold + predicted feature values.</S>
			<S sid ="566" ssid = "32">Bottom: Similar models to the top half, with the Easy-First Parser.</S>
			<S sid ="567" ssid = "33">Statistical significance tested only for CORE 12+.</S>
			<S sid ="568" ssid = "34">models on predicted input: significance of the MaltParser models from the MaltParser CORE 12 baseline model, and significance of the Easy-First Parser models from the Easy-First Parser CORE 12 baseline.</S>
			<S sid ="569" ssid = "35">mod el (PO S tag set and feat ures ) gold L AS U AS LS p r e d i c t e d L A S U A S L S M a l t P a r s e r : COR E 12 (gol d train , repe ated ) 82.9 85.4 93.5 COR E 12 pred icte d train 82.4 85.0 93.2 COR E 12 g+p 82.7 85.2 93.5 COR E 12+ DET +LM M +PN G (gol d train , repe ated ) 84.4 86.4 94.6 COR E 12+ DET +LM M +PN G pred icte d train 84.1 86.1 94.3 COR E 12+ DET +LM M +PN G g+p 84.2 86.1 94.5 CO R E 1 2 + D E T 2 + L M M + P E R S O N + F N * N G R 85.0 86.7 94.9 (gold train, repeated) CO R E 1 2 + D E T 2 + L M M + P E R S O N + F N * N G 84.6 86.5 94.7 (gold train, repeated) COR E 12+ DET 2+L MM +PE RSO N +FN *NG g+p 84.4 86.3 94.6 COR E 12+ DET 2+L MM +PE RSO N +FN *NG R g+p 84.7 86.5 94.7 78.</S>
			<S sid ="570" ssid = "36">7 82.5 90.6 79.</S>
			<S sid ="571" ssid = "37">8+ + 83.</S>
			<S sid ="572" ssid = "38">2 91.</S>
			<S sid ="573" ssid = "39">4 80.</S>
			<S sid ="574" ssid = "40">0+ + 83.</S>
			<S sid ="575" ssid = "41">4 91.</S>
			<S sid ="576" ssid = "42">6 80.</S>
			<S sid ="577" ssid = "43">2+ + 83.</S>
			<S sid ="578" ssid = "44">3 91.</S>
			<S sid ="579" ssid = "45">9 81.</S>
			<S sid ="580" ssid = "46">6+ + 84.</S>
			<S sid ="581" ssid = "47">4 92.</S>
			<S sid ="582" ssid = "48">8 81.</S>
			<S sid ="583" ssid = "49">7+ + 84.</S>
			<S sid ="584" ssid = "50">5 92.</S>
			<S sid ="585" ssid = "51">9 80.</S>
			<S sid ="586" ssid = "52">3+ + 83.</S>
			<S sid ="587" ssid = "53">7 91.</S>
			<S sid ="588" ssid = "54">6 80.</S>
			<S sid ="589" ssid = "55">4+ + 83.</S>
			<S sid ="590" ssid = "56">5 91.</S>
			<S sid ="591" ssid = "57">9 81.</S>
			<S sid ="592" ssid = "58">8+ + 84.</S>
			<S sid ="593" ssid = "59">6 93.</S>
			<S sid ="594" ssid = "60">0 81.</S>
			<S sid ="595" ssid = "61">9+ + 84.</S>
			<S sid ="596" ssid = "62">7 93.</S>
			<S sid ="597" ssid = "63">0 E a s y F i r s t P a r s e r : COR E 12 (gol d train , repe ated ) 83.5 86.0 93.9 COR E 12 g+p 83.6 86.1 94.1 COR E 12+ DET +LM M +PN G g+p 84.8 86.9 94.7 COR E 12+ DET +LM M +PE RSO N +FN *NG g+p 84.9 86.9 94.9 COR E 12+ DET +LM M +PE RSO N +FN *N GR g+p 85.2 87.2 95.0 79.</S>
			<S sid ="598" ssid = "64">6 83.5 91.3 80.</S>
			<S sid ="599" ssid = "65">8+ + 84.</S>
			<S sid ="600" ssid = "66">4 92.</S>
			<S sid ="601" ssid = "67">3 82.</S>
			<S sid ="602" ssid = "68">5+ + 85.</S>
			<S sid ="603" ssid = "69">5 93.</S>
			<S sid ="604" ssid = "70">3 82.</S>
			<S sid ="605" ssid = "71">7+ + 85.</S>
			<S sid ="606" ssid = "72">7 93.</S>
			<S sid ="607" ssid = "73">3 82.</S>
			<S sid ="608" ssid = "74">6+ + 85.</S>
			<S sid ="609" ssid = "75">7 93.</S>
			<S sid ="610" ssid = "76">2 5% (absolute) for LAS on predicted input with MaltParser (and over 3% with Easy- First Parser).</S>
			<S sid ="611" ssid = "77">Although much improved, BW models’ performance still lags behind the leading models.</S>
			<S sid ="612" ssid = "78">The results in Tables 10 and 11 suggest that our g+p training method is superior to the alternatives (independently of parser choice) due to making the parser more resilient to lower accuracy in the input.</S>
			<S sid ="613" ssid = "79">It also suggests that g+p training enables the parser to better exploit relevant data when represented in “cleaner ” separate features, as opposed to when the POS tags are split into ambiguous form-based cases as in CAT IB EX.</S>
			<S sid ="614" ssid = "80">Future experimentation is needed in order to test this latter conjecture.</S>
			<S sid ="615" ssid = "81">8.</S>
			<S sid ="616" ssid = "82">Result Validation and Discussion.</S>
			<S sid ="617" ssid = "83">8.1 Validating Results on an Unseen Test Set.</S>
			<S sid ="618" ssid = "84">Once experiments on the development set were done, we ran the best performing form- based non-gold-based models from Section 4 on a previously unseen test set.</S>
			<S sid ="619" ssid = "85">This set 182 Table 11 Alternatives to training on gold-only feature values for CAT I B EX and BW tag sets.</S>
			<S sid ="620" ssid = "86">Top: Select MaltParser models retrained on predicted or gold + predicted feature values.</S>
			<S sid ="621" ssid = "87">Bottom: Similar models to the top half, with the Easy-First Parser.</S>
			<S sid ="622" ssid = "88">(Statistical significance was tested only for CORE 12+.</S>
			<S sid ="623" ssid = "89">models – none here).</S>
			<S sid ="624" ssid = "90">mod el (PO S tag set and feat ures ) gold L AS U AS LS p r e d i c t e d L A S U A S L S M a l t P a r s e r : CAT I B EX (gol d train , repe ated ) 82.5 85.0 93.4 CAT I B EX g+p 82.3 84.8 93.3 CA T I B E X + D E T 2 + L M M + P E R S O N + F N * N G 83.5 85.4 94.1 (gold train, repeated) CA T I B E X + D E T 2 + L M M + P E R S O N + F N * N G R 84.1 85.9 94.4 (gold train) CAT I B EX+ DET 2+L MM +PE RSO N +FN *NG g+p 83.2 85.3 93.9 CAT I B EX+ DET 2+L MM +PE RSO N +FN *NG R g+p 83.7 85.7 94.2 BW (gol d train , repe ated ) 84.0 85.8 94.8 BW g+p 83.9 85.7 94.7 BW+ DET 2+L MM +PE RSO N +FN *NG g+p 84.8 86.4 95.1 BW+ DET 2+L MM +PE RSO N +FN *NG R g+p 85.1 86.6 95.2 79.</S>
			<S sid ="625" ssid = "91">7 83.3 91.4 80.</S>
			<S sid ="626" ssid = "92">4 83.6 92.0 80.</S>
			<S sid ="627" ssid = "93">7 83.7 92.2 80.</S>
			<S sid ="628" ssid = "94">7 84.0 91.9 81.</S>
			<S sid ="629" ssid = "95">3 84.2 92.6 81.</S>
			<S sid ="630" ssid = "96">4 84.3 92.6 72.</S>
			<S sid ="631" ssid = "97">6 77.9 86.5 77.</S>
			<S sid ="632" ssid = "98">8 81.4 90.3 79.</S>
			<S sid ="633" ssid = "99">4 82.6 91.2 79.</S>
			<S sid ="634" ssid = "100">5 82.7 91.2 E a s y F i r s t P a r s e r : CAT I B EX (gol d train , repe ated ) 83.1 85.6 94.0 CAT I B EX g+p 82.5 85.1 93.8 CA T I B E X + D E T + L M M + P E R S O N + F N * N G 83.5 85.8 94.2 (gold train, repeated) CA T I B E X + D E T + L M M + P E R S O N + F N * N G R 83.9 85.9 94.7 (gold train, repeated) CAT I B EX+ DET +LM M +PN G g+p 83.4 85.7 94.3 CAT I B EX+ DET +LM M +PE RSO N +FN *NG g+p 83.6 85.8 94.4 CAT I B EX+ DET +LM M +PE RSO N +FN *N GR g+p 83.9 86.0 94.6 BW (gol d train , repe ated ) 84.9 86.6 95.6 BW g+p 84.4 86.2 95.3 BW+ DET +LM M +PE RSO N +FN *NG g+p 84.8 86.5 95.5 BW+ DET +LM M +PE RSO N +FN *N GR g+p 85.1 86.7 95.6 81.</S>
			<S sid ="635" ssid = "101">2 84.6 92.5 81.</S>
			<S sid ="636" ssid = "102">2 84.4 92.9 81.</S>
			<S sid ="637" ssid = "103">4 84.6 92.7 81.</S>
			<S sid ="638" ssid = "104">1 84.6 92.5 82.</S>
			<S sid ="639" ssid = "105">1 85.0 93.3 82.</S>
			<S sid ="640" ssid = "106">0 84.9 93.4 82.</S>
			<S sid ="641" ssid = "107">2 85.3 93.2 77.</S>
			<S sid ="642" ssid = "108">5 82.2 90.1 80.</S>
			<S sid ="643" ssid = "109">7 84.1 92.5 81.</S>
			<S sid ="644" ssid = "110">1 84.2 92.8 81.</S>
			<S sid ="645" ssid = "111">2 84.4 92.9 Table 12 Results on PATB3-TEST for form-based models which performed best on PATB3DEV – predicted input.</S>
			<S sid ="646" ssid = "112">Statistical significance tested on the PATB3-TEST set, only for MaltParser CORE 12+.</S>
			<S sid ="647" ssid = "113">models against the MaltParser CORE 12 baseline model output.</S>
			<S sid ="648" ssid = "114">mo del (PO S tag set and mor ph.</S>
			<S sid ="649" ssid = "115">feat ure s) L A S UA S LS COR E 12 77 .3 81.</S>
			<S sid ="650" ssid = "116">0 90.</S>
			<S sid ="651" ssid = "117">1 COR E 12+ DET +PN G 78 .6 81.</S>
			<S sid ="652" ssid = "118">7 91.</S>
			<S sid ="653" ssid = "119">1 COR E 12+ DET +L MM +PN G 79 .1 + + 82.</S>
			<S sid ="654" ssid = "120">1 91.</S>
			<S sid ="655" ssid = "121">4 CAT IB EX 78 .5 81.</S>
			<S sid ="656" ssid = "122">8 91.</S>
			<S sid ="657" ssid = "123">0 CAT IB EX+ DET +L MM +PN G 79 .3 82.</S>
			<S sid ="658" ssid = "124">4 91.</S>
			<S sid ="659" ssid = "125">6 183 is the test split of part 3 of the PATB (hereafter PATB3-TEST; see Table 1 for details).</S>
			<S sid ="660" ssid = "126">Table 12 shows that the same trends held on this set too, with even greater relative gains, up to almost 2% absolute gains.</S>
			<S sid ="661" ssid = "127">We then also revalidated the contribution of the best performing models from Sections 5–7 on PATB3-TEST.</S>
			<S sid ="662" ssid = "128">Here, too, the same trends held.</S>
			<S sid ="663" ssid = "129">Results are shown in Table 13.</S>
			<S sid ="664" ssid = "130">8.2 Best Results on Length-Filtered Input.</S>
			<S sid ="665" ssid = "131">For better comparison with work of others, we adopt the suggestion made by Green and Manning (2010) to evaluate the parsing quality on sentences up to 70 tokens long.</S>
			<S sid ="666" ssid = "132">We report these filtered results in Table 14.</S>
			<S sid ="667" ssid = "133">Filtered results are consistently higher (as expected).</S>
			<S sid ="668" ssid = "134">Results are about 0.9% absolute higher on the development set, and about 0.6% higher on the test set.</S>
			<S sid ="669" ssid = "135">The contribution of the RAT feature across sets is negligible (or small and unstable), resulting in less than 0.1% absolute loss on the dev set, but about 0.15% gain on the test set.</S>
			<S sid ="670" ssid = "136">For clarity and conciseness, we only show the best model (with RAT) in Table 14.</S>
			<S sid ="671" ssid = "137">8.3 Error Analysis.</S>
			<S sid ="672" ssid = "138">We perform two types of error analyses.</S>
			<S sid ="673" ssid = "139">First, we analyze the attachment accuracy by attachment relation type on PATB3DEV.</S>
			<S sid ="674" ssid = "140">Our hypothesis is that the syntactic relations which are involved in agreement or assignment configurations will show an improvement when the relevant morphological features are used, but other syntactic Table 13 Results on PATB3-TEST for models that performed best on PATB3DEV – predicted input.</S>
			<S sid ="675" ssid = "141">Using MaltParser, unless indicated otherwise.</S>
			<S sid ="676" ssid = "142">g+p = trained on combination of gold and predicted input (instead of gold-only).</S>
			<S sid ="677" ssid = "143">Statistical significance tested only for CORE 12+.</S>
			<S sid ="678" ssid = "144">models: For MaltParser CORE 12+.</S>
			<S sid ="679" ssid = "145">models against the MaltParser CORE 12 baseline model output, and for Easy-First Parser CORE 12+.</S>
			<S sid ="680" ssid = "146">models against the Easy-First Parser CORE 12 baseline model output.</S>
			<S sid ="681" ssid = "147">PO S tag set L AS UA S LS COR E 12 (rep eate d) 77.</S>
			<S sid ="682" ssid = "148">3 81.</S>
			<S sid ="683" ssid = "149">0 90.</S>
			<S sid ="684" ssid = "150">1 COR E 12+ DET 2+L MM +PG +F N NU M DG T BIN 79.</S>
			<S sid ="685" ssid = "151">3+ + 82.</S>
			<S sid ="686" ssid = "152">3 91.</S>
			<S sid ="687" ssid = "153">4 COR E 12+ DET 2+L MM +PE RSO N +F N *NG R 78.</S>
			<S sid ="688" ssid = "154">9+ 82.</S>
			<S sid ="689" ssid = "155">3 91.</S>
			<S sid ="690" ssid = "156">0 COR E 12+ DET 2+L MM +PE RSO N +F N *NG 79.</S>
			<S sid ="691" ssid = "157">1+ + 82.</S>
			<S sid ="692" ssid = "158">1 91.</S>
			<S sid ="693" ssid = "159">4 COR E 12+ DET 2+L MM +PE RSO N +FN *NG R g+p, Easy First Par ser 81.</S>
			<S sid ="694" ssid = "160">0+ + 84.</S>
			<S sid ="695" ssid = "161">0 92.</S>
			<S sid ="696" ssid = "162">7 COR E 12+ DET 2+L MM +PE RSO N +FN *NG g+p, Easy First Par ser 80.</S>
			<S sid ="697" ssid = "163">9+ + 83.</S>
			<S sid ="698" ssid = "164">9 92.</S>
			<S sid ="699" ssid = "165">8 CAT IB EX 78.</S>
			<S sid ="700" ssid = "166">5 81.</S>
			<S sid ="701" ssid = "167">8 91.</S>
			<S sid ="702" ssid = "168">0 CAT IB EX+ DET 2+L MM +PG +F N NU M DG T BIN 79.</S>
			<S sid ="703" ssid = "169">4 82.</S>
			<S sid ="704" ssid = "170">5 91.</S>
			<S sid ="705" ssid = "171">6 CAT IB EX+ DET 2+L MM +PE RSO N +F N *NG R 79.</S>
			<S sid ="706" ssid = "172">3 82.</S>
			<S sid ="707" ssid = "173">6 91.</S>
			<S sid ="708" ssid = "174">3 CAT IB EX+ DET 2+L MM +PE RSO N +F N *NG 79.</S>
			<S sid ="709" ssid = "175">3 82.</S>
			<S sid ="710" ssid = "176">4 91.</S>
			<S sid ="711" ssid = "177">5 CAT IB EX+ DET 2+L MM +PE RSO N +FN *NG R g+p, Easy First Par ser 79.</S>
			<S sid ="712" ssid = "178">5 83.</S>
			<S sid ="713" ssid = "179">0 91.</S>
			<S sid ="714" ssid = "180">9 CAT IB EX+ DET 2+L MM +PE RSO N +FN *NG g+p, Easy First Par ser 79.</S>
			<S sid ="715" ssid = "181">6 82.</S>
			<S sid ="716" ssid = "182">8 92.</S>
			<S sid ="717" ssid = "183">1 BW 72.</S>
			<S sid ="718" ssid = "184">1 77.</S>
			<S sid ="719" ssid = "185">2 86.</S>
			<S sid ="720" ssid = "186">3 BW +DE T 2+L MM +PE RSO N +FN *NG R g+p, Easy First Par ser 79.</S>
			<S sid ="721" ssid = "187">6 82.</S>
			<S sid ="722" ssid = "188">7 92.</S>
			<S sid ="723" ssid = "189">2 BW +DE T 2+L MM +PE RSO N +FN *NG g+p, Easy First Par ser 79.</S>
			<S sid ="724" ssid = "190">7 82.</S>
			<S sid ="725" ssid = "191">9 92.</S>
			<S sid ="726" ssid = "192">3 184 Table 14 Results for best performing model on PATB3DEV and PATB3-TEST for sentences up to 70 tokens long (predicted input).</S>
			<S sid ="727" ssid = "193">Easy-First Parser Easy-First Parser relations will not.</S>
			<S sid ="728" ssid = "194">Second, we analyze the grammaticality of the obtained parse trees with respect to agreement and assignment phenomena.</S>
			<S sid ="729" ssid = "195">Here, our hypothesis is that when using morphological features, the grammaticality of the obtained parse trees will increase.</S>
			<S sid ="730" ssid = "196">Attachment accuracy by relation type.</S>
			<S sid ="731" ssid = "197">Our first hypothesis is illustrated in Figure 2.</S>
			<S sid ="732" ssid = "198">On the left, we see the parse provided by our baseline system (MaltParser using only CORE 12), which has two errors: • The node labeled i .v1 ÂyAm (‘days’) should be the subject, not the object, of the main verb &apos;-&apos;.</S>
			<S sid ="733" ssid = "199">_;..</S>
			<S sid ="734" ssid = "200">mrt (‘passed’).</S>
			<S sid ="735" ssid = "201">Morphologically, i .v1 ÂyAm is masculine plural,and &apos;-&apos;.</S>
			<S sid ="736" ssid = "202">_;..</S>
			<S sid ="737" ssid = "203">mrt (‘passed’) is feminine singular, obeying the agreement pattern un der which a non-rational subject following the verb always triggers a feminine singular verbal form.</S>
			<S sid ="738" ssid = "204">• The node labeled V&quot;..Lt.�.</S>
			<S sid ="739" ssid = "205">1 Almhnds (‘the engineer ’) should not be in an idafa (genitive construction) dependency with its governor JL..._;J1 Alzmyl (‘the colleague’), but in a modifier relation (a sort of apposition, in this case).</S>
			<S sid ="740" ssid = "206">This must be the case because a noun that is the head of an idafa construction cannot have a definite determiner, as is the case here.</S>
			<S sid ="741" ssid = "207">Both errors could be corrected (to the correct form as in our best model, on the right- hand side of Figure 2) if functional morphological features were available to the parser, including the rationality feature, and if the parser could learn the agreement rule for non-rational subjects, as well as the requirement that the head of an idafa construction cannot have a definite article.</S>
			<S sid ="742" ssid = "208">Our first hypothesis is generally borne out.</S>
			<S sid ="743" ssid = "209">We discuss three conditions in more detail: 1.</S>
			<S sid ="744" ssid = "210">Using morphological features with the MaltParser and training on gold tags.</S>
			<S sid ="745" ssid = "211">(Table 15).</S>
			<S sid ="746" ssid = "212">2.</S>
			<S sid ="747" ssid = "213">Using morphological features with the MaltParser and training on a combination.</S>
			<S sid ="748" ssid = "214">of gold and predicted tags (Table 16).</S>
			<S sid ="749" ssid = "215">3.</S>
			<S sid ="750" ssid = "216">Using morphological features with the Easy-First parser and training on a combi-.</S>
			<S sid ="751" ssid = "217">nation of gold and predicted tags (Table 17).</S>
			<S sid ="752" ssid = "218">In all cases, for controlled investigation, we compare the error reduction resulting from adding morphological features to a “morphology-free” baseline, which in all cases we take to be the MaltParser trained on the gold CORE 12, and evaluated on 185 Baseline V &apos;-&apos;.</S>
			<S sid ="753" ssid = "219">_;..</S>
			<S sid ="754" ssid = "220">mrt ‘passed’ B e s t V &apos;-&apos; . _ ; . . m r t ‘ p a s s e d ’ MOD P u ς lý ‘upon’ OBJ N . .A.L&gt;1 Aˇ xtfA’ ‘disappearance’ IDF N JL..._;J1 Alzmyl ‘the colleague’ &lt;&lt;&lt;IDF&gt;&gt;&gt; N V&quot;..Lt.�.</S>
			<S sid ="755" ssid = "221">1 Almhnds ‘the engineer ’ MOD PN ...</S>
			<S sid ="756" ssid = "222">&lt;&lt;&lt;OBJ&gt;&gt;&gt; N i v.1 ÂyAm ‘days’ MOD P u ς lý ‘upon’ OBJ N . .A.L&gt;1 Aˇ xtfA’ ‘disappearance’ IDF N JL..._;J1 Alzmyl ‘the colleague’ MOD N V&quot;..Lt.�.</S>
			<S sid ="757" ssid = "223">1 Almhnds ‘the engineer ’ MOD PN ...</S>
			<S sid ="758" ssid = "224">S B J N i v . 1 Â y A m ‘ d a y s ’ Figure 2 Error analysis example.</S>
			<S sid ="759" ssid = "225">V&quot;..Lt.�.</S>
			<S sid ="760" ssid = "226">1 JL.._;J1 . .A.L&gt;1 u i v1 &apos;-&apos;.</S>
			<S sid ="761" ssid = "227">_;..</S>
			<S sid ="762" ssid = "228">mrt ÂyAm ς lý Aˇ xtfA’ Alzmyl Almhnds ...</S>
			<S sid ="763" ssid = "229">(‘Several days have passed since the disappearance of the colleague the engineer ... ’), as parsed by the baseline system using only CORE 12 (left) and as using the best performing model (right).</S>
			<S sid ="764" ssid = "230">Bad predictions are marked with &lt;&lt;&lt; . . .</S>
			<S sid ="765" ssid = "231">The words in the tree are presented in the Arabic reading direction (from right to left).</S>
			<S sid ="766" ssid = "232">machine-predicted input (except for Table 17, where the Easy-First Parser is trained and evaluated instead).</S>
			<S sid ="767" ssid = "233">We start out by investigating the behavior of MaltParser, using all gold tags for training.</S>
			<S sid ="768" ssid = "234">The accuracy by relation type is shown in Table 15.</S>
			<S sid ="769" ssid = "235">Using just CORE 12, we see that some attachments (subject, modifications) are harder than others (objects, idafa).</S>
			<S sid ="770" ssid = "236">We see that by adding LMM, all attachment types improve a little bit; this is as expected, because this feature provides a slight lexical abstraction.</S>
			<S sid ="771" ssid = "237">We then add features designed to improve idafa and those relations subject to agreement, subject, and nominal modification (DET 2, PERSON, NUMBER, GENDER).</S>
			<S sid ="772" ssid = "238">We see that, as expected, subject, nominal modification, and idafa reduce error by substantial margins (error reduction over CORE 12 is greater than 10%; in the case of idafa it is 21.8%), and all other relations (including object and prepositional attachment) improve to a lesser degree (error reduction of 7.1% or less).</S>
			<S sid ="773" ssid = "239">We assume that the non-agreement relations (object 186 Table 15 Training the MaltParser on gold tags, accuracy by gold attachment type (selected): subject, object, modification (of a verb or a noun) by a noun, modification (of a verb or a noun) by a preposition, idafa, and overall results (repeated).</S>
			<S sid ="774" ssid = "240">mo del (PO S and mo rph olo gica l feat ure s) SB J OB J M OD N M OD Pr ep ID F tot al COR E 12 67.</S>
			<S sid ="775" ssid = "241">9 90.</S>
			<S sid ="776" ssid = "242">4 7 2 . 0 7 0 . 3 94.</S>
			<S sid ="777" ssid = "243">5 78.</S>
			<S sid ="778" ssid = "244">7 COR E 12 + LM M 68.</S>
			<S sid ="779" ssid = "245">8 90.</S>
			<S sid ="780" ssid = "246">4 7 2 . 6 7 0 . 9 94.</S>
			<S sid ="781" ssid = "247">6 79.</S>
			<S sid ="782" ssid = "248">0 COR E 12 + DET 2+L MM +PN G 71.</S>
			<S sid ="783" ssid = "249">7 91.</S>
			<S sid ="784" ssid = "250">0 7 4 . 9 7 2 . 4 95.</S>
			<S sid ="785" ssid = "251">5 80.</S>
			<S sid ="786" ssid = "252">2 COR E 12 + DET 2+L MM +PE RSO N +F N *NG 72.</S>
			<S sid ="787" ssid = "253">3 91.</S>
			<S sid ="788" ssid = "254">0 7 5 . 6 7 2 . 7 95.</S>
			<S sid ="789" ssid = "255">5 80.</S>
			<S sid ="790" ssid = "256">4 COR E 12 + DET 2+L MM +PE RSO N +F N *NG R 71.</S>
			<S sid ="791" ssid = "257">9 91.</S>
			<S sid ="792" ssid = "258">2 7 4 . 5 7 3 . 2 95.</S>
			<S sid ="793" ssid = "259">3 80.</S>
			<S sid ="794" ssid = "260">2 and prepositional attachment) improve because of the overall improvement in the parse due to the improvements in the other relations.</S>
			<S sid ="795" ssid = "261">When we move to the functional features, using functional number and gender, we see a further reduction in the agreement-related attachments, namely, subject and nominal modification (error reductions over baseline of 13.7% and 12.9%, respectively).</S>
			<S sid ="796" ssid = "262">Idafa decreases slightly (because this relation is not affected by the functional features), whereas object stays the same.</S>
			<S sid ="797" ssid = "263">Surprisingly, prepositional attachment also improves, with an error reduction of 8.1%.</S>
			<S sid ="798" ssid = "264">Again, we can only explain this by proposing that the improvement in nominal modification attachment has the indirect effect of ruling out some bad prepositional attachments as well.</S>
			<S sid ="799" ssid = "265">We then add the rationality feature (last line of Table 15).</S>
			<S sid ="800" ssid = "266">We now see that all relations affected by agreement or assignment perform worse than without the rationality feature.</S>
			<S sid ="801" ssid = "267">In contrast, all other relations improve.</S>
			<S sid ="802" ssid = "268">The decrease in performance can be explained by the fact that the rationality (RAT) feature is not predicted with high accuracy; because it interacts directly with agreement, and because we are training on gold annotation, the models trained do not correspond to the seen data.</S>
			<S sid ="803" ssid = "269">We expect rationality to contribute when we look at training that includes predicted features.</S>
			<S sid ="804" ssid = "270">(We have no explanation for the improvement in the other relations.)</S>
			<S sid ="805" ssid = "271">We now turn to training the MaltParser on a combination of gold and predicted POS and morphological feature values (g+p; Section 7).</S>
			<S sid ="806" ssid = "272">The accuracy by relation is shown in Table 16.</S>
			<S sid ="807" ssid = "273">The table repeats (in the first row) the results for the MaltParser trained only using gold CORE 12 features.</S>
			<S sid ="808" ssid = "274">First, we see that using the same single feature, but training on gold and predicted tags, we obtain an across-the-board improvement, Table 16 Training the MaltParser on gold and predicted tags, accuracy by gold attachment type (selected): subject, object, modification (of a verb or a noun) by a noun, modification (of a verb or a noun) by a preposition, idafa, and overall results (repeated).</S>
			<S sid ="809" ssid = "275">+FN *NG g+p +FN *NGR g+p 187 Table 17 Training the Easy-First Parser on gold and predicted tags, accuracy by gold attachment type (selected): subject, object, modification (of a verb or a noun) by a noun, modification (of a verb or a noun) by a preposition, idafa, and overall results (repeated).</S>
			<S sid ="810" ssid = "276">mo del (PO S and mo rph olo gica l feat ure s) SB J OB J M OD N M OD Pr ep ID F tot al COR E 12 70.</S>
			<S sid ="811" ssid = "277">8 90.</S>
			<S sid ="812" ssid = "278">7 7 3 . 1 7 1 . 4 94.</S>
			<S sid ="813" ssid = "279">2 79.</S>
			<S sid ="814" ssid = "280">6 COR E 12 g+p 73.</S>
			<S sid ="815" ssid = "281">3 91.</S>
			<S sid ="816" ssid = "282">2 7 4 . 6 7 1 . 4 95.</S>
			<S sid ="817" ssid = "283">0 80.</S>
			<S sid ="818" ssid = "284">8 COR E 12 + DET +L MM +PE RSO N +FN *NG g+p 76.</S>
			<S sid ="819" ssid = "285">4 91.</S>
			<S sid ="820" ssid = "286">9 7 7 . 9 7 3 . 2 96.</S>
			<S sid ="821" ssid = "287">2 82.</S>
			<S sid ="822" ssid = "288">7 COR E 12 + DET +L MM +PE RSO N +FN *NG R g+p 76.</S>
			<S sid ="823" ssid = "289">2 91.</S>
			<S sid ="824" ssid = "290">9 7 8 . 1 7 3 . 2 95.</S>
			<S sid ="825" ssid = "291">9 82.</S>
			<S sid ="826" ssid = "292">6 with error reductions between 3.6% and 9.3%, with no apparent patterns.</S>
			<S sid ="827" ssid = "293">(Prepositional modifications even show a slight decline in attachment accuracy).</S>
			<S sid ="828" ssid = "294">This row (using only CORE 12 and training on gold and predicted) now becomes our baseline for subsequent discussion of error reduction.</S>
			<S sid ="829" ssid = "295">If we then add the form-based features, we again find that the error rate decrease for subject, nominal modification, and idafa (the relations affected by agreement and assignment) is greater than that for the other relations; with this training corpus, however, the separation is not as stark, with subject decreasing its error rate by 9.6% and prepositional modification by 8.7%.</S>
			<S sid ="830" ssid = "296">Notably, idafa shows the greatest error rate reduction we have seen so far: 30.2%.</S>
			<S sid ="831" ssid = "297">When we turn to functional features, we again see a further increase in performance across the board.</S>
			<S sid ="832" ssid = "298">And, as expected, the penalty for using the rationality feature disappears because we have trained on predicted features as well.</S>
			<S sid ="833" ssid = "299">In fact the improvement due to rationality specifically benefits the relations affected by agreement and assignment, with subject reducing error by 13.4% now, nominal modification by 14.7%, and idafa by 34.0%.</S>
			<S sid ="834" ssid = "300">The tree on the right in Figure 2 is the parse tree returned by this model, and both the subject and the idafa relation are correctly analyzed.</S>
			<S sid ="835" ssid = "301">Note that the increase in the accuracy of idafa is probably not related to the interaction of syntax and morphology in assignment, because assignment in the idafa construction is not affected by rationality.</S>
			<S sid ="836" ssid = "302">Instead, we suspect that the parser can exploit the very different profile of the rationality feature in the dependent node of the idafa and modification constructions.</S>
			<S sid ="837" ssid = "303">Looking just at nominals, we see in the gold corpus that 62% of the dependents in a modification relation have no inherent rationality (this is the case notably for adjectives), whereas this number for idafa is only 18%.</S>
			<S sid ="838" ssid = "304">In contrast, the dependent of an idafa is irrational 66% of the time, whereas for modification that number is only 16%.</S>
			<S sid ="839" ssid = "305">Finally, we turn to the use of the Easy-First Parser (Section 6).</S>
			<S sid ="840" ssid = "306">The accuracy by relation is shown in Table 17.</S>
			<S sid ="841" ssid = "307">When we switch from MaltParser to Easy-First Parser, we get an overall error reduction of 4.2%, which is reflected fairly evenly among the relations, with two outliers: subjects improve by 9.0%, whereas idafa increases its error rate by 5.5%!</S>
			<S sid ="842" ssid = "308">We do not have an immediate analysis for this behavior, because idafa is usually considered an “easy” relation (no word can intervene between the linked words), as reflected in the high accuracy numbers for this relation.</S>
			<S sid ="843" ssid = "309">Furthermore, when we inspect the unlabeled accuracy scores (not shown here), we see that the unlabeled attachment score for idafa also decreases.</S>
			<S sid ="844" ssid = "310">Thus, we must reject a plausible hypothesis, namely, that the parser gets the relations right but the labeler (which in the Easy-First Parser is a separate, second-pass module) gets the labels wrong.</S>
			<S sid ="845" ssid = "311">When we train the Easy-First Parser on gold and predicted, we see a similar improvement pattern over just training on gold as we did with the MaltParser; one exception is that the idafa relation improves greatly again.</S>
			<S sid ="846" ssid = "312">Finally, we add the functional morphological features (training 188 on gold and predicted).</S>
			<S sid ="847" ssid = "313">Again, the pattern we observe (by comparing error reduction against using Easy-First Parser trained only using CORE 12 on gold and predicted) are very similar to the pattern we observed with the MaltParser in the same conditions.</S>
			<S sid ="848" ssid = "314">One difference stands out, however: whereas the MaltParser can exploit the rationality feature when trained on gold and predicted, the Easy-First Parser cannot.</S>
			<S sid ="849" ssid = "315">Object and prepositional modification perform identically with or without rationality, but subject and idafa perform worse; only nominal modification performs better (with overall performance decreasing).</S>
			<S sid ="850" ssid = "316">If we inspect the unlabeled attachment scores for subjects, we do detect an increase in accuracy (from 85.0% to 85.4%); perhaps the parser can exploit the rationality feature, but the labeler cannot.</S>
			<S sid ="851" ssid = "317">Grammaticality of parse trees.</S>
			<S sid ="852" ssid = "318">We now turn to our second type of error analysis, the evaluation of the grammaticality of the parse trees in terms of gender and number agreement patterns.</S>
			<S sid ="853" ssid = "319">We use the agreement checker code developed by Alkuhlani and Habash (2011) and evaluate our baseline (MaltParser using only CORE 12), best performing model (Easy-First Parser using CORE 12 + DET +LMM+PERSON+FN*NGR g+p), and the gold reference.</S>
			<S sid ="854" ssid = "320">The agreement checker verifies, for all verb–nominal subject relations and noun–adjective relations found in the tree, whether the agreement conditions are met or not.</S>
			<S sid ="855" ssid = "321">The accuracy number reflects the percentage of such relations found which meet the agreement criteria.</S>
			<S sid ="856" ssid = "322">Note that we use the syntax given by the tree, not the gold syntax.</S>
			<S sid ="857" ssid = "323">For all three trees, however, we used gold morphological features for this evaluation even when those features were not used in the parsing task.</S>
			<S sid ="858" ssid = "324">This is because we want to see to what extent the predicted morphological features help find the correct syntactic relations, not whether the predicted trees are intrinsically coherent given possibly false predicted morphology.</S>
			<S sid ="859" ssid = "325">The results can be found in Table 18.</S>
			<S sid ="860" ssid = "326">We note that the grammaticality of the gold corpus is not 100%; this is approximately equally due to errors in the checking script and to annotation errors in the gold standard.</S>
			<S sid ="861" ssid = "327">We take the given grammaticality of the gold corpus as a topline for this analysis.</S>
			<S sid ="862" ssid = "328">Nominal modification has a smaller error band between baseline and gold compared with subject–verb agreement.</S>
			<S sid ="863" ssid = "329">We assume this is because subject–verb agreement is more complex (it depends on their relative order), and because nominal modification can have multiple structural targets, only one of which is correct, although all, however, are plausible from the point of view of agreement.</S>
			<S sid ="864" ssid = "330">The error reduction relative to the gold topline is 62% and 76% for nominal agreement and verb agreement, respectively.</S>
			<S sid ="865" ssid = "331">Thus, we see that our second hypothesis—that the use of morphological features will reduce grammaticality errors in the resulting parse trees with respect to agreement phenomena—is borne out.</S>
			<S sid ="866" ssid = "332">In summary, we see that not only do morphological (and functional morphological features in particular) improve parsing, but they improve parsing in the way Table 18 Analysis of grammaticality of agreement relations between verb and subject and between a noun and a nominal modifier (correct agreement in percent).</S>
			<S sid ="867" ssid = "333">mo del (PO S and mo rph olo gica l feat ure s) noun mo difi er su bject ver b Gol d 9 7 . 8 9 8 . 1 Mal tPar ser usin g COR E 12 9 5 . 2 8 8 . 6 Easy First Pars er usin g COR E 12 + 9 6 . 8 9 5 . 8 DET +LMM +PERSON +FN *NGR g+p 189 that we expect: (a) those relations affected by agreement and assignment contribute more than those that are not, and (b) agreement errors in the resulting parse trees are reduced.</S>
	</SECTION>
	<SECTION title="Conclusions and Future Work. " number = "9">
			<S sid ="868" ssid = "1">We explored the contribution of different morphological features (both inflectional and lexical) to dependency parsing of Arabic.</S>
			<S sid ="869" ssid = "2">Starting with form-based morphological features, we find that definiteness (DET), PERSON, NUMBER, GENDER, and undiacritized lemma (LMM) are most helpful for Arabic dependency parsing on predicted (non- gold) input.</S>
			<S sid ="870" ssid = "3">We further find that functional gender, number, and rationality features (FN*GENDER, FN*NUMBER, RAT) improve over form-based-only morphological features, as expected when considering the complex agreement rules of Arabic.</S>
			<S sid ="871" ssid = "4">To our knowledge, this is the first result in Arabic NLP using functional morphological features, and showing an improvement over form-based features.</S>
			<S sid ="872" ssid = "5">This article presented a large number of results.</S>
			<S sid ="873" ssid = "6">We summarize them next.</S>
			<S sid ="874" ssid = "7">1.</S>
			<S sid ="875" ssid = "8">We observe a tradeoff among the three factors (relevance, redundancy, and ac-.</S>
			<S sid ="876" ssid = "9">curacy) of morphological features in parsing quality.</S>
			<S sid ="877" ssid = "10">The best performing tag set (BW) under the gold condition (i.e., it is very relevant) is worst under the machine- predicted condition, because of its dismal prediction accuracy rate.</S>
			<S sid ="878" ssid = "11">The tag set with highest prediction accuracy (CATIB 6) does not necessarily yield the best results in dependency parsing accuracy, because it is not very relevant.</S>
			<S sid ="879" ssid = "12">A simple extension of CATIB 6, however, that improves its relevance (CATIB EX) but retains sufficient accuracy improves the overall parsing quality.</S>
			<S sid ="880" ssid = "13">2.</S>
			<S sid ="881" ssid = "14">Lexical features do help parsing, and the most helpful in predicted condition is. the undiacritized lemma (LMM) feature.</S>
			<S sid ="882" ssid = "15">Although LMM is more ambiguous than the diacritized LEMMA feature, it has half the error rate of LEMMA which makes it a more reliable (accurate) feature.</S>
			<S sid ="883" ssid = "16">When using LMM, LEMMA is highly redundant (and vice versa).</S>
			<S sid ="884" ssid = "17">3.</S>
			<S sid ="885" ssid = "18">GENDER and NUMBER and their functional variants are the most useful for parsing.</S>
			<S sid ="886" ssid = "19">in predicted condition.</S>
			<S sid ="887" ssid = "20">This is a result of their high relevance and their high prediction accuracy.</S>
			<S sid ="888" ssid = "21">In contrast, CASE and STAT E are the best performers in the gold condition (i.e., highly relevant) but not in the predicted condition (where CASE is actually the worst feature).</S>
			<S sid ="889" ssid = "22">The rationality (RAT) feature is more helpful in the gold condition, which suggests it is relevant; its associated parsing results in predicted condition are not as good, however.</S>
			<S sid ="890" ssid = "23">Presumably, this is because of its lower prediction accuracy.</S>
			<S sid ="891" ssid = "24">4.</S>
			<S sid ="892" ssid = "25">When evaluating in the machine-predicted input condition, training on data with.</S>
			<S sid ="893" ssid = "26">gold and predicted morphological features (g+p training) consistently improves results over training on gold.</S>
			<S sid ="894" ssid = "27">This novel technique most likely addresses the negative effect of feature prediction error by introducing the common errors to the parsing model in training.</S>
			<S sid ="895" ssid = "28">A side effect of it is that using correct predictions by the parser is reinforced, because constructions with correctly predicted values appear twice as often in g+p training.</S>
			<S sid ="896" ssid = "29">5.</S>
			<S sid ="897" ssid = "30">All of these results carry over successfully to another parser (Easy-First Parser),.</S>
			<S sid ="898" ssid = "31">suggesting the insights are not specific to MaltParser.</S>
			<S sid ="899" ssid = "32">190 6.</S>
			<S sid ="900" ssid = "33">Our best model was trained with the Easy-First Parser, containing the follow-.</S>
			<S sid ="901" ssid = "34">ing features: CORE 12+DET +LMM+PERSON+FN*NGR, with g+p feature values for training.</S>
			<S sid ="902" ssid = "35">We make this model available, together with the source code.23 Although we only experimented with Arabic dependency parsing, we believe that the evaluation framework we presented and many of our conclusions will carry over to other languages (particularly, Semitic and morphology-rich languages) and syntactic representations (e.g., phrase structure).</S>
			<S sid ="903" ssid = "36">Some of our conclusions are more language independent (e.g., those involving the use of predicted training conditions).</S>
			<S sid ="904" ssid = "37">In future work, we intend to improve the prediction of functional morphological features—especially RAT—in order to improve dependency parsing accuracy in predicted condition.</S>
			<S sid ="905" ssid = "38">We also intend to investigate how these features can be integrated into other parsing frameworks; we expect them to help independently of the framework.</S>
			<S sid ="906" ssid = "39">The ability to represent the relevant morphological information in a manner that is useful to attachment decisions is, of course, crucial to improving parsing quality.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="907" ssid = "40">This work was supported by the DARPA GALE program, contract HR001108-C-0110.</S>
			<S sid ="908" ssid = "41">Y. Marton performed most of the work on this paper while he was at the Center for Computational Learning Systems at Columbia University and at the IBM Watson Research Center.</S>
			<S sid ="909" ssid = "42">We thank Joakim Nivre for his useful remarks, Ryan Roth for his help with MADA, and Sarah Alkuhlani for her help with functional features.</S>
			<S sid ="910" ssid = "43">We also thank three anonymous reviewers for thoughtful comments.</S>
	</SECTION>
</PAPER>
