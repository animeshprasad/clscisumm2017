<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">We inspect the viability of finite-state spell- checking and contextless correction of non- word errors in three languages with a large degree of morphological variety.</S>
		<S sid ="2" ssid = "2">Overviewing previous work, we conduct large-scale tests involving three languages — English, Finnish and Greenlandic — and a variety of error models and algorithms, including proposed improvements of our own.</S>
		<S sid ="3" ssid = "3">Special reference is made to online three-way composition of the input, the error model and the language model.</S>
		<S sid ="4" ssid = "4">Tests are run on real-world text acquired from freely available sources.</S>
		<S sid ="5" ssid = "5">We show that the finite-state approaches discussed are sufficiently fast for high-quality correction, even for Greenlandic which, due to its morphological complexity, is a difficult task for non-finite-state approaches.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="6" ssid = "6">In most implementations of spell-checking, efficiency is a limiting factor for selecting or discarding spell-checking solutions.</S>
			<S sid ="7" ssid = "7">In the case of finite finite-state implementations that both detect and correct errors (Schulz and Mihov, 2002; Pirinen and Linde´n, 2010).</S>
			<S sid ="8" ssid = "8">In this paper we further evaluate the use of finite-state dictionaries with two-tape finite- state automatons as a mechanism for correcting misspellings, and optimisations to the finite-state error models, intending to demonstrate that purely finite- state algorithms can be made sufficiently efficient.</S>
			<S sid ="9" ssid = "9">To evaluate the general usability and efficiency of finite-state spell-checking we test a number of possible implementations of such a system with three languages of typologically different morphological features2 and reference implementations for contemporary spell-checking applications: English as a morphologically more isolating language with essentially a word-list approach to spell-checking; Finnish, whose computational complexity has been just beyond the edge of being too hard to implement nicely in eg.</S>
			<S sid ="10" ssid = "10">hunspell (Pitka¨nen, 2006); and Green- landic, a polysynthetic language which is implemented as a finite-state system using Xerox’s original finite-state morphology formalism (Beesley and Karttunen, 2003).</S>
			<S sid ="11" ssid = "11">As a general purpose finite-state library we use HFST3, which also contains our spell state spell-checking it is known that finite-state language models can efficiently encode dictionaries of natural languages (Beesley and Karttunen, 2003), even for polysynthetic languages.</S>
			<S sid ="12" ssid = "12">Most contemporary spell-checking and correction systems are still based on programmatic solutions (e.g. hunspell1, and its *spell relatives), or at most specialised algorithms for implementing error-tolerant traversal of the finite-state dictionaries (Oflazer, 1996; Hulde´n, 2009a).</S>
			<S sid ="13" ssid = "13">There have also been few fully 1 http://hunspell.sf.net tures of these languages.</S>
			<S sid ="14" ssid = "14">We thank the anonymous reviewer for guiding us to make a rough comparison using a piece of translated text.</S>
			<S sid ="15" ssid = "15">We observe from the translations of the Universal Declaration of Human Rights (with preamble included) as follows: the number of word-like tokens for English is 1,746, for Finnish 1,275 and for Greenlandic 1,063.</S>
			<S sid ="16" ssid = "16">The count of the 15 most frequent tokens are for English 120—28, for Finnish 85— 10 and for Greenlandic 38—7.</S>
			<S sid ="17" ssid = "17">The average word length is 5.0 characters for English, 7.8 for Finnish and 14.9 for Greenlandic.</S>
			<S sid ="18" ssid = "18">For the complexity of computational models refer to Table 2 in this article.</S>
			<S sid ="19" ssid = "19">3 http://hfst.sf.net 1 Proceedings of the 10th International Workshop on Finite State Methods and Natural Language Processing, pages 1–9, Donostia–San Sebastia´n, July 23–25, 2012.</S>
			<S sid ="20" ssid = "20">Qc 2012 Association for Computational Linguistics checking code.</S>
			<S sid ="21" ssid = "21">As neither Finnish nor Greenlandic have been successfully implemented in the hunspell formalism, we mainly use them to evaluate how the complexity of a language model affects the efficiency of finite-state spell-checking.</S>
			<S sid ="22" ssid = "22">For a full-scale survey on the state-of-the-art non-finite-state spell-checking, refer to Mitton (2009).</S>
			<S sid ="23" ssid = "23">The efficiency results are contrasted with the existing research on finite-state spell-checking in Has- san et al.</S>
			<S sid ="24" ssid = "24">(2008) and the theoretical results on finite- state error-models in Mitankin (2005).</S>
			<S sid ="25" ssid = "25">Our contribution primarily comprises the addition of morphologically complex languages with actual cyclic dictionary automata (i.e. infinite dictionaries formed by compounding and recurring derivation) and more complex structure in general, compared to those of English and Arabic.</S>
			<S sid ="26" ssid = "26">Our goal is to demonstrate that finite-state spelling is tractable for these complex the language, and one automaton to map misspelt words into correct strings, or the error model.</S>
			<S sid ="27" ssid = "27">Both the language model and the error model are usually (Pirinen and Linde´n, 2010) weighted finite-state automata, where the weights represent the probabilities are of a word being correctly spelled in the language model and of specific misspellings, respectively.</S>
			<S sid ="28" ssid = "28">We evaluate here the effect of both the language and error model automatons’ structure and complexity on the efficiency of the finite-state spelling task.4 2.1 Language Models.</S>
			<S sid ="29" ssid = "29">The most basic language model for a spell-checking dictionary is a list of correctly spelled word forms.</S>
			<S sid ="30" ssid = "30">One of the easiest ways of creating such a spell- checker is to collect the word forms from a reasonably large corpus of (mostly) correctly spelt texts.</S>
			<S sid ="31" ssid = "31">Additionally we can count the frequency of wordslanguages, to document their implications for per and use that as the likelihood, P (w) = c(w) w∈D c(w) formance and to present an algorithm for the task.</S>
			<S sid ="32" ssid = "32">We also point out that previous approaches have neglected to simultaneously constrain the error model and the dictionary with each other in online composition, which affords a significant speed benefit compared to generating the two component compositions.</S>
			<S sid ="33" ssid = "33">The rest of the paper is organised as follows.</S>
			<S sid ="34" ssid = "34">In Section 2 we discuss the spell-checking task, current non-finite-state spell-checkers and previously used finite-state methods for spell-checking and correction and propose some possible speed optimisations for the error models.</S>
			<S sid ="35" ssid = "35">We also investigate algorithmic limitations of finite-state approaches and ways to remedy them.</S>
			<S sid ="36" ssid = "36">In Section 3 we present the language models, error models and the testing corpora.</S>
			<S sid ="37" ssid = "37">In Section 4 we present the comparisons of speed and quality with combinations of different language and error models and corpora for spell-checking.</S>
			<S sid ="38" ssid = "38">In Section 5 we summarise our findings and results, and outline future goals.</S>
	</SECTION>
	<SECTION title="Methods. " number = "2">
			<S sid ="39" ssid = "1">A finite-state spell-checker is typically (Pirinen and Linde´n, 2010) composed of at least two finite-state automata; one for the dictionary of the language, or the language model, which contains valid strings of where c(w) is the count of the word w and D is the set of corpus word forms.</S>
			<S sid ="40" ssid = "2">For morphologically more isolating languages such as English, this is often a sufficient approach (Norvig, 2010), and we use it to create a dictionary for our English spell-checker as well.</S>
			<S sid ="41" ssid = "3">As a non-finite-state reference point we use hunspell.</S>
			<S sid ="42" ssid = "4">For agglutinative languages like Finnish, for which the word-list approach is likely to miss a much greater number of words, one of the most common approaches is to use right-linear grammars, possibly combined with finite-state rule languages to implement morphophonological alterations (Koskenniemi, 1983).</S>
			<S sid ="43" ssid = "5">This approach also applies to the newest available free / open source and full-fledged finite-state Finnish morphological dictionary we found (Pirinen, 2011).</S>
			<S sid ="44" ssid = "6">This language model features productive derivations, compounding and rudimentary probabilistic models.</S>
			<S sid ="45" ssid = "7">We take, as a reference non-finite state language model for Finnish, Voikko’s implementation in Malaga, which is currently used as a spell-checking component in open source software.</S>
			<S sid ="46" ssid = "8">It is implemented in a 4 The methods introduced in this research as well as all materials are free/libre open source.</S>
			<S sid ="47" ssid = "9">Please see our svn repository https://hfst.svn.sf.net/svnroot/trunk/ fsmnlp2012-spellers/ for detailed implementation and scripts to reproduce all the results.</S>
			<S sid ="48" ssid = "10">left-associative grammar formalism, which is a potentially less efficient system with more expressive power.</S>
			<S sid ="49" ssid = "11">It’s similar to finite-state formulations in terms of linguistic coverage.</S>
			<S sid ="50" ssid = "12">For polysynthetic languages it will be obvious that the coverage of any word-list-based approach will be even lower.</S>
			<S sid ="51" ssid = "13">Furthermore, most simple extensions to it such as affix stripping (as in hun- spell) are not adequate for describing word forms.</S>
			<S sid ="52" ssid = "14">To our knowledge, the only approaches that have been widely used for spell-checking and morphological analysis of Greenlandic have been based on traditional finite-state solutions, such as the Xerox formalisms.</S>
			<S sid ="53" ssid = "15">In our case we have obtained a freely available finite-state morphology implementation from the Internet5.</S>
			<S sid ="54" ssid = "16">For further details we refer to the authors’ website http:// oqaaserpassualeriffik.org/.</S>
			<S sid ="55" ssid = "17">2.2 Error Models.</S>
			<S sid ="56" ssid = "18">The ubiquitous formula for modeling typing errors since computer-assisted spelling correction began has been the edit distance metric sometimes attributed to Levenshtein (1966) and/or Damerau (1964).</S>
			<S sid ="57" ssid = "19">It maps four typical slips of the fingers on a keyboard to events in the fuzzy matching of misspelt word forms to correct ones, that is, the deletion of a character (i.e. failing to press a key), addition of a character (i.e. hitting an extra key accidentally), changing a character (i.e. hitting the wrong key) and transposing adjacent characters (i.e. hitting two keys in the wrong order).</S>
			<S sid ="58" ssid = "20">When modeling edit distance as a finite-state automaton, a relatively simple two-tape automaton is sufficient to implement the algorithm (Hassan et al., 2008).</S>
			<S sid ="59" ssid = "21">The automaton will consist of one arc for each type of error, and additionally one state for each transposition pair.</S>
			<S sid ="60" ssid = "22">This means that the trivial nondetermistic finite-state automaton implementing the algorithm is of space complexity S(V, E, Σ) = To further fine-tune this finite-state formulation of the edit distance algorithm, it is possible to attach a probability to each of the error events as a weight in a weighted finite-state automaton, corresponding to the likelihood of an error, or a confusion factor.</S>
			<S sid ="61" ssid = "23">This can be used to implement features like keyboard adjacency or an OCR confusion factor to the error correction model.</S>
			<S sid ="62" ssid = "24">This will not modify the structure of the finite-state error models or the search space—which is why we did not test their effects in this article—, but introduction of non-homogenous weights to the resulting finite-state network may have an effect on search time.</S>
			<S sid ="63" ssid = "25">This addition is equivalent to hunspell’s KEY mechanism.</S>
			<S sid ="64" ssid = "26">For English language spelling correction there is also an additional type of error model to deal with competence-related misspellings—as opposed to models that mainly deal with mistypings— implemented in the form of phonemic folding and unfolding.</S>
			<S sid ="65" ssid = "27">This type of error is very specific to certain types of English text and is not in the scope of this experiment.</S>
			<S sid ="66" ssid = "28">This is the PHON part of the hun- spell’s correction mechanism.</S>
			<S sid ="67" ssid = "29">After fine-tuning the error models to reimplement hunspell’s feature set, we propose variations of this edit distance scheme to optimise the speed of error correction with little or no negative effect to the quality of the correction suggestions.</S>
			<S sid ="68" ssid = "30">The time requirement of the algorithm is determined by the size of the search space, i.e. the complexity of the resulting network when the error model is applied to the misspelt string and intersected with the dictionary6.</S>
			<S sid ="69" ssid = "31">To optimise the application of edit distance by limiting the search space, many traditional spell checkers will not attempt to correct the very first letter of the word form.</S>
			<S sid ="70" ssid = "32">We investigated whether this decision is a particularly effective way to limit the search space, but it does not appear to significantly differ from restricting edits at any other position in the input.</S>
			<S sid ="71" ssid = "33">Dividing the states of a dictionary automaton into O(|Σ|2|V | + |Σ|2|E|), where Σ is the alphabet of 6 For non-finite-state solutions, the search space is simply.</S>
			<S sid ="72" ssid = "34">language, V is the set vertices in automaton and E is the set of edges in automaton.</S>
			<S sid ="73" ssid = "35">This edit distance formulation is roughly feature equivalent to hunspell’s TRY mechanism.</S>
			<S sid ="74" ssid = "36">5 https://victorio.uit.no/langtech/trunk/ st/kal the number of possible strings given the error corrections made in the algorithm.</S>
			<S sid ="75" ssid = "37">For finite-state systems the amount of generated strings with cyclic language and error models is infinite, so complexity calculation are theoretically slightly more complex, however for basic edit distance implementations used in this article the search space complexities are always the same and the amount of suggestions generated finite classes corresponding to the minimum number of input symbols consumed by that state, we found that the average ambiguity in a particular class is somewhat higher for the first input symbols, but then stabilises quickly at a lower level.</S>
			<S sid ="76" ssid = "38">This was accomplished by performing the following state- categorisation procedure: 1.</S>
			<S sid ="77" ssid = "39">The start state is assigned to class 0, and all.</S>
			<S sid ="78" ssid = "40">other states are assigned to a candidate pool.</S>
			<S sid ="79" ssid = "41">2.</S>
			<S sid ="80" ssid = "42">All states to which there is an (input) epsilon.</S>
			<S sid ="81" ssid = "43">transition from the start state are assigned to class 0 and removed from the candidate pool.</S>
			<S sid ="82" ssid = "44">no more states are added to class 0.</S>
			<S sid ="83" ssid = "45">This completes class 0 as the set of states in which the automaton can be before consuming any input.</S>
			<S sid ="84" ssid = "46">4.</S>
			<S sid ="85" ssid = "47">For each state in class 0, states in the candidate.</S>
			<S sid ="86" ssid = "48">pool to which there is a non-epsilon transition are assigned to class 1 and removed from the candidate pool.</S>
			<S sid ="87" ssid = "49">5.</S>
			<S sid ="88" ssid = "50">Class 1 is epsilon-completed as in (23)..</S>
			<S sid ="89" ssid = "51">6.</S>
			<S sid ="90" ssid = "52">After the completion of class n, class n + 1.</S>
			<S sid ="91" ssid = "53">is constructed.</S>
			<S sid ="92" ssid = "54">This continues until the candidate pool is empty, which will happen as long as there are no unreachable states.</S>
			<S sid ="93" ssid = "55">With this categorisation, we tallied the total number of arcs from states in each class and divided the total by the number of states in the class.</S>
			<S sid ="94" ssid = "56">This is intended as an approximate measure of the ambiguity present at a particular point in the input.</S>
			<S sid ="95" ssid = "57">Some results are summarized in Table 1.</S>
			<S sid ="96" ssid = "58">Cla ss Tra nsi tio ns States Average 0 1 2 3 4 5 6 7 8 9 10 11 12 1 5 6 3 5 2 1 , 0 1 5 1 0 9 9 . 3 6 , 4 3 9 1 , 0 2 9 6 . 3 2 2 , 4 3 6 5 , 7 8 0 3 . 9 3 8 , 8 9 9 1 2 , 7 8 5 3 . 0 4 4 , 9 7 3 1 5 , 4 8 1 2 . 9 4 7 , 8 0 8 1 7 , 0 1 4 2 . 8 4 7 , 4 9 5 1 8 , 8 6 6 2 . 5 3 9 , 8 3 5 1 7 , 0 0 0 2 . 3 3 6 , 7 8 6 1 4 , 3 0 4 2 . 6 4 5 , 0 9 2 1 4 , 6 3 3 3 . 1 6 6 , 5 9 8 2 2 , 0 0 7 3 . 0 8 6 , 2 0 6 3 0 , 0 1 7 2 . 9 Table 1: State classification by minimum input consumed for the Finnish dictionary Further, the size of a dictionary automaton that is restricted to have a particular symbol in a particular position does not apparently depend on the choice of position.</S>
			<S sid ="97" ssid = "59">This result was acquired by intersecting eg.</S>
			<S sid ="98" ssid = "60">the automaton e.+ with the dictionary to restrict the first position to have the symbol e, the automaton .e.+ to restrict the second position, and so on.</S>
			<S sid ="99" ssid = "61">The transducers acquired by this intersection vary in size of the language, number of states and number of transitions, but without any trend depending on the position of the restriction.</S>
			<S sid ="100" ssid = "62">This is in line with the rather obvious finding that the size of the restricted dictionary in terms of number of strings is similarily position-agnostic.</S>
			<S sid ="101" ssid = "63">Presumably, the rationale is a belief that errors predominately occur at other positions in the input.</S>
			<S sid ="102" ssid = "64">As far as we know, the complete justification for this belief remains to be made with a high-quality, hand- checked error corpus.</S>
			<S sid ="103" ssid = "65">On the error model side this optimisation has been justified by findings where between 1.5 % and 15 % of spelling errors happen in the first character of the word, depending on the text type (Bhagat, 2007); the 1.5 % from a small corpus of academic texts (Yannakoudakis and Fawthrop, 1983) and 15 % from dictated corpora (Kukich, 1992).</S>
			<S sid ="104" ssid = "66">We also performed a rudimentary classification of the errors in the small error corpus of 333 entries from Pirinen et al.</S>
			<S sid ="105" ssid = "67">(2012), and found errors at the first position in 1.2 % of the entries.</S>
			<S sid ="106" ssid = "68">Furthermore, we noticed that when evenly splitting the word forms in three parts, 15 % of the errors are in the first third of the word form, while second has 47 % and third 38 %, which would be in favor of discarding initial errors7.</S>
			<S sid ="107" ssid = "69">A second form of optimisation that is used by many traditional spell-checking systems is to apply a lower order edit distance separately before trying higher order ones.</S>
			<S sid ="108" ssid = "70">This is based on the assumption that the vast majority of spelling errors will be of lower order.</S>
			<S sid ="109" ssid = "71">In the original account of edit distance for spell-checking, 80 % of the spelling errors were found to be correctable with distance 1 (Pollock and Zamora, 1984).</S>
			<S sid ="110" ssid = "72">The third form of optimisation that we test is omitting redundant corrections in error models of higher order than one.</S>
			<S sid ="111" ssid = "73">Without such an optimisa 7 By crude classification we mean that all errors were forced to one of the three classes at weight of one, e.g. a series of three consecutive instances of the same letters was counted as deletion at the first position.</S>
			<S sid ="112" ssid = "74">tion, higher order error models will permit adding and deleting the same character in succession at any position, which is obviously futile work for error correction.</S>
			<S sid ="113" ssid = "75">Performing the optimisation makes the error model larger but reduces the search space, and does not affect the quality of results.</S>
			<S sid ="114" ssid = "76">2.3 Algorithms.</S>
			<S sid ="115" ssid = "77">The obvious baseline algorithm for the task of finding which strings can be altered by the error model in such a way that the alteration is present in the language model is generating all the possible alterations and checking which ones are present in the language model.</S>
			<S sid ="116" ssid = "78">This was done in Hassan et al.</S>
			<S sid ="117" ssid = "79">(2008) by first calculating the composition of the input string with the error model and then composing the result with the language model.</S>
			<S sid ="118" ssid = "80">If we simplify the error model to one in which only substitutions occur, it can already be seen that this method is quite sensitive to input length and alphabet size.</S>
			<S sid ="119" ssid = "81">The composition explores each combination of edit sites in the input string.</S>
			<S sid ="120" ssid = "82">If any number of edits up to d can be made at positions in an input string of length n, there are 100, 215 different outputs.</S>
			<S sid ="121" ssid = "83">We have implemented this algorithm for our results by generating the edited strings by lookup, and performing another lookup with the language model on these strings.</S>
			<S sid ="122" ssid = "84">Plainly, it would be desirable to improve on this.</S>
			<S sid ="123" ssid = "85">The intuition behind our improvement is that when editing an input string, say “spellling”, it is a wasted effort to explore the remainder after generating a prefix that is not present in the lexicon.</S>
			<S sid ="124" ssid = "86">For example, after changing the first character to “z” and not editing the second characted, we have the prefix “zp-”, which does not occur in our English lexicon.</S>
			<S sid ="125" ssid = "87">So the remaining possibilities - performing any edits on the remaining 7-character word - can be ignored.</S>
			<S sid ="126" ssid = "88">This is accomplished with a three-way composition in which the input, the error model and the language model simultaneously constrain each other to produce the legal correction set.</S>
			<S sid ="127" ssid = "89">This algorithm is presented in some detail in Linde´n et al.</S>
			<S sid ="128" ssid = "90">(2012).</S>
			<S sid ="129" ssid = "91">A more advanced and general algorithm is due to Allauzen and Mohri (2009).</S>
	</SECTION>
	<SECTION title="Material. " number = "3">
			<S sid ="130" ssid = "1">For language models we have acquired suitable free d i=1 n i to-use dictionaries, readily obtainable on the Internet.</S>
			<S sid ="131" ssid = "2">We made our own implementations of the al ways to choose the edit site, and each site is subject to a choice of |Σ|−1 edits (the entire alphabet except for the actual input).</S>
			<S sid ="132" ssid = "3">This expression has no closed form, but as d grows to n, the number of choices has the form 2n, so the altogether complexity is exponential in input length and linear in alphabet size (quadratic if transpositions are considered).</S>
			<S sid ="133" ssid = "4">In practice (when d is small relative to n) it is useful to observe that an increase of 1 in distance results in an additional term to the aforementioned sum, the ratio of which to the previously greatest term is gorithms to create and modify finite-state error models.</S>
			<S sid ="134" ssid = "5">Our source repository contains a Python script for generating error models and an extensive Makefile for exercising it in various permutations.</S>
			<S sid ="135" ssid = "6">To test the effect of correctness of the source text to the speed of the spell-checker we have retrieved one of largest freely available open source text materials from the Internet, i.e. Wikipedia.</S>
			<S sid ="136" ssid = "7">The Wikipedia text is an appropriate real-world material as it is a large body of text authored by many individuals, and may be expected to contain a wide variety n!/(d! · (n − d!)) n!/((d − 1)!</S>
			<S sid ="137" ssid = "8">· (n − d + 1)!)</S>
			<S sid ="138" ssid = "9">n d + 1 = d of spelling errors.</S>
			<S sid ="139" ssid = "10">For material with more errors, we have used a simple script to introduce (further, ar indicating that when d is small, increases in it produce an exponential increase in complexity.</S>
			<S sid ="140" ssid = "11">For an English 26-letter lowercase alphabet, edit distance 2 and the 8-letter word “spelling”, 700 strings are stored in a transducer.</S>
			<S sid ="141" ssid = "12">With transpositions, deletions, insertions and edit weights this grows to bitrary) errors at a uniform probability of 1/33 per character; using this method we can also obtain a corpus of errors with correct corrections along them.</S>
			<S sid ="142" ssid = "13">Finally we have used a text corpus from a language different than the one being spelled to ensure that the majority of words are not in the vocabulary and (al most always) not correctable by standard error models.</S>
			<S sid ="143" ssid = "14">The Wikipedia corpora were sourced from wikimedia.org.</S>
			<S sid ="144" ssid = "15">For exact references, see our previously mentioned repository.</S>
			<S sid ="145" ssid = "16">From the dumps we extracted the contents of the articles and picked the first 100,000 word tokens for evaluation.</S>
			<S sid ="146" ssid = "17">In Table 2 we summarize the sizes of automata in terms of structural elements.</S>
			<S sid ="147" ssid = "18">On the first row, we give the size of the alphabet needed to represent the entire dictionary.</S>
			<S sid ="148" ssid = "19">Next we give the sizes of automata as nodes and arcs of the finite-state automaton encoding the dictionary.</S>
			<S sid ="149" ssid = "20">Finally we give the size of the automaton as serialised on the hard disk.</S>
			<S sid ="150" ssid = "21">While this is not the same amount of memory as its loaded data structures, it gives some indication of memory usage of the program while running the automaton in question.</S>
			<S sid ="151" ssid = "22">As can be clearly seen from the table, the morphologically less isolating languages do fairly consistently have larger automata in every sense.</S>
			<S sid ="152" ssid = "23">Au to ma ton E n F i K l Σ set siz e Di cti on ar y F S M n o d es Di cti on ar y F S M ar cs Di cti on ar y F S M on di sk 4 3 1 1 7 1 3 3 4 9, 7 7 8 286,719 628,177 8 6, 5 2 3 783,461 11,596,911 2.3 Mi B 43 MiB 290 MiB Table 2: The sizes of dictionaries as automata In Table 3 we give the same figures for the sizes of error models we’ve generated.</S>
			<S sid ="153" ssid = "24">The Σ size row here shows the number of symbols left when we have removed the symbols that are usually not considered to be a part of a spell-checking mechanism, such as all punctuation that does not occur word-internally and white-space characters8.</S>
			<S sid ="154" ssid = "25">Note that sizes of error models can be directly computed from their parameters; i.e., the distance, the Σ set size and the optimisation, so this table is provided for reference only.</S>
	</SECTION>
	<SECTION title="Evaluation. " number = "4">
			<S sid ="155" ssid = "1">We ran various combinations of language and error models on the corpora described in section 3.</S>
			<S sid ="156" ssid = "2">We give tabular results of the speed of the system and the effect of the error model on recall.</S>
			<S sid ="157" ssid = "3">The latter 8 The method described here does not handle run-on words or extraneous spaces, as they introduce lot of programmatic complexity which we believe is irrelevant to the results of this experiment.</S>
			<S sid ="158" ssid = "4">Au to ma ton E n Fi Kl Σ set siz e E d i t d i s t a n c e 1 n o d e s E d i t d i s t a n c e 1 a r c s E d i t d i s t a n c e 2 n o d e s E d i t d i s t a n c e 2 a r c s N o f i r s t s e d 1 n o d e s N o f i r s t s e d 1 a r c s No first s ed 2 no de s No first s ed 2 arc s N o re du nd an cy an d 1s t ed 2 no de s N o re du nd an cy an d 1s t ed 2 ar cs Lo w er or de r fir st ed 1 to 2 ar cs Lo w er or de r fir st ed 1 to 2 n o d es 2 8 60 64 6 5 2 3,308 3,784 2, 08 1 10,209 11,657 1, 30 3 6,615 7,567 4 1 3 6 20,360 23,252 6 5 2 3,308 3,784 2, 10 7 10,267 11,719 1, 30 3 6,615 7,567 4, 16 2 20,418 23,314 1, 30 3 6,615 7,567 4, 16 2 20,418 23,314 6, 21 7 30,569 34,909 1, 95</S>
	</SECTION>
	<SECTION title="9,923	11,351" number = "5">
			<S sid ="159" ssid = "1">Table 3: The sizes of error models as automata is to establish that simpler error models lead to degraded recall—and not to more generally evaluate the present system as a spell-checker.</S>
			<S sid ="160" ssid = "2">The evaluations in this section are performed on quad-core Intel Xeon E5450 running at 3 GHz with 64 GiB of RAM memory.</S>
			<S sid ="161" ssid = "3">The times are averaged.</S>
			<S sid ="162" ssid = "4">over five test runs of 10,000 words in a stable server environment with no server processes or running graphical interfaces or other uses.</S>
			<S sid ="163" ssid = "5">The test results are measured using the getrusage C function on a system that supports the maximum resident stack size ru maxrss and user time ru utime fields.</S>
			<S sid ="164" ssid = "6">The times are also verified with the GNU time command.</S>
			<S sid ="165" ssid = "7">The results for hunspell, Voikkospell and foma processes are only measured with time and top.</S>
			<S sid ="166" ssid = "8">The respective versions of the software are Voikkospell 3.3, hunspell 1.2.14, and Foma 0.9.16alpha.</S>
			<S sid ="167" ssid = "9">The reference systems are tested with default settings, meaning that they will only give some fixed number of suggestions whereas our system will calculate all strings within the given error model.</S>
			<S sid ="168" ssid = "10">As a reference implementation for English we use hunspell’s en-US dictionary9 and for a finite-state implementation we use a weighted word-list from Norvig (2010).</S>
			<S sid ="169" ssid = "11">As a Finnish reference implementation we use Voikko10, with a LAG-based dictionary using Malaga11.</S>
			<S sid ="170" ssid = "12">The reference correction task for Greenlandic is done with foma’s (Hulde´n, 2009b) 9 http://wiki.services.openoffice.org/ wiki/Dictionaries 10 http://voikko.sf.net 11 http://home.arcor.de/bjoernbeutel/ malaga/ apply med function with default settings12.</S>
			<S sid ="171" ssid = "13">The baseline feature set and the efficiency of spell-checking we are targeting is defined by the currently de facto standard spelling suite in open source systems, hunspell.</S>
			<S sid ="172" ssid = "14">In Table 4 we measure the speed of the spell- checking process on native language Wikipedia text with real-world spelling errors and unknown strings.</S>
			<S sid ="173" ssid = "15">The error model rows are defined as follows: on the Reference impl.</S>
			<S sid ="174" ssid = "16">row, we test the spell- checking speed of the hunspell tool for English, and Voikkospell tool for Finnish.</S>
			<S sid ="175" ssid = "17">On the edit distance 2 row we use the basic traditional edit distance 2 without any modifications.</S>
			<S sid ="176" ssid = "18">On the No first edits row we use the error model that does not modify the first character of the word.</S>
			<S sid ="177" ssid = "19">On the No redundancy row we use the edit distance 2 error model with the redundant edit combinations removed.</S>
			<S sid ="178" ssid = "20">On the No redundancy and firsts rows we use the combined error model of No first edits and No redundancy functionalities.</S>
			<S sid ="179" ssid = "21">On the row Lower order first we apply a lower order edit distance model first, then if no results are found, a higher order model is used.</S>
			<S sid ="180" ssid = "22">In the tables and formulae we routinely use the language codes to denote the languages: en for English, fi for Finnish and kl for Greenlandic (Kalaallisut).</S>
			<S sid ="181" ssid = "23">of error models gives the expected timing result between its relevant primary and secondary error models.</S>
			<S sid ="182" ssid = "24">It should be noteworthy that, when thinking of real world applications, the speed of the most of the models described here is greater than 1 word per second (i.e. 10,000 seconds per 10,000 words).</S>
			<S sid ="183" ssid = "25">We measured memory consumption when performing the same tests.</S>
			<S sid ="184" ssid = "26">Varying the error model had little to no effect.</S>
			<S sid ="185" ssid = "27">Memory consumption was almost entirely determined by the language model, giving consumptions of 137 MiB for English, 0.2 GiB for Finnish and 1.6 GiB for Greenlandic.</S>
			<S sid ="186" ssid = "28">To measure the degradation of quality when using different error models we count the proportion of suggestion sets that contain the correct correction among the corrected strings.</S>
			<S sid ="187" ssid = "29">The suggestion sets are the entire (unrestricted by number) results of correction, with no attempt to evaluate precision13.</S>
			<S sid ="188" ssid = "30">For this test we use automatically generated corpus of spelling errors to get the large-scale results.</S>
			<S sid ="189" ssid = "31">Error model En Fi Kl Edit distance 1 0.89 0.83 0.81 Edit distance 2 0.99 0.95 0.92 Edit distance 3 1.00 0.96 — No firsts ed 1 0.74 0.73 0.60 No firsts ed 2 0.81 0.82 0.69 No firsts ed 3 0.82 — — Table 5: Effect of language and error models to quality (recall, proportion of suggestion sets containing a correctly suggested word) Table 4: Effect of language and error models to speed (time in seconds per 10,000 word forms) The results show that not editing the first position does indeed give significant boost to the speed, regardless of language model, which is of course caused by the significant reduction in search space.</S>
			<S sid ="190" ssid = "32">However, the redundancy avoidance does not seem to make a significant difference.</S>
			<S sid ="191" ssid = "33">This is most likely because the amount of duplicate paths in the search This test with automatically introduced errors shows us that with uniformly distributed errors the penalty of using an error model that ignores word- initial corrections could be significant.</S>
			<S sid ="192" ssid = "34">This contrasts to our findings with real world errors, that the distribution of errors tends towards the end of the word, described in 2.2 and (Bhagat, 2007), but it should be noted that degradation can be as bad as given here.</S>
			<S sid ="193" ssid = "35">Finally we measure how the text type used will affect the speed of spell-checking.</S>
			<S sid ="194" ssid = "36">As the best-case scenario we use the unmodified texts of Wikipedia, which contain probably the most realistic native-language-speaker-like typing error dis space is not so proportionally large and their traver13 Which, in the absence of suitable error corpora and a more.</S>
			<S sid ="195" ssid = "37">sal will be relatively fast.</S>
			<S sid ="196" ssid = "38">The separate application 12 http://code.google.com/p/Foma/ full-fledged language model taking context into account, would be irrelevant for the goal at hand.</S>
			<S sid ="197" ssid = "39">tribution available.</S>
			<S sid ="198" ssid = "40">For text with more errors, where the majority of errors should be recoverable, we introduce automatically generated errors in the Wikipedia texts.</S>
			<S sid ="199" ssid = "41">Finally to see the performance in the worst case scenario where most of the words have unrecoverable spelling errors we use texts from other languages, in this case English texts for Finnish and Greenlandic spell-checking and Finnish texts for English spell-checking, which should bring us close to the lower bounds on performance.</S>
			<S sid ="200" ssid = "42">The effects of text type (i.e. frequency of non-words) on speed of spell-checking is given in Table 6.</S>
			<S sid ="201" ssid = "43">All of the tests in this category were performed with error models under the avoid redundancy and firsts ed 2 row in previous tables, which gave us the best speed/quality ratio.</S>
			<S sid ="202" ssid = "44">Err or mo del E n Fi Kl Nat ive Lan g. Co rpu s Add ed aut om atic err ors Tex t in ano ther lan gu ag e 1.</S>
			<S sid ="203" ssid = "45">38 61.88 386.06 6.</S>
			<S sid ="204" ssid = "46">91 95.01 551.81 22.</S>
			<S sid ="205" ssid = "47">40 148.86 783.64 Table 6: Effect of text type on error models to speed (in seconds per 10,000 word-forms) Here we chiefly note that the amount of non- words in text directly reflects the speed of spell- checking.</S>
			<S sid ="206" ssid = "48">This shows that the dominating factor of the speed of spell-checking is indeed in the correcting of misspelled words.</S>
			<S sid ="207" ssid = "49">5 Conclusions and Future Work.</S>
			<S sid ="208" ssid = "50">In this article, we built a full-fledged finite-state spell-checking system from existing finite-state language models and generated error models.</S>
			<S sid ="209" ssid = "51">This work uses the system initially described in Pirinen and Linde´n (2010) and an algorithm described in Linde´n et al.</S>
			<S sid ="210" ssid = "52">(2012), providing an extensive quantitative evaluation of various combinations of constituents for such a system, and applying it to the most challenging linguistic environments available for testing.</S>
			<S sid ="211" ssid = "53">We showed that using online composition of the word form, error model and dictionary is usable for morphologically complex languages.</S>
			<S sid ="212" ssid = "54">Furthermore we showed that the error models can be automatically optimised in several ways to gain some speed at cost of recall.</S>
			<S sid ="213" ssid = "55">We showed that the memory consumption of the spell-checking process is mainly unaffected by the selection of error model, apart from the need to store a greater set of suggestions for models that generate more suggestions.</S>
			<S sid ="214" ssid = "56">The error models may therefore be quite freely changed in real world applications as needed.</S>
			<S sid ="215" ssid = "57">We verified that correcting only the first input letter affords a significant speed improvement, but that this improvement is not greatly dependent on the position of such a restriction.</S>
			<S sid ="216" ssid = "58">This practice is somewhat supported by our tentative finding that it may cause the least drop in practical recall figures, at least in Finnish.</S>
			<S sid ="217" ssid = "59">It is promising especially in conjunction with a fallback model that does correct the first letter.</S>
			<S sid ="218" ssid = "60">We described a way to avoid having a finite-state error model perform redundant work, such as deleting and inserting the same letter in succession.</S>
			<S sid ="219" ssid = "61">The practical improvement from doing this is extremely modest, and it increases the size of the error model.</S>
			<S sid ="220" ssid = "62">In this research we focused on differences in automatically generated error models and their optimisations in the case of morphologically complex languages.</S>
			<S sid ="221" ssid = "63">For future research we intend to study more realistic error models induced from actual error corpora (e.g. Brill and Moore (2000)).</S>
			<S sid ="222" ssid = "64">Research into different ways to induce weights into the language models, as well as further use of context in finite- state spell-checking (as in Pirinen et al.</S>
			<S sid ="223" ssid = "65">(2012)), is warranted.</S>
	</SECTION>
	<SECTION title="Acknowledgements">
			<S sid ="224" ssid = "66">We thank the anonymous reviewers for their comments and the HFST research team for fruity discussions on the article’s topics.</S>
			<S sid ="225" ssid = "67">The first author thanks the people of Oqaaserpassualeriffik for introducing the problems and possibilities of finite-state applications to the morphologically complex language of Greenlandic.</S>
	</SECTION>
</PAPER>
