<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">We present efmaral, a new system for efficient and accurate word alignment using a Bayesian model with Markov Chain Monte Carlo (MCMC) inference.</S>
		<S sid ="2" ssid = "2">Through careful selection of data structures and model architecture we are able to surpass the fast_align system, commonly used for performance-critical word alignment, both in computational efficiency and alignment accuracy.</S>
		<S sid ="3" ssid = "3">Our evaluation shows that a phrase-based statistical machine translation (SMT) system produces translations of higher quality when using word alignments from efmaral than from fast_align, and that translation quality is on par with what is obtained using giza++, a tool requiring orders of magnitude more processing time.</S>
		<S sid ="4" ssid = "4">More generally we hope to convince the reader that Monte Carlo sampling, rather than being viewed as a slow method of last resort, should actually be the method of choice for the SMT practitioner and others interested in word alignment.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="5" ssid = "5">Word alignment is an essential step in several applications, perhaps most prominently phrase-based statistical machine translation (Koehn et al., 2003) and annotation transfer (e.g. Yarowsky et al., 2001).</S>
			<S sid ="6" ssid = "6">The problem is this: given a pair of translationally equivalent sentences, identify which word(s) in one language corresponds to which word(s) in the other language.</S>
			<S sid ="7" ssid = "7">A number of off-the-shelf tools exist to solve this problem, but they tend to be slow, inaccurate, or both.</S>
			<S sid ="8" ssid = "8">We introduce efmaral, a new open-source tool1 for word alignment based on partially collapsed Gibbs sampling in a Bayesian model.</S>
			<S sid ="9" ssid = "9">1 The source code and documentation can be found at https://github.com/robertostling/efmaral.</S>
			<S sid ="10" ssid = "10">© 2016 PBML.</S>
			<S sid ="11" ssid = "11">Distributed under CC BY-NC-ND.</S>
			<S sid ="12" ssid = "12">Corresponding author: robert.ostling@helsinki.fi Cite as: Robert Östling, Jörg Tiedemann.</S>
			<S sid ="13" ssid = "13">Eﬃcient Word Alignment with Markov Chain Monte Carlo.</S>
			<S sid ="14" ssid = "14">The Prague Bulletin of Mathematical Linguistics No. 106, 2016, pp.</S>
			<S sid ="15" ssid = "15">125–146.</S>
			<S sid ="16" ssid = "16">doi: 10.1515/pralin2016-0013.</S>
			<S sid ="17" ssid = "17">PBML 106 OCTOBER 2016</S>
	</SECTION>
	<SECTION title="Background. " number = "2">
			<S sid ="18" ssid = "1">In order to understand the present work, we first need to formalize the problem and introduce the family of models used (Section 2.1), describe their Bayesian extension (Section 2.2), the Markov Chain Monte Carlo algorithm used for inference (Section 2.3) and its particular application to our problem (Section 2.4).</S>
			<S sid ="19" ssid = "2">2.1.</S>
			<S sid ="20" ssid = "3">The IBM models.</S>
			<S sid ="21" ssid = "4">The IBM models (Brown et al., 1993) are asymmetric generative models that describe how a source language sentence generates a target language sentence though a set of latent alignment variables.</S>
			<S sid ="22" ssid = "5">Since the task at hand is to align the words in the source and target language sentences, the words in both sentences are given, and we are left with inferring the values of the alignment variables.</S>
			<S sid ="23" ssid = "6">Formally, we denote the k:th sentence pair ⟨s(k) , t(k) ⟩ with the source sentence s(k) containing words s(k) (for each word index i ∈ 1 . . .</S>
			<S sid ="24" ssid = "7">I(k) ) and the target sentence t(k) containing words t(k) (for j ∈ 1 . . .</S>
			<S sid ="25" ssid = "8">J(k) ).</S>
			<S sid ="26" ssid = "9">Each sentence pair ⟨s( , t ⟩ is associated with an alignment variable a , where a(k) (k) (k) j = i indicates that target word tj was generated by source word si . This implies an n-to-1 mapping between source and target words, since each target word is aligned to exactly one source word, while each source word can be aligned to zero or more target words.Sentences are assumed to be generated independently, so the probability of gen erating a set of parallel sentences ⟨s, t⟩ is K P(t|s, a) = ∏ P(t(k) |s(k) , a(k) ) (1) k=1For simplicity of notation, we will drop the sentence index (k) in the following dis cussion and let ⟨s, t⟩ instead denote a single sentence pair, without loss of generality due to the independence assumption between sentences.</S>
			<S sid ="27" ssid = "10">A source word type e is associated with a lexical distribution, modeled by a categorical distribution with parameter vector θe . In the simplest of the IBM models (model 1), the probability of generating a target sentence t is defined as the probability of independently generating each of the J target words independently from the lexical distributions of their respective aligned source words.</S>
			<S sid ="28" ssid = "11">J P(t|s, a) ∝ ∏ θs j=1 ,tj (2) IBM model 1 assumes a uniform distribution for P(a), which effectively means that the word order of the sentences are considered irrelevant.</S>
			<S sid ="29" ssid = "12">This is clearly not true 126 R. Östling, J. Tiedemann Eﬃcient Word Alignment with MCMC (125–146) in real translated sentences, and in fact aj and aj+1 tend to be strongly correlated.</S>
			<S sid ="30" ssid = "13">Most research on word alignment has assumed some version of a word order model to capture this dependency.</S>
			<S sid ="31" ssid = "14">Perhaps the simplest version is used in IBM model 2 and the fast_align model (Dyer et al., 2013), which are based on the observation that j/J ≈ aj /I, in other words that sentences tend to have the same order of words in both languages.</S>
			<S sid ="32" ssid = "15">This is however a very rough approximation, and Vogel et al.</S>
			<S sid ="33" ssid = "16">(1996) instead proposed to directly model P(aj+1 − aj = x|I), which describes the length x of the “jump” in the source sentence when moving one word forward in the target sentence, conditioned on the source sentence length I. Although the IBM models allow n-to-1 alignments, not all values of n are equally likely.</S>
			<S sid ="34" ssid = "17">In general, high values of n are unlikely, and a large proportion of translations are in fact 1-to-1.</S>
			<S sid ="35" ssid = "18">The value of n depends both on the particular languages involved (a highly synthetic language like Finnish translated into English would yield higher values than a French to English translation) and on the specific word type.</S>
			<S sid ="36" ssid = "19">For instance, the German Katze ‘cat’ would typically be translated into a single English word, whereas Unabhängigkeitserklärung would normally be translated into two (independence declaration) or three words (declaration of independence).</S>
			<S sid ="37" ssid = "20">This can be modeled by defining the fertility ϕ(i) = ∑J δaj =i of a source token si , and introducing a distribution for P (ϕ(i) = n|si = e) for each source word type e.A large number of models based on the same general assumptions have been ex plored (Brown et al., 1993; Toutanova et al., 2002; Och and Ney, 2003), and the interested reader may want to consult Tiedemann (2011) for a more thorough review than we are able to provide in this work.</S>
			<S sid ="38" ssid = "21">2.2.</S>
			<S sid ="39" ssid = "22">Bayesian IBM models.</S>
			<S sid ="40" ssid = "23">The IBM models make no a priori assumptions about the categorical distributions that define the model, and most authors have used maximum-likelihood estimation through the Expectation-Maximization algorithm (Dempster et al., 1977) or some approximation to it.</S>
			<S sid ="41" ssid = "24">However, when translating natural languages the lexical distributions should be very sparse, reflecting the fact that a given source word tends to have a rather small number of target words as allowable translations, while the vast majority of target words are unimaginable as translations.</S>
			<S sid ="42" ssid = "25">These constraints have recently been modeled with sparse and symmetric Dirichlet priors (Mermer and Saraçlar, 2011; Mermer et al., 2013; Riley and Gildea, 2012) which, beyond capturing the range of lexical distributions we consider likely, also turn out to be mathematically very convenient as the Dirichlet distribution is a conjugate prior to the categorical distribution.</S>
			<S sid ="43" ssid = "26">The d-dimensional Dirichlet distribution is defined over the space of d-dimensional categorical distributions, and is parameterized by the d dimensional vector α &gt; 0.</S>
			<S sid ="44" ssid = "27">If X ∼ Dir(α), the probability density function of X is 127 PBML 106 OCTOBER 2016 given by P(X = x) = 1 ∏ xαi −1 (3) Z i i=1 where the normalization constant Z is given by the multinomial beta function ∏d ( ) B(α) = i=1 Γ αi (4) i=1 αi ) A symmetric Dirichlet distribution has αi = αj for all i, j, with the interpretation in our case that no particular translation is preferred a priori for any source word type, as this has to be estimated from the data.</S>
			<S sid ="45" ssid = "28">By also setting α ≪ 1 we favor sparse lexical distributions where most probabilities are close to zero.</S>
			<S sid ="46" ssid = "29">While it is possible to treat α as a latent variable to be inferred, good results can be obtained by using a fixed value roughly in the range of 10−6 to 10−2 (Riley and Gildea, 2012).</S>
			<S sid ="47" ssid = "30">Another direction of research has explored hierarchical distributions such as the PitmanYor process (Pitman and Yor, 1997) instead of the Dirichlet distribution for the translation distribution priors (Gal and Blunsom, 2013; Östling, 2015).</S>
			<S sid ="48" ssid = "31">Such distributions offer even greater flexibility in specifying prior constraints on the categorical distributions, but at the cost of less efficient inference.</S>
			<S sid ="49" ssid = "32">Since the gain in accuracy has turned out to be limited and computational efficiency is an important concern to us, we will not further consider hierarchical priors in this work.</S>
			<S sid ="50" ssid = "33">2.3.</S>
			<S sid ="51" ssid = "34">Markov Chain Monte Carlo.</S>
			<S sid ="52" ssid = "35">Several different methods have been used for inference in IBM alignment models.</S>
			<S sid ="53" ssid = "36">Starting with Brown et al.</S>
			<S sid ="54" ssid = "37">(1993), maximum-likelihood estimation through the Expectation-Maximization (EM) algorithm has been a popular choice.</S>
			<S sid ="55" ssid = "38">This method is generally efficient for simple models without word order or fertility distributions, but computing the expectations becomes intractable for more complex models such as IBM model 4 so approximative hill-climbing methods are used instead.</S>
			<S sid ="56" ssid = "39">Another disadvantage of using plain EM inference with the IBM models is that it is unable to incorporate priors on the model parameters, and as was pointed out in the previous section this deprives us of a powerful tool to steer the model towards more realistic solutions.</S>
			<S sid ="57" ssid = "40">Riley and Gildea (2012) presented a method to extend the EM algorithm to IBM models with Dirichlet priors, through Variational Bayes inference.</S>
			<S sid ="58" ssid = "41">Unfortunately, their method inherits the complexity issues of earlier EM approaches.</S>
			<S sid ="59" ssid = "42">The inference approach chosen by most authors working on Bayesian IBM models (Mermer and Saraçlar, 2011; Gal and Blunsom, 2013; Östling, 2015) is Gibbs sampling (Gelfand and Smith, 1991), a special case of the Markov Chain Monte Carlo (MCMC) method which we will briefly summarize here.</S>
			<S sid ="60" ssid = "43">128 R. Östling, J. Tiedemann Eﬃcient Word Alignment with MCMC (125–146) Given a probability function pM (x) of some model M on parameter vector x, MCMC provides us with the means to draw samples from pM . This is done by constructing a Markov chain with values of x as states, such that its stationary distribution is identical to pM . In practice, this means deriving expressions for the transition probabilities P(x ′ |x) of going from state x to state x ′ . Since the number of states is enormous or infinite in typical applications, it is essential that there is some way of sampling efficiently from P(x ′ |x).</S>
			<S sid ="61" ssid = "44">With Gibbs sampling, this is done by sampling one variable from the parameter vector x at a time, conditioned on all other variables:P(xi |x1 , x2 , . . .</S>
			<S sid ="62" ssid = "45">, xi−1 , xi+1 , . . .</S>
			<S sid ="63" ssid = "46">, xm ) which we will write as P(xi |x(−i) ) to indicate con ditioning on all elements of x except at index i. All positions i are then sampled in some arbitrary but fixed order.</S>
			<S sid ="64" ssid = "47">By choosing suitable distributions for the model, the goal in designing a Gibbs sampler is to make sure that this distribution is easy to sample from.</S>
			<S sid ="65" ssid = "48">2.4.</S>
			<S sid ="66" ssid = "49">Gibbs sampling for Bayesian IBM models.</S>
			<S sid ="67" ssid = "50">The Bayesian version of IBM model 1 defines the following probability over the parameter vector, which consists of the alignment vector a and the lexical distribution vectors θe for each e in the source target vocabulary:  K J(k)  ( E F ) P(a, θ) = P(s, t, a, θ, α) ∝ ∏ ∏ θ (k) (k)  · ∏ ∏ θαf −1 (5) since s, t and α are constant.</S>
			<S sid ="68" ssid = "51">k=1 j=1 s (k) ,tj a j e=1 f=1 e,f A straightforward Gibbs sampler can be derived by observing that P(x) P(x(−i) , xi ) which means that P(xi |x(−i) ) = P(x(−i) ) = P(x(−i) ) P(a(−j) , aj = i, θ) P(aj = i|a(−j) , θ) = ( ) ∝ θs ,t (6) and P a(−j) , θ aj j P(θ(−e) , θe = x|a) ∏F xαf +ce,f −1 P(θe = x|a, θ(−e) ) = P(θ(−e) |a) = f=1 f B(αe + ce ) (7) where ce,f is the number of times that word e is aligned to word f given a, s and t. Equation (7) is a consequence of the fact that the Dirichlet distribution is a conjugate prior to the categorical distribution, so that if x ∼ Dir(α) z ∼ Cat(x) 129 PBML 106 OCTOBER 2016 then given a sequence z of |z| samples from Cat(x) we have x|z ∼ Dir(α + c(z)) (8) where | z | c(z)m = ∑ δz =m i=1 is the number of samples in z that are equal to m. This can be easily shown from the definition of the Dirichlet distribution using Bayes’ theorem: P(x|α, z) ∝ P(z|α, x)P(α, x) (9) d ∏ ∝ i=1 d xαi −1 |z| ∏ i=1 xzi (10) = ∏ xαi −1 ∏ xc(z)m (11) i=1 m d = ∏ xαi +c(z)−1 (12) i=1 which is the (unnormalized) Dirichlet distribution with parameter α + c(z).</S>
			<S sid ="69" ssid = "52">Equation (6) and Equation (7) can be used for sampling with standard algorithms for categorical and Dirichlet distributions, respectively, and together they define an explicit Gibbs sampler for the Bayesian IBM model 1.</S>
			<S sid ="70" ssid = "53">While simple, this sampler suffers from poor mixing (Östling, 2015, section 3.3) and is not a competitive algorithm for word alignment.</S>
			<S sid ="71" ssid = "54">However, much better performance can be achieved by using a collapsed sampler where the parameters θe are integrated out so that we only have to derive a sampling equation for the alignment variables P(aj = i|a(−j) ).</S>
			<S sid ="72" ssid = "55">First we use Equation (5) to derive an expression for P(a|s, t, α), from which the final sampler can be computed as P(a(−j) , aj = i|s, t, α) P(aj = i|a(−j) , s, t, α) = ( ) (13) P a(−j) |s, t, α Since the elements of a are exchangeable, a sufficient statistic for a is the count vector c(·) where each element K J(k) c(a, e, f)e,f = ∑ ∑ δ (k) (k) (14) k=1 j=1 s (k) =e∧tj =f a j 130 R. Östling, J. Tiedemann Eﬃcient Word Alignment with MCMC (125–146) represents the number of times that source word type e is aligned to target word type f under the alignment a. Next, we marginalize over each of the lexical distributions θe . P(a|s, t, α) = ∏ ∫ P(a |θ , s, t, α)P(θ |s, t, α) dθ (15) e=1 ∆ {j|saj =e} e e e Substituting from Equation (5) into the integral we have P(a|s, t, α) = 1 ∫ F ∏ ∏ θc(a,s,t)e,f +αf −1 dθe (16) B(α) e=1 ∆ f=1 e,f where the innermost product can be recognized as an unnormalized Dir(α+c(a, s, t))distribution which has normalization factor B(α + c(a, s, t)), so that the final expres sion becomes E ( ) P(a|s, t, α) = ∏ B α + c(a, s, t) B α e=1 E = ∏ (∑F ) ∏ f=1 f F (αf + c(a, s, t)e,f ) (18) e=1 Γ (∑ =1 (αf + c(a, s, t)e,f )) ∏ Γ (αf ) f f Combining Equation (13) with Equation (18) gives us an expression where almost all of the terms are cancelled out, except when si = e and tj = f for which c(a, s, t)e,f and c(a(−j) , s, t)e,f differ by 1.</S>
			<S sid ="73" ssid = "56">We are left with a remarkably simple sampling distribution: P(aj = i|a(−j) , s, t, α) = αt (−j) , s, t)si ,tj (19) ∑F f=1 (αf + c(a(−j) , s, t)s ,f ) By repeatedly sampling each aj in turn from Equation (19) we are guaranteed to, in the limit, obtain an unbiased sample from P(a) under the model.</S>
			<S sid ="74" ssid = "57">What we are really interested in, however, is to estimate the marginal distributions P(aj = i) as closely as possible while using as little computation as possible, given a sequence of correlated samples a(t) for time t ∈ 1 . . .</S>
			<S sid ="75" ssid = "58">T . Given a sequence of samples a(t) we can then approximate the marginal distributions P(aj = i) = E P(a) ∞ [δaj =i ] = δa(t) ≈ T T δa(t) 1 (20) t= In practice a(0) will be initialized either from a uniform distribution or by using the output of a simpler model, and the samples will gradually become more independent of a(0) as t increases.</S>
			<S sid ="76" ssid = "59">Since a(0) is likely to lie in a low-probability region of the model, 131 PBML 106 OCTOBER 2016 so do the initial samples, and it is common to use a burn-in period and disregard all a(t) for t &lt; t0 . To further ameliorate the problem of initialization bias, it is possible to run several independently initialized samplers and average their results.</S>
			<S sid ="77" ssid = "60">Combining these methods the marginal distribution approximation becomes 1 N T P(aj = i) ≈ N(T − t + 1) ∑ ∑ n=1 t=t0 δa(n,t) (21) where N is the number of independent samplers and t0 is the length of the burn- in period.</S>
			<S sid ="78" ssid = "61">Finally, a better estimate can be obtained by applying the RaoBlackwell theorem (Blackwell, 1947; Gelfand and Smith, 1991), which allows us to reuse the computations of P(aj = i|a(−j) ) during sampling and averaging these distributions rather than δa(t) . The final.</S>
			<S sid ="79" ssid = "62">approximation then becomes 1 N T P(aj = i) ≈ N(T − t + 1) ∑ ∑ n=1 t=t0 P(a(n,t) = i|a (n,t)(−j) ) (22)</S>
	</SECTION>
	<SECTION title="Methods. " number = "3">
			<S sid ="80" ssid = "1">We now turn to the particular models and algorithms implemented in efmaral, presenting our Bayesian HMM model with fertility, the Gibbs sampler used as well as the details on how to make it computationally efficient.</S>
			<S sid ="81" ssid = "2">3.1.</S>
			<S sid ="82" ssid = "3">Alignment model.</S>
			<S sid ="83" ssid = "4">Our goal in this work is to find a word alignment algorithm that is both accurate and efficient.</S>
			<S sid ="84" ssid = "5">Previous studies have shown that good word order and fertility models are essential to high accuracy (Brown et al., 1993; Och and Ney, 2003), along with reasonable priors on the parameters (Mermer and Saraçlar, 2011; Östling, 2015).</S>
			<S sid ="85" ssid = "6">As was discussed in Section 2.3, MCMC algorithms and in particular collapsed Gibbs sampling are particularly suitable for inference in this class of models, as long as the convergence of the Markov chain are sufficiently fast.</S>
			<S sid ="86" ssid = "7">Even within this class of algorithms there are some trade-offs between accuracy and computational efficiency.</S>
			<S sid ="87" ssid = "8">In particular, hierarchical priors have been shown to somewhat improve accuracy (Östling, 2015, p. 65), but in spite of improved sampling algorithms (Blunsom et al., 2009) it is still considerably more costly to sample from models with hierarchical priors than with Dirichlet priors.</S>
			<S sid ="88" ssid = "9">For these reasons, we use a HMM model for word order based on Vogel et al.</S>
			<S sid ="89" ssid = "10">(1996) as well as a simple fertility model, and the complete probability of an alignment is essentially the same as Equation (5) with extra factors added for the word order and 132 R. Östling, J. Tiedemann Eﬃcient Word Alignment with MCMC (125–146) fertility model: P(s, t, a,θ, ψ, π, α, β, γ)  K J(k)  ( E F ) ∏ ∏ ∝  k=1 j=1 θ (k) (k) a j ,t(k)  · ∏ ∏ e=1 f=1 αf −1 e,f  K J(k) +1 ∏ ∏ ·  ψa(k)  (k)  · ( mmax ∏ ) βm −1 m (23) k=1 j=1 j −aj−1 m=mmin  K I(k)  ( E nmax ) ∏ ∏ ·  k=1 i=1 i ,ϕ(i,a(k) )  ∏ ∏ e=1 n=0 γn −1 e,n where ψ ∼ Dir(β) are the categorical distribution parameters for the word order model P(aj − aj−1 = m), and πe ∼ Dir(γ) for the fertility model P(ϕ(i, a)|si = e).</S>
			<S sid ="90" ssid = "11">In our experiments we fix α = 0.001, ψ = 0.5 and γ = 1, but these parameters are not very critical as long as 0 &lt; α ≪ 1.</S>
			<S sid ="91" ssid = "12">The IBM models naturally allow unaligned source language words, but in order to also allow target words to not be aligned we use the extension of Och and Ney (2003) to the HMM alignment model, where each source word si (from sentence s of length I) is assumed to have a special null word si+I . The null word generates lexical items from the distribution θnull , and the word order model is modified so that P(aj = i + I|aj−1 = i ′ ) = pnull δi=i ′ (24) P(aj = i + I|aj−1 = i ′ + I) = pnull δi=i ′ (25) P(aj = i|aj−1 = i ′ + I) = ψi−i ′ (26) where pnull is the prior probability of a null word alignment (fixed to 0.2 in our experiments).</S>
			<S sid ="92" ssid = "13">133 PBML 106 OCTOBER 2016 We collapse the sampler over θ and ψ in the same manner as was shown in Section 2.4 and obtain the following approximate2 sampling distribution: P(aj = i|a(−j) , s, t, α, β, γ) ∝ αtj + c(a (−j) , s, t)si ,tj ∑F f=1 (αf + c(a(−j) , s, t)s ,f ) (−j) βi−aj−1 + c ′ (a )i−aj−1 · ∑mmax m=mmin (βm + c ′ (a(−j) )m ) (−j) (27) βaj+1−i + c ′ (a )aj−1 −i · ∑mmax m=mmin (βm + c ′ (a(−j) )m ) πsi ,ϕ(i,a(−j) )+1 πsi ,ϕ(i,a(−j) ) While collapsing over the θ is essential for acceptable mixing in the Markov chain, this is not the case for π.</S>
			<S sid ="93" ssid = "14">Instead, we alternate between sampling from Equation (27) and πe ∼ Dir(γ + c ′′ (a)e )) (28) where c ′′ (a)e is the count vector over the fertility distribution for source word e given alignments a. The advantage of this is that the last product of Equation (27) can be precomputed, saving computation in the inner loop in exchange for the (relatively minor) expense of also sampling from Equation (28).</S>
			<S sid ="94" ssid = "15">3.2.</S>
			<S sid ="95" ssid = "16">Computational efficiency.</S>
			<S sid ="96" ssid = "17">From Equation (27) it is clear that the computational complexity of sampling sen tence k is O(I(k) J(k) ), since every alignment variable a(k) for each j ∈ 1 . . .</S>
			<S sid ="97" ssid = "18">J(k) needs to evaluate the expression in 27 once for each i ∈ 1 . . .</S>
			<S sid ="98" ssid = "19">I(k) , and each evaluation re quires constant time assuming that the sums are cached.</S>
			<S sid ="99" ssid = "20">Since sentence lengths are approximately proportional across languages, I(k) ≈ λJ(k) for some constant λ, thisgives a total complexity of O(∑ I2 ) per iteration of sampling a. Note that the com plexity does not change as we go from Equation (19) for the simple IBM model 1 to Equation (27) for the more complex model with word order and fertility.</S>
			<S sid ="100" ssid = "21">In contrast, the corresponding Expectation-Maximization (EM) algorithm for IBMalignment models has O(∑ I2 ) complexity in the E-step only for models with sim ple or no word order model.</S>
			<S sid ="101" ssid = "22">The HMM-based model of Vogel et al.</S>
			<S sid ="102" ssid = "23">(1996) can still be implemented relatively efficiently using dynamic programming, but complexity increases to O(∑ I3 ).</S>
			<S sid ="103" ssid = "24">For models with fertility computing the expectations instead becomes intractable, and previous authors have solved this by using approximative 2 The approximation consists of ignoring the dependence between the two draws from the word order jump distribution (second and third factors).</S>
			<S sid ="104" ssid = "25">134 R. Östling, J. Tiedemann Eﬃcient Word Alignment with MCMC (125–146) greedy optimization techniques (Brown et al., 1993) or local Gibbs sampling (Zhao and Gildea, 2010).</S>
			<S sid ="105" ssid = "26">The main advantage of EM over a collapsed Gibbs sampler is that the former is trivial to parallelize, which makes well-implemented parallel EM based implementations of simple alignment models with O(∑ I2 ) complexity, such as fast_align (Dyer et al., 2013), a strong baseline performance-wise.</S>
			<S sid ="106" ssid = "27">Algorithm 1 Inner loop of our sampler for IBM model 1 function sample(a(k)(−j) ) ▷ Initialize cumulative probability s ← 0 for all i ∈ 1 . . .</S>
			<S sid ="107" ssid = "28">I(k) do ▷ Load denominator reciprocal (small array random access) D−1 ← dk,i ▷ Load numerator index (sequential access) L ← lk,i,j ▷ Load numerator (large array random access) N ← uL ▷ Compute unnormalized probability (one multiplication) pˆ ← D−1 U ▷ Accumulate probabilities (one addition) s ← s + pˆ ▷ Store cumulative probability (sequential access) pi ← s end for ▷ Sample from a uniform distribution on the unit interval r ∼ Uniform(0, 1,) r ← r · pI ▷ Find the lowest i such that pi &gt; r i ← 1 while pi ≤ r do i ← i + 1 end while a(k) ← end function If a collapsed Gibbs sampler is to be a viable option for performance-critical applications, we must pay attention to details.</S>
			<S sid ="108" ssid = "29">In particular, we propose utilizing the fixed order of computations in order to avoid expensive lookups.</S>
			<S sid ="109" ssid = "30">Recall that variables a(k) are sampled in order, for k = 1 . . .</S>
			<S sid ="110" ssid = "31">K, j = 1 . . .</S>
			<S sid ="111" ssid = "32">J(k) . Now, for each pair ⟨k, j⟩ we need 135 PBML 106 OCTOBER 2016 to compute αtj + c(a (−j) , s, t)si ,tj ∑F f=1 (αf + c(a(−j) , s, t)s ,f ) which, if the numerator sum and the reciprocal of the denominator sum are cached in memory, involves two table lookups and one multiplication.</S>
			<S sid ="112" ssid = "33">Since multiplication is fast and the denominator reciprocal is stored in a relatively small dense array, most attention has to be paid to the numerator lookup, which apart from the constant αtj is a sparse matrix with nonzero counts c(a(−j) , s, t)s ,t only where si and tj are i j aligned.</S>
			<S sid ="113" ssid = "34">The standard solution would therefore be to use a hash table with ⟨si , tj ⟩ as keys to ensure memory efficiency and constant-time lookup.</S>
			<S sid ="114" ssid = "35">However, most counts are in fact guaranteed to always be zero, as only words from the same parallel sentence pair can be aligned.</S>
			<S sid ="115" ssid = "36">We are therefore able to construct a count vector u and an index (−j) table l such that ulk,i,j = c(a , s, t)si ,tj +αtj . At the expense of some extra memory usage we are able to achieve the lookup with only two operations, one of which is a cache-efficient sequential memory access.</S>
			<S sid ="116" ssid = "37">With this method, the inner loop of the sampler for IBM model 1 thus contains only six operations, outlined in algorithm 1.</S>
			<S sid ="117" ssid = "38">Adding the HMM word order model, two more sequential memory loads and two.</S>
			<S sid ="118" ssid = "39">multiplications are needed, and adding the fertility model requires one more memory load and a multiplication.</S>
	</SECTION>
	<SECTION title="Related work. " number = "4">
			<S sid ="119" ssid = "1">In this section we relate our work mainly to the literature on Bayesian models of word alignment, as well as computationally efficient methods for this problem.</S>
			<S sid ="120" ssid = "2">A comprehensive survey of word alignment methods is beyond the scope of this article, for this we refer the reader to Tiedemann (2011).</S>
			<S sid ="121" ssid = "3">Much of research into word alignment has been based on the pioneering work of Brown et al.</S>
			<S sid ="122" ssid = "4">(1993), and we have already introduced part of their family of IBM alignment models in Section 2.1.</S>
			<S sid ="123" ssid = "5">Their most advanced models still perform competitively after nearly two decades, but due to their complexity (with exact inference being intractable) many have suggested simpler alternatives, typically by keeping the lexical translation model intact and introducing computationally convenient word order and fertility models so that inference with the Expectation-Maximization (EM) algorithm remains tractable.</S>
			<S sid ="124" ssid = "6">Notable examples include the simple HMM-based model of Vogel et al.</S>
			<S sid ="125" ssid = "7">(1996) and the even simpler reparametrized IBM model 2 of Dyer et al.</S>
			<S sid ="126" ssid = "8">(2013).</S>
			<S sid ="127" ssid = "9">Neither of these include a model for word fertility, but Toutanova et al.</S>
			<S sid ="128" ssid = "10">(2002) showed that a simplified fertility model (which only counts alignments from consecutive target words) can be added to the HMM model without increasing the complexity of inference, and more recently this has also been achieved for a general fertility model (Quirk, 2013).</S>
			<S sid ="129" ssid = "11">136 R. Östling, J. Tiedemann Eﬃcient Word Alignment with MCMC (125–146) The EM algorithm requires computing the expected values of the alignments, E [δaj =i ], given the current values of the model parameters.</S>
			<S sid ="130" ssid = "12">The authors cited above all dealt with this fact by analytically deriving expressions for exact computation of these expectations in their models.</S>
			<S sid ="131" ssid = "13">Zhao and Gildea (2010) instead chose to use Gibbs sampling to approximate these expectations, which allowed them to perform efficient inference with EM for a HMM model with fertility.</S>
			<S sid ="132" ssid = "14">Riley and Gildea (2012) later showed how Variational Bayesian techniques can be used to incorporate priors on the parameters of the IBM models, with only minor modifications to the expressions for the alignment expectations.</S>
			<S sid ="133" ssid = "15">Recently, several authors have disposed with EM altogether, relying entirely on Gibbs sampling for inference in IBM-based models with Bayesian priors of varying complexity (Mermer and Saraçlar, 2011; Mermer et al., 2013; Gal and Blunsom, 2013; Östling, 2015).</S>
			<S sid ="134" ssid = "16">Of these, Gal and Blunsom (2013) and to some extent Östling (2015) prioritize maximizing alignment accuracy, which is obtained by using complex hierarchical models.</S>
			<S sid ="135" ssid = "17">Mermer et al.</S>
			<S sid ="136" ssid = "18">(2013) use Dirichlet priors with IBM models 1 and 2 to obtain efficient samplers, which they implement in an approximate fashion (where dependencies between variables are ignored during sampling) in order to facilitate parallelization.</S>
			<S sid ="137" ssid = "19">This article follows previous work by the first author (Östling, 2015), which however was focused on alignment of short parallel text for applications in language typology and transfer learning, rather than efficient large-scale alignment for use with statistical machine translation systems.</S>
	</SECTION>
	<SECTION title="Results. " number = "5">
			<S sid ="138" ssid = "1">In this section we first investigate the effect of different parameter settings in efmaral, then we proceed with a comparison to two other influential word alignment systems with respect to the performance of statistical machine translation (SMT) systems using the alignments.</S>
			<S sid ="139" ssid = "2">Since computational efficiency is an important objective with efmaral, we report runtime for all experiments.</S>
			<S sid ="140" ssid = "3">The following three systems are used in our comparison: giza++: The standard pipeline of IBM models with standard settings of 5 iterations of IBM 1, 5 iterations of the HMM model, and 5 iterations of IBM model 3 and 4 with Viterbi alignments of the final model (Och and Ney, 2003).</S>
			<S sid ="141" ssid = "4">Class dependencies in the final distortion model use automatically created word clusters using the mkcls tool, 50 per language.</S>
			<S sid ="142" ssid = "5">fast_align: An log-linear reparameterization of IBM model 2 using efficient inference procedures and parameter estimations (Dyer et al., 2013).</S>
			<S sid ="143" ssid = "6">We use the options that favor monotonic alignment points including the optimization procedures that estimate how close they should be to the monotonic diagonal.</S>
			<S sid ="144" ssid = "7">efmaral: Our implementation of the MCMC alignment approach proposed in this article.</S>
			<S sid ="145" ssid = "8">137 PBML 106 OCTOBER 2016 Since these tools all use asymmetric models, we ran each aligner in both directions and applied the grow-diag-final-and (Section 5.1) or grow-diag-final (Section 5.2) symmetrization heuristic (Och and Ney, 2003, p. 33).</S>
			<S sid ="146" ssid = "9">This method assumes a set of binary alignments, so for efmaral we produce these by choosing the single most probable value for each aj : arg maxi P(aj = i).</S>
			<S sid ="147" ssid = "10">In this way the results are more easily comparable to other systems, although some information is lost before the symmetrization step and methods have been explored that avoid this (Matusov et al., 2004; Östling, 2015, pp.</S>
			<S sid ="148" ssid = "11">46–47).</S>
			<S sid ="149" ssid = "12">5.1.</S>
			<S sid ="150" ssid = "13">Alignment quality experiments.</S>
			<S sid ="151" ssid = "14">As discussed in Section 2.4, there are two ways of trading off computing time for approximation accuracy: increasing the number of independent samplers, and increasing the number of sampling iterations.</S>
			<S sid ="152" ssid = "15">Here we explore the effects of these trade-offs on alignment accuracy.</S>
			<S sid ="153" ssid = "16">Following Och and Ney (2003), most subsequent research has compared the results of automatic word alignment to hand-annotated data consisting of two sets of links: S, containing sure tuples ⟨i, j⟩ where the human judgment is that si and tj must be aligned, and S ⊆ P, containing possible tuples ⟨i, j⟩ where si and tj may be linked.</S>
			<S sid ="154" ssid = "17">Given a set A of alignments to be evaluated, they define the measures precision (p), recall (r), and alignment error rate (AER) as follows: |A ∩ P| p = (29) |A| r = |A ∩ S| (30) |P| |A ∩ S| + |A ∩ P| AER = 1 − (31) |A| + |S| While popular, the AER measure is biased towards precision rather than recall and correlates poorly with machine translation performance.</S>
			<S sid ="155" ssid = "18">Fraser and Marcu (2007) instead suggest to use the F-measure, which favors a balance between precision and recall as defined in Equation (29) and Equation (30): ( α Fα = p + 1 − α )−1 r (32) In our experiments, we report both AER and F0.5 .In order to evaluate alignment quality we are limited to language pairs with an notated alignment data.</S>
			<S sid ="156" ssid = "19">For this reason, we use the corpora and test sets from the WPT 2003 and 2005 shared tasks (Mihalcea and Pedersen, 2003; Martin et al., 2005).</S>
			<S sid ="157" ssid = "20">In addition, we also use the SwedishEnglish part of the Europarl corpus version 7 138 R. Östling, J. Tiedemann Eﬃcient Word Alignment with MCMC (125–146) Table 1.</S>
			<S sid ="158" ssid = "21">Data sets used for our alignment quality experiments.</S>
			<S sid ="159" ssid = "22">The total number of sentences in the respective corpora are given along with the number of sentences and gold-standard (S)ure and (P)ossible alignment links in the corresponding test set.</S>
			<S sid ="160" ssid = "23">Co rp us Se nt en ce s Tr ai ni n g Se nt en ce s | S | Tes t | P | En glish Fr en ch 1, 1 3 0, 5 8 8 4 4 7 4, 03 8 17, 43 8 En glish Ro m an ia n 4 8 , 6 4 1 2 0 0 5, 03 4 5, 0 3 4 En gli sh In uk tit ut 3 3 3 , 1 8 5 75 2 9 3 1, 9 7 2 En gli sh Hi nd i 3 , 5 5 6 90 1, 40 9 1, 4 0 9 En gli sh S we di sh 6 9 2 , 6 6 2 1 9 2 3, 34 0 4, 5 7 7 (Koehn, 2005) with test set from Holmqvist and Ahrenberg (2011).</S>
			<S sid ="161" ssid = "24">The data sets are presented in Table 1, where it can be noted they differ both in size and in annotation style.</S>
			<S sid ="162" ssid = "25">In particular, the EnglishRomanian and EnglishHindi data only have one set of gold-standard links, so that S = P, the English-French and EnglishInuktitut data have |S| ≪ |P|, while the EnglishSwedish data lies somewhere in between.</S>
			<S sid ="163" ssid = "26">Table 2: Results of our alignment quality experiments.</S>
			<S sid ="164" ssid = "27">All timing and accuracy figures use means from five independently initialized runs.</S>
			<S sid ="165" ssid = "28">Note that lower is better for AER, higher is better for F0.5 . All experiments are run on a system with two Intel Xeon E5645 CPUs running at 2.4 GHz, in total 12 physical (24 virtual) cores.</S>
			<S sid ="166" ssid = "29">Quality Time (seconds) Configuration AER F0.5 CPU Wall English-French fa st _a li gn 1x ite rat io ns, 2 sa m pl er s 1 5.</S>
			<S sid ="167" ssid = "30">3 86.2 8 . 2 92.3 4 , 1 2 4 243 7 4 1 2 7 0 4x ite rat io ns, 2 sa m pl er s 16 x ite rat io ns, 2 sa m pl er s 8 . 1 92.2 8 . 1 92.1 2, 7 0 0 809 10, 55 7 2,945 1x ite rat io ns, 1 sa m pl er s 1x ite rat io ns, 4 sa m pl er s 1x ite rat io ns, 8 sa m pl er s 9 . 1 91.4 7 . 8 92.6 7 . 6 92.9 4 7 0 2 4 8 1 , 3 2 4 298 2 , 4 5</S>
	</SECTION>
	<SECTION title="330" number = "6">
			<S sid ="168" ssid = "1">Continued on next page 139 PBML 106 OCTOBER 2016 Configuration AER F0.5 CPU Wall EnglishHindi fa st _a li gn 1x ite rat io ns, 2 sa m pl er s 6 7.</S>
			<S sid ="169" ssid = "2">3 32.7 4 8.</S>
			<S sid ="170" ssid = "3">3 51.7 2 7 2 1 0 7 12 4x ite rat io ns, 2 sa m pl er s 16 x ite rat io ns, 2 sa m pl er s 4 9.</S>
			<S sid ="171" ssid = "4">0 51.0 5 1.</S>
			<S sid ="172" ssid = "5">0 49.0 4 1 6 4 6 1 , 6 6 4 183 1x ite rat io ns, 1 sa m pl er s 1x ite rat io ns, 4 sa m pl er s 1x ite rat io ns, 8 sa m pl er s 4 9.</S>
			<S sid ="173" ssid = "6">4 50.6 4 7.</S>
			<S sid ="174" ssid = "7">5 52.5 4 6.</S>
	</SECTION>
	<SECTION title="53.3" number = "7">
			<S sid ="175" ssid = "1">8 1 1 0 1 4 6 13 2 3 8 17 EnglishInuktitut fa st _a li gn 1x ite rat io ns, 2 sa m pl er s 2 8.</S>
			<S sid ="176" ssid = "2">7 78.1 2 2.</S>
			<S sid ="177" ssid = "3">3 81.5 7 5 2 48 1 6 0 62 4x ite rat io ns, 2 sa m pl er s 16 x ite rat io ns, 2 sa m pl er s 1 9.</S>
			<S sid ="178" ssid = "4">7 83.7 1 7.</S>
			<S sid ="179" ssid = "5">3 86.0 5 6 0 1 9 9 2 , 1 7 6 747 1x ite rat io ns, 1 sa m pl er s 1x ite rat io ns, 4 sa m pl er s 1x ite rat io ns, 8 sa m pl er s 2 3.</S>
	</SECTION>
	<SECTION title="80.1" number = "8">
			<S sid ="180" ssid = "1">1 9.</S>
			<S sid ="181" ssid = "2">6 84.1 1 8.</S>
			<S sid ="182" ssid = "3">4 85.3 9 8 5 6 2 5 9 64 5 1 5 72 EnglishRomanian fa st _a li gn 1x ite rat io ns, 2 sa m pl er s 3 2.</S>
			<S sid ="183" ssid = "4">5 67.5 2 8.</S>
			<S sid ="184" ssid = "5">7 71.3 2 6 6 17 1 6 7 47 4x ite rat io ns, 2 sa m pl er s 16 x ite rat io ns, 2 sa m pl er s 2 9.</S>
			<S sid ="185" ssid = "6">0 71.0 2 9.</S>
			<S sid ="186" ssid = "7">5 70.5 6 4 8 1 7 3 2 , 5 8 0 682 1x ite rat io ns, 1 sa m pl er s 1x ite rat io ns, 4 sa m pl er s 1x ite rat io ns, 8 sa m pl er s 2 9.</S>
			<S sid ="187" ssid = "8">8 70.2 2 8.</S>
			<S sid ="188" ssid = "9">2 71.8 2 7.</S>
	</SECTION>
	<SECTION title="72.1" number = "9">
			<S sid ="189" ssid = "1">9 7 4 3 3 2 0 53 6 5 6 59 EnglishSwedish fa st _a li gn 1x ite rat io ns, 2 sa m pl er s 2 0.</S>
			<S sid ="190" ssid = "2">5 79.8 1 3.</S>
			<S sid ="191" ssid = "3">1 87.0 12, 29 8 671 1, 6 0 6 589 4x ite rat io ns, 2 sa m pl er s 16 x ite rat io ns, 2 sa m pl er s 1 1.</S>
			<S sid ="192" ssid = "4">4 88.6 1 0.</S>
			<S sid ="193" ssid = "5">6 89.4 5, 9 8 9 1,830 23, 09 9 6,519 1x ite rat io ns, 1 sa m pl er s 1x ite rat io ns, 4 sa m pl er s 1x ite rat io ns, 8 sa m pl er s 1 3.</S>
			<S sid ="194" ssid = "6">8 86.3 1 3.</S>
			<S sid ="195" ssid = "7">2 86.8 1 1.</S>
			<S sid ="196" ssid = "8">7 88.3 1, 0 0 5 538 2, 6 8 1 626 6, 1 4 7 839 Table 2 shows the result of varying the number of samplers and iterations for all the language pairs under consideration.</S>
			<S sid ="197" ssid = "9">As a baseline for each language pair, we use fast_align as well as the default efmaral configuration of two independent sam √ plers, running x = ⌊100/ K⌋ sampling iterations where K is the number of parallel sentences in the data (with the additional constraint that 4 ≤ x ≤ 250).</S>
			<S sid ="198" ssid = "10">Following 140 R. Östling, J. Tiedemann Eﬃcient Word Alignment with MCMC (125–146) the practice set by Brown et al.</S>
			<S sid ="199" ssid = "11">(1993), each model is initialized with the output of a simpler model.</S>
			<S sid ="200" ssid = "12">For the full HMM+fertility model, we run ⌊x/4⌋ sampling iterations of IBM model 1 initialized with uniformly random alignments, use the last sample to initialize the fertility-less HMM model that we also run for ⌊x/4⌋ iterations.</S>
			<S sid ="201" ssid = "13">Finally, x samples are drawn from the full model and the final alignments are estimated from these using Equation (22).</S>
			<S sid ="202" ssid = "14">The experiments described in Table 2 were carried out on a system with dual Intel Xeon E5645 CPUs, with a total of 24 virtual cores available.</S>
			<S sid ="203" ssid = "15">Even though this setup strongly favors fast_align’s parallel implementation, efmaral is faster for the largest corpus (where speed matters most) in terms of both wall time and CPU time, and for all but the smallest corpora in CPU time.</S>
			<S sid ="204" ssid = "16">This trend will also be seen in Section 5.2, where even larger parallel corpora are used for our machine translation experiments.</S>
			<S sid ="205" ssid = "17">As expected, increasing the number of independently initialized samplers consistently results in better alignments, in line with research on model averaging for a wide range of machine learning models.</S>
			<S sid ="206" ssid = "18">When it comes to increasing the number of sampling iterations the result is less clear: for some pairs this seems even more important than the number of independent samplers, whereas for other pairs the quality metrics actually change for the worse.</S>
			<S sid ="207" ssid = "19">Recall that the samplers are initialized with a sample from the fertility-less HMM model, and that the correlation to this sample decreases as the number of samples from the HMM model with fertility increases.</S>
			<S sid ="208" ssid = "20">Decreasing quality therefore indicates that for that particular language pair and annotation style, the fertility model performs worse than the mix between the fertility and fertility-less models obtained by using a small number of samples.</S>
			<S sid ="209" ssid = "21">When interpreting these results, it is also important to keep in mind that the quality metrics are computed using discretized and symmetrized alignments, which are related in a quite complex way to the probability estimates of the underlying model.</S>
			<S sid ="210" ssid = "22">From a practical point of view, one should also consider that additional independent samplers can be run in parallel, unlike additional sampling iterations which have a serial dependence.</S>
			<S sid ="211" ssid = "23">For this reason and because of the consistent improvements demonstrated in Table 2, increasing the number of samplers should be the preferred method for improving alignment quality at the cost of memory and CPU time.</S>
			<S sid ="212" ssid = "24">5.2.</S>
			<S sid ="213" ssid = "25">Machine translation experiments.</S>
			<S sid ="214" ssid = "26">In order to test the effect of word alignment in a downstream task, we conducted some experiments with generic phrase-based machine translation.</S>
			<S sid ="215" ssid = "27">Our models are based on the Moses pipeline (Koehn et al., 2007) with data coming from the Workshop on Statistical Machine Translation.</S>
			<S sid ="216" ssid = "28">In our setup we use the news translation task from 2013 with translation models for English to Czech, German, Spanish, French and Russian and vice versa.</S>
			<S sid ="217" ssid = "29">Parallel training data comes from Europarl version 7 (Koehn, 2005) (for all language pairs except RussianEnglish) and the News Commentary corpus version 11.</S>
			<S sid ="218" ssid = "30">For language modeling, we use the monolingual data sets from Eu 141 PBML 106 OCTOBER 2016 Table 3.</S>
			<S sid ="219" ssid = "31">Data used for training SMT models (all counts in millions).</S>
			<S sid ="220" ssid = "32">Parallel data sets refer to the bitexts aligned to English and their token counts include both languages.</S>
			<S sid ="221" ssid = "33">La ng ua ge Mo nol ing ual Parallel Se nte nc es Tokens Se nte nc es Tokens Cz ec h G e r m a n E n g l i s h S p a n i s h F r e n c h R u s s i a n 8 . 4 1 4 5 2 3 . 1 4 2 5 1 7 . 3 4 1 1 6 . 5 1 9 0 6 . 4 1 7 3 1 0 . 0 1 7 8 0 . 8 4 1 2 . 1 1 1 4 – – 2 . 0 1 0 9 2 . 0 1 1 4 0 . 2 1 0 roparl and News Commentary as well as the shuffled news texts from 2012.</S>
			<S sid ="222" ssid = "34">We did not use any of the larger news data sets from more recent years to avoid possible overlaps with the 2013 test set.</S>
			<S sid ="223" ssid = "35">We apply a pipeline of pre-processing tools from the Moses package to prepare all data sets including punctuation normalization, tokenization, lowercasing and corpus cleaning (for parallel corpora).</S>
			<S sid ="224" ssid = "36">Statistics of the final data sets are listed in Table 3.</S>
			<S sid ="225" ssid = "37">All language models use order five with modified KneserNey smoothing and are estimated using KenLM (Heafield et al., 2013).</S>
			<S sid ="226" ssid = "38">Word alignments are symmetrized using the grow-diag-final heuristics and we use standard settings to extract phrases and to estimate translation probabilities and lexical weights.</S>
			<S sid ="227" ssid = "39">For reordering we use the default distance-based distortion penalty and parameters are tuned using MERT (Och, 2003) with 200-best lists.</S>
			<S sid ="228" ssid = "40">Table 4 shows the performance of our SMT models given alignments from the different word alignment systems.</S>
			<S sid ="229" ssid = "41">The left-hand part of the table contains results when using full word forms for the word alignment systems, whereas the results in the right-hand part were obtained by removing any letters after the four first from each word, as a form of approximate stemming since all the languages in our evaluation are predominantly suffixing.</S>
			<S sid ="230" ssid = "42">Though seemingly very drastic, this method improves accuracy in most cases since data sparsity is a major problem for word alignment.</S>
			<S sid ="231" ssid = "43">Next we turn to the computational cost of the experiments just described, these are found in Table 5.</S>
			<S sid ="232" ssid = "44">In almost all cases, efmaral runs faster by a comfortable margin.</S>
			<S sid ="233" ssid = "45">The only exception is for the smallest dataset, RussianEnglish, where fast_align uses slightly less wall time (but still much more CPU time).</S>
			<S sid ="234" ssid = "46">This trend is also present in the alignment quality experiments in Section 5.1 with mostly smaller corpora, where efmaral is only faster for the largest corpus.3 3 Due to different computing environments, only four CPU cores were available per aligner in the SMT.</S>
			<S sid ="235" ssid = "47">experiments, versus 24 cores in the alignment quality experiments.</S>
			<S sid ="236" ssid = "48">142 R. Östling, J. Tiedemann Eﬃcient Word Alignment with MCMC (125–146) Table 4.</S>
			<S sid ="237" ssid = "49">Results from our SMT evaluation.</S>
			<S sid ="238" ssid = "50">The BLEU scores are the maximum over the Moses parameters explored for the given word alignment conﬁguration.</S>
			<S sid ="239" ssid = "51">Tr an sla tio n pa ir B L E U s c o r e N o s t e m m i n g 4 p r e f i x s t e m m i n g Cz ech En gli sh En gli sh Cz ec h Ge rm an En gli sh En gli sh Ge rm an Sp an ish En gli sh En gli sh Sp an ish Fr en ch En gli sh En gli sh Fr en ch Ru ssi an En gli sh En gli sh Ru ssi an ef m ar al giz a+ + fast_align 23.</S>
			<S sid ="240" ssid = "52">43 23.29 22.77 16.</S>
			<S sid ="241" ssid = "53">22 15.97 15.69 23.</S>
			<S sid ="242" ssid = "54">60 23.86 22.84 17.</S>
			<S sid ="243" ssid = "55">83 17.69 17.50 28.</S>
			<S sid ="244" ssid = "56">50 28.43 28.25 27.</S>
			<S sid ="245" ssid = "57">39 27.51 27.08 28.</S>
			<S sid ="246" ssid = "58">50 28.45 28.06 27.</S>
			<S sid ="247" ssid = "59">73 27.57 27.22 20.</S>
			<S sid ="248" ssid = "60">74 20.14 19.55 15.</S>
			<S sid ="249" ssid = "61">89 15.55 15.07 ef m ar al giz a+ + fast_align 23.</S>
			<S sid ="250" ssid = "62">58 23.57 23.44 16.</S>
			<S sid ="251" ssid = "63">11 15.96 15.88 23.</S>
			<S sid ="252" ssid = "64">54 23.80 23.08 17.</S>
			<S sid ="253" ssid = "65">77 17.70 17.65 28.</S>
			<S sid ="254" ssid = "66">57 28.69 28.20 27.</S>
			<S sid ="255" ssid = "67">49 27.49 27.08 28.</S>
			<S sid ="256" ssid = "68">69 28.67 28.33 27.</S>
			<S sid ="257" ssid = "69">66 27.71 27.16 20.</S>
			<S sid ="258" ssid = "70">96 20.65 20.38 16.</S>
			<S sid ="259" ssid = "71">17 16.13 15.77 Table 5.</S>
			<S sid ="260" ssid = "72">Timings from the word alignments for our SMT evaluation.</S>
			<S sid ="261" ssid = "73">The values are averaged over both alignment directions.</S>
			<S sid ="262" ssid = "74">For these experiments we used systems with 8-core Intel E52670 processors running at 2.6 GHz.</S>
			<S sid ="263" ssid = "75">Time (seconds) Tr an sla tio n pa ir St e m Wall CPU ef m ar al Wall CPU g i z a + + Wall CPU fast_ align Cz ech En gli sh no 3 0 3 4 6 2 13, 08 9 13, 08 3 4 6 5 1,7 59 Cz ech En gli sh ye s 2 3 3 3 6 1 12, 03 5 12, 03 3 3 1 1 1,2 00 Ge rm an En gli sh no 5 1 1 7 6 6 42, 07 7 41, 75 4 1,1 51 4,4 07 Ge rm an En gli sh ye s 3 7 7 5 5 8 43, 04 8 43, 02 3 8 1 3 3,1 15 Sp an ish En gli sh no 5 0 0 7 8 2 39, 04 7 39, 00 3 1,0 34 3,9 40 Sp an ish En gli sh ye s 3 4 6 5 2 5 38, 89 6 38, 86 6 7 5 8 2,9 11 Fr en ch En gli sh no 6 9 6 1,0 88 41, 69 8 41, 64 6 1,6 81 6,4 23 Fr en ch En gli sh ye s 3 8 3 5 8 3 40, 98 6 40, 90 7 8 0 5 3,1 01 Ru ssi an En gli sh no 1 2 2 2 0 6 3 5 8 3 3 5 8 1 1 0 7 3 8 2 Ru ssi an En gli sh ye s 8 7 1 5 1 3 1 4 8 3 1 4 3 7 8 2 9 2 143 PBML 106 OCTOBER 2016 6.</S>
			<S sid ="264" ssid = "76">Concluding remarks.</S>
			<S sid ="265" ssid = "77">We hope that the reader at this point is convinced that Bayesian alignment models with Markov Chain Monte Carlo inference should be the method of choice for researchers who need to align large parallel corpora.</S>
			<S sid ="266" ssid = "78">To facilitate a practical shift towards this direction, we have released the efmaral tool which the evaluations in this article show to be both accurate, computationally efficient, and useful as a component of practical machine translation systems.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
</PAPER>
