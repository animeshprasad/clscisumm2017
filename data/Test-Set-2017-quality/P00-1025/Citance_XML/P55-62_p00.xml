<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">In the present study a system have developed that uses the Successor Variety Stemming Algoritlnn to find stems for Arabic words.</S>
		<S sid ="2" ssid = "2">A corpus of 242 abstracts have obtained from the Saudi Arabian National Computer Conference.</S>
		<S sid ="3" ssid = "3">All of these abstracts involve computer science and information systems.</S>
		<S sid ="4" ssid = "4">The study have set out to discover whether the Successor Variety Stemming Algorithm technique with the Cutoff Method can be used for the Arabic Language or not.</S>
		<S sid ="5" ssid = "5">In addition, the Successor Variety Algorithrn have compared with the Cutoff and the Successor Variety with Entropy Method.</S>
		<S sid ="6" ssid = "6">Stemming is typically used in the hope of improving the accuracy of the search reducing the size of the index.</S>
		<S sid ="7" ssid = "7">The results of present research show that the Successor Variety Algorithm with the Cutoff Method is better than Successor Variety Algorithm with the Entropy Method.</S>
		<S sid ="8" ssid = "8">We have achieved an 84% level of correctness using the Cutoff Method, but a 64% level of correctness using the Entropy Method.</S>
		<S sid ="9" ssid = "9">These experiments were carried out using Visual Basic 6.0.</S>
		<S sid ="10" ssid = "10">Key words: Successor, entropy, cutoff, stem, suffixes, prefixes</S>
	</ABSTRACT>
	<SECTION title="INTRODUCTION" number = "1">
			<S sid ="11" ssid = "11">Word stemming is an important feature supported by present day indexing and search systems.</S>
			<S sid ="12" ssid = "12">The idea is to improve recall by automatic handling of word endings by reducing the words to their word roots, at the time of indexing and searching.</S>
			<S sid ="13" ssid = "13">Stemming broadens our results to include both word roots and word derivatives.</S>
			<S sid ="14" ssid = "14">It is commonly accepted that removal of word-endings (sometimes called suffix stripping) is a good idea; removal of prefixes can be useful in some subject domains.</S>
			<S sid ="15" ssid = "15">A stemming algorithm is an algorithm that converts a word to a related form.</S>
			<S sid ="16" ssid = "16">One of the simplest such transformations is the conversion of plurals to singulars.</S>
			<S sid ="17" ssid = "17">One example is Porter&apos;s Algorithm.</S>
			<S sid ="18" ssid = "18">The Porter Stemmer is a conflation stemmer developed by Martin Porter at the University of Cambridge in 1980.</S>
			<S sid ="19" ssid = "19">The Porter stemming algorithm (or &apos;Porter stemmer&apos;) is a process for removing the commoner morphological and inflexional endings from words in English.</S>
			<S sid ="20" ssid = "20">It is the most effective and widely used.</S>
			<S sid ="21" ssid = "21">stemmer for English Porter&apos;s Algorithm works based on the number of vowel characters that are followed by a consonant character in the stem.</S>
			<S sid ="22" ssid = "22">This number (the Measure) must be greater than one for the rule to be applied.</S>
			<S sid ="23" ssid = "23">One of the limitations of this algorithm is that it can only be applied to text in the English Language.</S>
			<S sid ="24" ssid = "24">Frequently, the user specifies a word in a query but only a variant of this word is present in a relevant document.</S>
			<S sid ="25" ssid = "25">This problem can be partially overcome with the substitution of stems for the words.</S>
			<S sid ="26" ssid = "26">A stem is the portion of a word that is left after the removal of its affixes (i.e., prefixes and suffixes).</S>
			<S sid ="27" ssid = "27">Stems are thought to be useful for improving retrieval performance, because they reduce variants of the same root word to a common concept.</S>
			<S sid ="28" ssid = "28">Furthermore, stemming has the secondary effect of reducing the size of the indexing structure because the number of distinct index terms is reduced.</S>
			<S sid ="29" ssid = "29">Many Web search engines do not adopt any stemming algorithm whatsoever.</S>
			<S sid ="30" ssid = "30">Frakes[ 1 distinguishes four types of stemming strategies: affix removal, table lookup, successor variety and n-grams.</S>
			<S sid ="31" ssid = "31">Table lookup consists simply of looking for the stem of a word in a table.</S>
			<S sid ="32" ssid = "32">Since such data is not readily available and might require considerable storage space, this type of stemming algorithm may not be practical.</S>
			<S sid ="33" ssid = "33">Successor variety stemming is based on the determination of morpheme bmmdaries, uses knowledge from structural linguistics and is more complex than an affix removal-stemming algorithm[2l.</S>
			<S sid ="34" ssid = "34">The goal of this study was to experiment with alternative stemming techniques using the successor variety approach.</S>
			<S sid ="35" ssid = "35">We all agree that a word in any language consists of a meaningful string of letters.</S>
			<S sid ="36" ssid = "36">An index in any language consists of a number of words in a related domain.</S>
			<S sid ="37" ssid = "37">A word may have nonstem letters in the beginning (prefix), in the middle (infix), or at the end (postfix) of the word.</S>
			<S sid ="38" ssid = "38">From the information retrieval point of view stemming is one technique to provide ways of finding morphological variants of search terms.</S>
			<S sid ="39" ssid = "39">It is used to improve retrieval effectiveness and to reduce the size of indexing files (Fig.</S>
			<S sid ="40" ssid = "40">1 ).</S>
			<S sid ="41" ssid = "41">Corresponding Author: Dr. Riyad AlShalabi, Yarrnouk University, Irbid, Jordan Email: shalabi@yu.edu.jo ----Conflation MethodsInform.</S>
			<S sid ="42" ssid = "42">Technol.</S>
			<S sid ="43" ssid = "43">J., 4 (I): 55 62, 2005 against the stemmer described by Dawsod 16l usi the Manual Automatic (stemmers ) Cranfi eld-I test collect ion.</S>
			<S sid ="44" ssid = "44">Katzer et al. [i sJ examin ed the perfor mance of stemm ed title abstrac t term s against six other docum ent represe ntation s. Karen et a/Y 9l did a throug h review and study of stemmi ng algorit hms.</S>
			<S sid ="45" ssid = "45">[ 2 0 l Aflx Successor Table n-gram Harman used three stemmers-Porter, Lovins and S Longest match Removal Simple removal Variety look upremoval on three databases -Cranfield 1400, Medlars and CACM and found that none of them sig nificantly improved retrieval effectivene ss in a IR system called IRX that ranks its output in order of relevance.</S>
			<S sid ="46" ssid = "46">The latest natural lang uage research focuses on building systems for the Arabic language with high Fig.</S>
			<S sid ="47" ssid = "47">1: Taxonomy of stemming algorithms[3l We set out to test the Successor Variety Algorithm, which determines word and morpheme boundaries based on the distribution of phonemes in a large body of utterances.</S>
			<S sid ="48" ssid = "48">The successor variety of a string is the number of different characters that follow it in words in some body of text.</S>
			<S sid ="49" ssid = "49">Successor variety stemmers[4l are based on work in structural ling uistics, which attempts to determine word and morpheme bmmdaries based on the distribution of phonemes in a large body of utterances[5l_ A stemming algorithm is a computational procedure that seeks to reduce all words with the same stem to a commod5l . Several algorithms have been developed to handle stems in E lish.</S>
			<S sid ="50" ssid = "50">Dar wish[6l presents a good technique with an accuracy of92.7% on 9,606 words.</S>
			<S sid ="51" ssid = "51">He stripped away the prefix and suffix.</S>
			<S sid ="52" ssid = "52">Beesleyl7l presents a finite-state morphological analyzer for Arabic, which displays the root, pattern and prefixes/suffixes.</S>
			<S sid ="53" ssid = "53">The analyses are based on manually acquired lexicons and rules.</S>
			<S sid ="54" ssid = "54">Although his analyzer is comprehensive in the types of knowledge it presents, it has been criticized for its extensive development time and lack of robustness[6l.</S>
			<S sid ="55" ssid = "55">Most stemmers currently in use are iterative longest match stemmers, a kind of affix removal stemmer first developed performance and results relevant to the user needs.</S>
			<S sid ="56" ssid = "56">This gave rise to the idea of our project, to develop a system dealing with Arabic words.</S>
			<S sid ="57" ssid = "57">The system has been built based on the Successor Variety Stemming Algorithm, which determine the successor variety for a word, then uses this information to segment the word.</S>
			<S sid ="58" ssid = "58">We use the cutoff and entropy methods in our system to observe the effects of the successor variety approach on text in the Arabic L ang uage and to discover whether it can be useful for special purposes for Arabic language applications.</S>
			<S sid ="59" ssid = "59">Successor variety algorithm: The successor variety of a string is the number of different characters that fo llow it in words in some body of text.</S>
			<S sid ="60" ssid = "60">The successor variety of substrings of a term will decrease as more characters are added lllltil a segment boundary is reached[2l.</S>
			<S sid ="61" ssid = "61">Successor variety stemmers[4l are based on work in str uctural linguistics, which attempted to determine word and morpheme bolllldaries based on the distribution of phonemes in a large body of text.</S>
			<S sid ="62" ssid = "62">The stemming method based on this work uses letters in place of phonemically transcribed utterances.</S>
			<S sid ="63" ssid = "63">When this process is carried out using a large body of text, Hafer and Weiss[4l report 2000 terms to be a stable number), the successor variety of substrings of a term will decrease as more characters are added until a segment by Lovins[sJ.</S>
			<S sid ="64" ssid = "64">Increasi interest in the development of bolllldary is reached.</S>
			<S sid ="65" ssid = "65">At this point, the successor variety stemming algorithms has appeared for languages such as the Arabic language.</S>
			<S sid ="66" ssid = "66">The most notable of the efforts in this context are those reported by many authors[5•912J_ In addition to Lovins[sJ , iterative longest match stemmers have been reported by many authors[ 13 16l_ There have been many experimental evaluations of stemmers.</S>
			<S sid ="67" ssid = "67">Salton and Ymmg[3l examined the relative retrieval performance of fully stemmed terms against terms with only the suffix &quot;s&quot; removed.</S>
			<S sid ="68" ssid = "68">Hafer and Weiss[4l tested their stemmer against other stemming methods using the ADI collection and the Carolina Population Center (CFC) collection consisting of 75 documents and five queries.</S>
			<S sid ="69" ssid = "69">Van Rijsbergen[ 17l tested their stemmer[ 14l will sharply increase.</S>
			<S sid ="70" ssid = "70">This information is used to find the stem.</S>
			<S sid ="71" ssid = "71">When the successor varieties for a given word have been derived, the information must be used to segment the word.</S>
			<S sid ="72" ssid = "72">Hafer and Weiss[4l discuss four ways of doing this: 1.</S>
			<S sid ="73" ssid = "73">The cutoff method (this is the method we apply in.</S>
			<S sid ="74" ssid = "74">our work): • Some cutoff value (Threshol d) is selected for successor varieties and a bolllld ary is reached.</S>
			<S sid ="75" ssid = "75">• The problem with this method is that if the threshold value selected is too small, incorrect cuts will be made; if it is too large, correct cuts will missed.</S>
	</SECTION>
	<SECTION title="Peak and plateau  method.. " number = "2">
			<S sid ="76" ssid = "1">• A segment break is made after a character whose Table 1: Successor variety stem process Prefix Successor variety Letters successor variety exceeds that of the character immediately preceding it and the character immediately following it.</S>
			<S sid ="77" ssid = "2">• This method does not suffer from the problem of the cutoff method.</S>
			<S sid ="78" ssid = "3">R RE REA READ READA READAB READABL</S>
	</SECTION>
	<SECTION title="E,I, 0" number = "3">
			<S sid ="79" ssid = "1">2 A.D 1 D 3 A, I, S B L E 3.</S>
			<S sid ="80" ssid = "2">Complete word method.</S>
			<S sid ="81" ssid = "3">• A break is made after a segment if the segment is a complete word in the corpus.</S>
			<S sid ="82" ssid = "4">our experiments) • Takes advantage of the distribution of successor variety letters.</S>
			<S sid ="83" ssid = "5">The method works as follows: • Let I D&quot;,l be the number of words in a text body beginning with the i length sequence of letters a. • Let ID&quot;&apos;&apos;I the number of words in ID&quot;,I with the successor j computed in step one.</S>
			<S sid ="84" ssid = "6">• The probability that a word has the successor j is given by: READABLE (!ll&gt;mk) Peak and plateau method • break at the character whose successor variety is greater than both its preceding and following character READ I ABLE Complete word method • break is made if the segment is a complete word in the corpus (READ) Entropy method • for i = 2, a = RE, P&quot;&apos;I = 5 • forj =&apos;A&apos;, P&quot;,1l = 4 • forj= &apos;D&apos;, P&quot;,1l = 1 • The entropy of I Dm I is: I Dm, I IDm I Hm = :f: _I Dm1 l·log) Dm1 I IDml IDml • a cutoff value is selected and a bormdary is identified whenever the cutoff value reached A set of the above measures for predecessors can also be defined similarly.</S>
			<S sid ="85" ssid = "7">In summary, the successor variety stemming process has 3 parts: 1.</S>
			<S sid ="86" ssid = "8">Determine the successor varieties of a word..</S>
			<S sid ="87" ssid = "9">2.</S>
			<S sid ="88" ssid = "10">Use this information to segment the word using one.</S>
			<S sid ="89" ssid = "11">of the methods above.</S>
			<S sid ="90" ssid = "12">3.</S>
			<S sid ="91" ssid = "13">Select one of the segments as a stem..</S>
			<S sid ="92" ssid = "14">The aim of Hafer and Weiss[4 J was to develop a stemmer that required little or no human processing.</S>
			<S sid ="93" ssid = "15">Full English Example Test Word: READABLE Corpus: ABLE, APE, BEATABLE, FIXABLE, READ, READABLE, READING, READS, RED, ROPE, RIPE The successor variety stem process is sho\Vll m Table 1.</S>
			<S sid ="94" ssid = "16">Cutoff method • segment when successor variety&gt;= threshold • consider threshold2 RIEIADIABLE • Hotf1/5 * log2(1/5)- 4/5 * log2(4/5)0.46+0.26 0.72 This value is low because &quot;REA ..</S>
			<S sid ="95" ssid = "17">&quot; appears four times!</S>
			<S sid ="96" ssid = "18">Our methodology Steps: The input data consists of a corpus of words and a reverse of each word.</S>
			<S sid ="97" ssid = "19">Step one: Determine the successor varieties for a word.</S>
			<S sid ="98" ssid = "20">Take a word from the corpus and name it FW ord and call the reverse RevWord: 1.</S>
			<S sid ="99" ssid = "21">(For Successor) Starting from ;1 to length of the FWord: a. For the rightmost i letters inFWord: 1.</S>
			<S sid ="100" ssid = "22">Cormt the number of letters in the corpus that.</S>
			<S sid ="101" ssid = "23">follow the first ith right most letters of FW ord.</S>
			<S sid ="102" ssid = "24">11.</S>
			<S sid ="103" ssid = "25">Store the successor value from the above step in.</S>
			<S sid ="104" ssid = "26">a list called SucList.</S>
			<S sid ="105" ssid = "27">2.</S>
			<S sid ="106" ssid = "28">(For Predecessor) Starting from j length of the RevWord: a. For the rightmost}letters inRevWord: 1.</S>
			<S sid ="107" ssid = "29">Cormt the number of letters in the Reversed.</S>
			<S sid ="108" ssid = "30">corpus that follow the firstjth right most letters ofRevWord.</S>
			<S sid ="109" ssid = "31">11.</S>
			<S sid ="110" ssid = "32">Store the Predecessor value from the above step.</S>
			<S sid ="111" ssid = "33">in a list calledPrdList.</S>
			<S sid ="112" ssid = "34">Step two: Use this information to segment the word using: 1.</S>
			<S sid ="113" ssid = "35">Cutoff method.</S>
			<S sid ="114" ssid = "36">a. Segmentation Process for Successor: 1.</S>
			<S sid ="115" ssid = "37">Set a variable namedSegSuc of type string..</S>
			<S sid ="116" ssid = "38">n. For each character at position kin the Fword 1.</S>
			<S sid ="117" ssid = "39">if the corresponding Successor value for k is greater than or equal to the threshold value (11) then add the contents of SegSuc to the list SucSegList and empty it.</S>
			<S sid ="118" ssid = "40">2.</S>
			<S sid ="119" ssid = "41">else add the character at position k to SegSuc.</S>
			<S sid ="120" ssid = "42">111.</S>
			<S sid ="121" ssid = "43">If the length of SegSuc is greater than zero, then.</S>
			<S sid ="122" ssid = "44">add its contents to SucSegList and empty it b. Segmentation Process for Predecessor: 1.</S>
			<S sid ="123" ssid = "45">Set a variable named SegPre of type string..</S>
			<S sid ="124" ssid = "46">n. For each character at position f in the Revword 111.</S>
			<S sid ="125" ssid = "47">if the corresponding Successor value for f is greater than or equal to the threshold value (16) then add the contents of SegPre to the list PreSegList and empty it.</S>
			<S sid ="126" ssid = "48">IV.</S>
			<S sid ="127" ssid = "49">else add the character at position f to SegPre.</S>
			<S sid ="128" ssid = "50">v. If the length of SegPre is greater than zero, then add its contents toPreSegList and empty it.</S>
			<S sid ="129" ssid = "51">Entropy method: 1.</S>
			<S sid ="130" ssid = "52">for each word in the corpus we find the following 1.</S>
			<S sid ="131" ssid = "53">I D&quot;&apos;I The number of words in a text body beginning with the i length sequence of letters a in FWord is computed and stored in step one.</S>
			<S sid ="132" ssid = "54">n. I D&quot;&apos;I The number of words in Dcxi with the successor}is computed in step one.</S>
			<S sid ="133" ssid = "55">111.</S>
			<S sid ="134" ssid = "56">The probability that a word has the successor.</S>
			<S sid ="135" ssid = "57">j is given by The entropy of I Dm I is: I Dm, I IDml Hm = :f: _I Dm1 l·log) Dm1 I ,_, I Dm I I Dm I The entropy value, calculated for each letter in the word, store the result in a list called SucEntl ist Repeat this step for predecessors and store the resulting values in a list calledPreEntl ist.</S>
			<S sid ="136" ssid = "58">c. Segmentation Process for Entropy Successor: 1.</S>
			<S sid ="137" ssid = "59">Set a variable named SegSucEnt of type string..</S>
			<S sid ="138" ssid = "60">11.</S>
			<S sid ="139" ssid = "61">For each character at position min the Fword.</S>
			<S sid ="140" ssid = "62">1.</S>
			<S sid ="141" ssid = "63">if the corresponding Successor value form is greater than or equal to the threshold value (2.</S>
			<S sid ="142" ssid = "64">7) then add the contents of d. Segmentation Process for Entropy Predecessor: 1.</S>
			<S sid ="143" ssid = "65">Set a variable namedSegPreEntoftype string..</S>
			<S sid ="144" ssid = "66">11.</S>
			<S sid ="145" ssid = "67">For each character at position n in the Revword.</S>
			<S sid ="146" ssid = "68">1.</S>
			<S sid ="147" ssid = "69">if the corresponding Successor value for n is greater than or equal to the threshold value (3.3) then add the contents of SegPreEnt to the list PreEntSegList and empty it.</S>
			<S sid ="148" ssid = "70">2.</S>
			<S sid ="149" ssid = "71">else add the character at position n to SegPreEnt.</S>
			<S sid ="150" ssid = "72">111.</S>
			<S sid ="151" ssid = "73">If the length of SegPreEnt is greater than zero,.</S>
			<S sid ="152" ssid = "74">then add its contents to PreEntSegList and empty it.</S>
			<S sid ="153" ssid = "75">Step three: Select one of the segments as the stem.</S>
			<S sid ="154" ssid = "76">For each segment in SucSegList do the following: 1.</S>
			<S sid ="155" ssid = "77">If the segment occurs less than 16 times m. words in the corpus then add this segment to the variable S1.</S>
			<S sid ="156" ssid = "78">For each segment inPreSegList do the following: 1.</S>
			<S sid ="157" ssid = "79">If the segment occurs less than 16 times m. words in the corpus then add this segment to the variable S2.</S>
			<S sid ="158" ssid = "80">For each segment in SucEntSegList do the following: 1.</S>
			<S sid ="159" ssid = "81">If the segment occurs less than 16 times m. words in the corpus then add this segment to the variable S3.</S>
			<S sid ="160" ssid = "82">For each segment inPreEntSegList do the following: 1.</S>
			<S sid ="161" ssid = "83">If the segment occurs in less than 14 times in.</S>
			<S sid ="162" ssid = "84">words in the corpus then add this segment to the variable S4.</S>
			<S sid ="163" ssid = "85">Step Four: The first stem is the intersection of S1 and S2 and Store in variable FirstStem.</S>
			<S sid ="164" ssid = "86">The entropy stem is the intersection of S3 and S4 and Store in variable EntropyStem.</S>
			<S sid ="165" ssid = "87">Step Five: Store the value of FirstStem in FWord and repeat steps One-to- Four using the new FWord, the resulting word is called SecondStem.</S>
			<S sid ="166" ssid = "88">Step Six: If the length of the SecondS/em is less than the length of FirstStem then take the SecondStem as the stem.</S>
			<S sid ="167" ssid = "89">else select either of them as a stem.</S>
			<S sid ="168" ssid = "90">11 SegSucEnt to the list SucEntSegList and Example: The word &quot; 4wWI is inserted in the text empty it.</S>
			<S sid ="169" ssid = "91">2.</S>
			<S sid ="170" ssid = "92">else add the character at position m to SegSucEnt.</S>
			<S sid ="171" ssid = "93">111.</S>
			<S sid ="172" ssid = "94">If the length of SegSucEnt is greater than zero,.</S>
			<S sid ="173" ssid = "95">then add its contents to SucEntSegList and empty it box.</S>
			<S sid ="174" ssid = "96">&quot;When the button labeled find, in the main form of our application, is pressed the program will perform the following steps: Step one: Determine the successor varieties for this word: II II FW ord assigned to and reverse it as RevWord &quot; t:;&quot; I.</S>
			<S sid ="175" ssid = "97">(For Successor) Starting from ;] to length of the FWord(8): -At i=l the system searches the corpus and finds that, there are 16letters following the ith segment and this is the successor variety we look for..</S>
			<S sid ="176" ssid = "98">The Table 2 shows the successor variety for all ith segments: Table 2: Successor variety for ith segments I Segment Successor Letters 16 {••.o} 2 26 {, LP,,_p,,U&quot;,J ,J ,t ,c_ ,rz , ,.::.,&apos;&quot;&quot;&apos;I ,Is ,-ArJr, J,3&gt; ,t,t,..h,_h,oL&gt;} 3 6 {J,&apos;-&apos;&quot;&quot;,J,J,rz,l}</S>
	</SECTION>
	<SECTION title="WI 	{ }. " number = "4">
			<S sid ="177" ssid = "1">7 2.</S>
			<S sid ="178" ssid = "2">else add the character at position k to SegSuc.</S>
			<S sid ="179" ssid = "3">v1.</S>
			<S sid ="180" ssid = "4">If the length of SegSuc is greater than zero, then add its contents to SucSegList and empty it The system will segment the word into three parts, the SucSegList looks like this: Segment Successor 16 &gt;= 11 26 &gt;= 11 6&lt; 11 b. Segmentation Process for Predecessor: vii.</S>
			<S sid ="181" ssid = "5">Set a variable named SegPre of type string.</S>
			<S sid ="182" ssid = "6">viii.</S>
			<S sid ="183" ssid = "7">For each character at position f in the Revword IX.</S>
			<S sid ="184" ssid = "8">if the corresponding Successor value for f is greater than or equal to the threshold value (16) 6 {I} ....., {c.} 8 Bl&gt;mk.</S>
			<S sid ="185" ssid = "9">Store the successor value from the above step in a list called SucList.</S>
			<S sid ="186" ssid = "10">2.</S>
			<S sid ="187" ssid = "11">(For Predecessor) Starting from j Jength of the RevW ord (8): For the rightmost}letters inRevWord: Cmmt the number of letters in the Reversed corpus that follow the firstjth rightmost letters of RevWord.</S>
			<S sid ="188" ssid = "12">-Atj=l the system searches the reversed corpus and finds that, there are 16 letters following the jth segment and this is the predecessor variety we look for.</S>
			<S sid ="189" ssid = "13">The Table 3 below shows the predecessor variety for all jth segments.</S>
			<S sid ="190" ssid = "14">Table 3: Predecessor variety for all ;th segments I Segment Predecessor Letters 1 .0 16 { ,-..</S>
			<S sid ="191" ssid = "15">,.,lJ,i&apos;&quot;,J, ,J,t,&lt;Y&quot;,,_;,,J,t,c,u,l} 2 17 { &quot;&apos;&apos;•,u&apos;i&apos;&quot;&apos;J,,J,--il,bt,oL&gt;,J,J,c,rz,&quot;&quot;} 3 yO 3 {-..</S>
			<S sid ="192" ssid = "16">,LJ,&lt;Y&apos;} 4 &quot;&quot;&quot; {I} 6 {J} 7 J-L.,O {I} 8 &quot;&quot;&apos;&quot;&apos;&apos; {Blank} Store the Predecessor value from the above step in a list calledPrdLisl.</S>
			<S sid ="193" ssid = "17">Step two: Use the information above to segment the word usmg: I. cutoff method a. Segmentation Process for Successor: IV.</S>
			<S sid ="194" ssid = "18">Set a variable Named SegSuc of type string.</S>
			<S sid ="195" ssid = "19">v. For each character at position kin the Fword 1.</S>
			<S sid ="196" ssid = "20">if the corresponding Successor value for k is greater than or equal to the threshold value (II) then add the contents of SegSuc to the list SucSegList and empty it.</S>
			<S sid ="197" ssid = "21">then add the contents of SegPre to the list PreSegList and empty it.</S>
			<S sid ="198" ssid = "22">x. else add the character at position fto SegPre.</S>
			<S sid ="199" ssid = "23">x1.</S>
			<S sid ="200" ssid = "24">If the length of SegPre is greater than zero, then add its contents toPreSegList and empty it.</S>
			<S sid ="201" ssid = "25">The system will segment the word into three parts, thePreSegListlooks like this: Segment Predecessor .::.</S>
			<S sid ="202" ssid = "26">16&gt;-16 I 17&gt;=11 t......y 3&lt;11 2.</S>
			<S sid ="203" ssid = "27">Entropy method: for each segment.</S>
			<S sid ="204" ssid = "28">Find the frequency of each letter after the ith most right segment in FWORD When i=l, find the frequency of each letter that follow &quot;1&quot;.</S>
			<S sid ="205" ssid = "29">Find the sum of all the letters., Here the sum is 230.</S>
			<S sid ="206" ssid = "30">For each letter: Table 4: Frequency of each letter after the ith most right segment in FWORD Letter Frequency Entropyx formula Entropyx value .0 41*(4/230)*logl4/230) -0.010166 2 c 21*(2/230)*logl2/230) -5.9526e2 3 t -1*(11230)*loglll230) -3.411082e2 4 21*(2/230)*logl2/230) -5.9526e2 51*(11230)*loglll230) -3.411082e2 6 81*(8/230)*logl8/230) -0.16850 7 ..;.</S>
			<S sid ="207" ssid = "31">21*(2/230)*logl2/230) -5.9526e2 8 21*(2/230)*logl2/230) -5.9526e2 9 t 21*(2/230)*logl2/230) -5.9526e2 10 J -1*(11230)*loglll230) -3.411082e2 11 J 1891*(189/230)*logl189/230) -0.2327 12 31*(3/230)*logl3/230) -8.1659e2 13 u 51*(5/230)*logl5/230) -0.12007 14 11*(11230)*lo&amp;(ll230) -3.411082e2 15 51*(5/230)*lo&amp;(5/230) -0.12007 16 21*(2/230)*logl2/230) -5.9526e2 Sum 230 1.318368 • When i=2, find the frequency of each letter that follows &quot;Jl&quot;.</S>
			<S sid ="208" ssid = "32">Find the sum of all the letters.</S>
			<S sid ="209" ssid = "33">Here the sum is 189.</S>
			<S sid ="210" ssid = "34">For each letter.</S>
			<S sid ="211" ssid = "35">• When i=3, find the frequency of each letter that • When j=4, find the frequency of each letter that follows t ;11 in reverse corpus.</S>
			<S sid ="212" ssid = "36">Find the sum of all the letters (sum of all words with this segment).</S>
			<S sid ="213" ssid = "37">Here the sum is 2.</S>
			<S sid ="214" ssid = "38">follows &quot;c;ll&quot;.</S>
			<S sid ="215" ssid = "39">Find the sum of all the letters Here the sum is 9.</S>
			<S sid ="216" ssid = "40">For each letter • When i=4, find the frequency of each letter that Letter Frequency EntropYx formula EntropYx value 21*(2/2)*logl2/2) 0 follows &quot;WI&quot;.</S>
			<S sid ="217" ssid = "41">Find the sum of all the letters.</S>
			<S sid ="218" ssid = "42">Here the sum is 2.</S>
			<S sid ="219" ssid = "43">For each letter Letter Frequency Entrop)&apos;x formula Entropy&quot; value 21*(2/2)*logl2/2) 0 Sum 2 0 • When j=5, find the frequency of each letter that follows 11 l:i11 in the reverse corpus.</S>
			<S sid ="220" ssid = "44">Find the sum of all the letters.</S>
			<S sid ="221" ssid = "45">Here the sum is 2.</S>
			<S sid ="222" ssid = "46">Sum 2 0 Letter Frequency EntropYx formula EntropYx value • When i=5, find the frequency of each letter that c 21*(2/2)*lo&amp;(212) 0 follows &quot;u.uWI&quot;.</S>
			<S sid ="223" ssid = "47">Find the sum of all the letters.</S>
			<S sid ="224" ssid = "48">Here the sum is 2.</S>
			<S sid ="225" ssid = "49">For each letter Letter Frequency Entrop)&apos;x formula Entropy&quot; value Sum 2 0 • When j=6, find the frequency of each letter that follows 11 c.L.&amp;yt:i 11 in the reverse corpus.</S>
			<S sid ="226" ssid = "50">Find the sum of all the letters.</S>
			<S sid ="227" ssid = "51">Here the sum is 1.</S>
			<S sid ="228" ssid = "52">21*(2/2)*logl2/2) 0 Sum 2 0 Letter Frequency Entrop)&apos;x formula Entrop)&apos;x value • When i=6, find the frequency of each letter that follows LJI &quot;F. ind the sum of all the letters.</S>
			<S sid ="229" ssid = "53">Here Sum J -1*(111)*lo&amp;(ll1) 0 0 the sum is 1.</S>
			<S sid ="230" ssid = "54">For each letter Letter Frequency Entrop)&apos;x formula Entropy&quot; value • When j=7, find the frequency of each letter that follows L.a:tl:i 11 in the reverse corpus.</S>
			<S sid ="231" ssid = "55">Find the sum of all the letters.</S>
			<S sid ="232" ssid = "56">Here the sum is 1.</S>
			<S sid ="233" ssid = "57">-1*(111)*loglll1) 0 Sum 0 • When i=7, find the frequency of each letter that follows 11 WI11 • Find the sum of all the letters Here the sum is 1.</S>
			<S sid ="234" ssid = "58">For each letter Letter Frequency Entropyx formula Entropyx value -1*(111)*log2(111) 0 Letter Frequency Entrop)&apos;x formula Entrop)&apos;x value -1*(111)*loglll1) 0 Sum 0 • When j=8, find the frequency of each letter that follows 11 l...u:tl:i 11 in the reverse corpus.</S>
			<S sid ="235" ssid = "59">Find the sum of all the letters.</S>
			<S sid ="236" ssid = "60">Here the sum is 1.</S>
			<S sid ="237" ssid = "61">Sum 0 Letter Frequency Entrop)&apos;x formula Entrop)&apos;x value • When i=8, find the frequency of each letter that follows&quot; .: WI&quot;.Find the sum of all the letters.</S>
			<S sid ="238" ssid = "62">A ssume that the sum is 1.</S>
			<S sid ="239" ssid = "63">Find the frequency of each letter after the ith most right segment inRevWORD • When j=1, find the frequency of each letter that follows 11 ..:::..</S>
			<S sid ="240" ssid = "64">11 in the reverse corpus.</S>
			<S sid ="241" ssid = "65">Find the sum of all the letters (sum of all words with this segment).</S>
			<S sid ="242" ssid = "66">Here the sum is 74.</S>
			<S sid ="243" ssid = "67">• When j=2, find the frequency of each letter that follows 11 t:;&quot; in the reverse corpus.</S>
			<S sid ="244" ssid = "68">Find the sum of all the letters (sum of all words with this segment).</S>
			<S sid ="245" ssid = "69">Here the sum is 54.</S>
			<S sid ="246" ssid = "70">• When j=3, find the frequency of each letter that follows 11 yl:i 11 in the reverse corpus.</S>
			<S sid ="247" ssid = "71">Find the sum of all the letters.</S>
			<S sid ="248" ssid = "72">Here the sum is 5.</S>
			<S sid ="249" ssid = "73">-1*(111)*lo&amp;(ll1) 0 Sum 0 Segmentation Process for Entropy Successor: 1.</S>
			<S sid ="250" ssid = "74">Set a variable named SegSucEnt of type string..</S>
			<S sid ="251" ssid = "75">n. For each character at position min the Fword 1.</S>
			<S sid ="252" ssid = "76">if the corresponding Successor value for m is greater than or equal to the threshold value (2.7) then add the contents of SegSucEnt to the list SucEntSegList and empty it.</S>
			<S sid ="253" ssid = "77">2.</S>
			<S sid ="254" ssid = "78">else add the character at position m to SegSucEnt.</S>
			<S sid ="255" ssid = "79">The following table shows the SucEntSegList Segment Successor entropy 4.0219 2.7 2 2.41938&lt;2.7 Segmentation Process for Entropy Predecessor: 1.</S>
			<S sid ="256" ssid = "80">Set a variable Named SegPreEnt of type string..</S>
			<S sid ="257" ssid = "81">11.</S>
			<S sid ="258" ssid = "82">For each character at position n in the Revword.</S>
			<S sid ="259" ssid = "83">1.</S>
			<S sid ="260" ssid = "84">if the corresponding Successor value for n is greater than or equal to the threshold value (3.3) then add the contents of SegPreEnt to the hstPreEntSegList and empty it.</S>
			<S sid ="261" ssid = "85">Step four: • The first stem is the intersection of S1 and S2 and Store in variable FirstStem.</S>
			<S sid ="262" ssid = "86">S1 is &quot; 6:&apos; and S2 is &quot; ...,.....wt &quot;.</S>
			<S sid ="263" ssid = "87">The intersection is &quot; Y-&apos;Mb.&apos;&apos; • The first stem is the intersection of S3 and S4 and Store in variable EntropyStem.</S>
			<S sid ="264" ssid = "88">S3 is &quot; 4--ub.&quot; and S4 2.</S>
			<S sid ="265" ssid = "89">else add the character at position n to SegPreEnt.</S>
			<S sid ="266" ssid = "90">111.</S>
			<S sid ="267" ssid = "91">If the length of SegPreEnt is greater than zero,.</S>
			<S sid ="268" ssid = "92">then add its contents to PreEntSegList and is &quot; WI&quot;.</S>
			<S sid ="269" ssid = "93">The intersection is &quot; l.:t..</S>
			<S sid ="270" ssid = "94">is the stem.</S>
			<S sid ="271" ssid = "95">Step five: a&quot; nd this empty it The following table shows PreEntSegLis: Step three: now, we attempt to select one of the segments as the stem: 1.</S>
			<S sid ="272" ssid = "96">For each segment inSucSegList do the following:.</S>
			<S sid ="273" ssid = "97">If the segment occurs less than 16 times in words in the corpus then add this segment to the variable Sl.</S>
			<S sid ="274" ssid = "98">The comparison is shown: Segment Occurs in Comapison Store the value of FirstStem=&quot; k..&quot; in FWord and repeat steps One-to- Four using new FWord, the resulted word called SecondStem = &quot; y..u &apos;.</S>
			<S sid ="275" ssid = "99">The result will be the same.</S>
			<S sid ="276" ssid = "100">Step Six: The length of the SecondStem( 4) is equal to the length of FirstStem Then we can select any one of them.</S>
			<S sid ="277" ssid = "101">The stem produced as &quot; y..wand this is correct.</S>
			<S sid ="278" ssid = "102">The implementation: 1 2 J 3 .:0 ThevalueifSl is&quot; &quot;&quot;4uotll..</S>
			<S sid ="279" ssid = "103">230 50 1 23016 50= 16 1 &lt; 16 We have implemented this algorithm using the well­ kno\Vll programming language Visual Basic version 6.0.</S>
			<S sid ="280" ssid = "104">The purpose behind using this programming language is that it is easy to use, it facilitates the construction of an 2.</S>
			<S sid ="281" ssid = "105">For each segment inPreSegList do the following:.</S>
			<S sid ="282" ssid = "106">If the segment occurs less than 16 times in words in the reverse corpus then add this segment to the variable S2.</S>
			<S sid ="283" ssid = "107">Segment Occurs in Comapison 3 1 1 &lt; 16 The value of S2 is reverse of&quot; t....., &quot; that is &quot; ..,.....wt &quot; 3.</S>
			<S sid ="284" ssid = "108">For each segment in SucEntSegList do the.</S>
			<S sid ="285" ssid = "109">following: attractive user interface for our system and there are many manuals that describe the features of this language.</S>
			<S sid ="286" ssid = "110">We focus mainly on the features dealing with the Arabic Language, also the ability to write applications that use an Arabic database.</S>
			<S sid ="287" ssid = "111">For our database, we used Microsoft Access 97 for storing and accessing the Arabic corpus.</S>
			<S sid ="288" ssid = "112">It is a good database engine and easy to learn and use.</S>
			<S sid ="289" ssid = "113">Table 5: Computed stems for lists of words that share the same root Computed stem Correct or Computed stem Correct or Test word cutoff method not correct entropy method not correct ._WI ..,....t..</S>
			<S sid ="290" ssid = "114">Correct ..,....t..</S>
			<S sid ="291" ssid = "115">Correct 4-o--6..11 .......</S>
			<S sid ="292" ssid = "116">Correct .......</S>
			<S sid ="293" ssid = "117">Correct the corpus then add this segment to the variable S3.</S>
			<S sid ="294" ssid = "118">yt-.11 y!....</S>
			<S sid ="295" ssid = "119">Correct yl....</S>
			<S sid ="296" ssid = "120">Correct Correct ......</S>
			<S sid ="297" ssid = "121">Correct &quot;.&apos;.&quot;.&quot;.&quot;&apos;&quot; ......</S>
			<S sid ="298" ssid = "122">..:o L......JI_, yl....</S>
			<S sid ="299" ssid = "123">Correct y!....</S>
			<S sid ="300" ssid = "124">Correct Jl 189 18916 tIt, ..,....t..</S>
			<S sid ="301" ssid = "125">Correct Incorrect 2 t,....t....</S>
			<S sid ="302" ssid = "126">1 &lt; 16 ..........r..,a.Jr ..,...(p Correct ......,,.... correct The value if S3 is &quot; l,....t.ll.</S>
			<S sid ="303" ssid = "127">4.</S>
			<S sid ="304" ssid = "128">For each segment in PreEntSegList do the.</S>
			<S sid ="305" ssid = "129">,..,_, ......</S>
			<S sid ="306" ssid = "130">Correct .,...._ Correct Correct ....- Correct Incorrect .,...t..</S>
			<S sid ="307" ssid = "131">Incorrect If the segment occurs less than 14 times in words in &quot;..&quot;..&quot;,&quot;,_&quot;&apos; ......</S>
			<S sid ="308" ssid = "132">Incorrect t b Incorrect the corpus then add this segment to the variable S4.</S>
			<S sid ="309" ssid = "133">..,....t..</S>
			<S sid ="310" ssid = "134">y..l.......</S>
			<S sid ="311" ssid = "135">Correct _y!......</S>
			<S sid ="312" ssid = "136">Correct Occurs in Comapison ., wr ......</S>
			<S sid ="313" ssid = "137">Correct Correct ..</S>
			<S sid ="314" ssid = "138">Correct.</S>
			<S sid ="315" ssid = "139">.- Incorrect ..,....t..</S>
			<S sid ="316" ssid = "140">Correct Incorrect The value of S4 is reverse of&quot; t...JI that is &quot; ...,.....LWt .,_L...Jt .,...t..</S>
			<S sid ="317" ssid = "141">Incorrect .,...t..</S>
			<S sid ="318" ssid = "142">Incorrect Inform.</S>
			<S sid ="319" ssid = "143">Techno!.</S>
			<S sid ="320" ssid = "144">J., 4 (I): 5562, 2005 EXPERIMENTS AND RESULTS we describe experiments done to test the correctness of our work.</S>
			<S sid ="321" ssid = "145">The results are shown in Table 5.</S>
			<S sid ="322" ssid = "146">CONCLUSIONS After applying these algorithms to 2000 Arabic words, we conclude that we can apply the Successor Variety Algorithm with the Cutoff Method to the Arabic Language since we have achieved an 80% level of correctness.</S>
			<S sid ="323" ssid = "147">On the other hand, we have achieved a 75% level of correctness by applying the Entropy Method.</S>
			<S sid ="324" ssid = "148">Several advantages of the Successor Variety Algorithm can be observed; the most important one is the ability to find a stem without the need to use a dictionary.</S>
			<S sid ="325" ssid = "149">Another advantage is that it can be used in several domains; it is basically (domain independent).</S>
	</SECTION>
			<S sid ="326" ssid = "150">1.</S>
			<S sid ="327" ssid = "151">Frakes, W., 1992.</S>
			<S sid ="328" ssid = "152">Stemming Techniques.</S>
			<S sid ="329" ssid = "153">Chapter 6.</S>
			<S sid ="330" ssid = "154">in Frakes and BaezaYates, 1992.</S>
			<S sid ="331" ssid = "155">2.</S>
			<S sid ="332" ssid = "156">Fox, C., 1992.</S>
			<S sid ="333" ssid = "157">Lexical Analysis and Stoplists.</S>
			<S sid ="334" ssid = "158">Chapter.</S>
			<S sid ="335" ssid = "159">5 in Frakes and BaezaYates, 1992.</S>
			<S sid ="336" ssid = "160">3.</S>
			<S sid ="337" ssid = "161">Salton G. and C.S. Yang, 1980.</S>
			<S sid ="338" ssid = "162">Contribution to the.</S>
			<S sid ="339" ssid = "163">Theory ofindexing.</S>
			<S sid ="340" ssid = "164">American Elsevier, New York, 1980.</S>
			<S sid ="341" ssid = "165">4.</S>
			<S sid ="342" ssid = "166">Hafer, M.A. and S.F. Weiss, 1974: Word.</S>
			<S sid ="343" ssid = "167">segmentation by letter successor varieties.</S>
			<S sid ="344" ssid = "168">Information Storage and Retrieval, 10: 371385.</S>
	</SECTION>
	<SECTION title="Mustafa  Suleiman and Qasem  Ahmad Al-Radaideh,. " number = "5">
			<S sid ="345" ssid = "1">2001.</S>
			<S sid ="346" ssid = "2">Arabic word stemming using letter successor and Predecessor Variety, ACIT 2001.</S>
	</SECTION>
	<SECTION title="Darwish,  K.,   2002.   Building    a   shallow   Arabic. " number = "6">
			<S sid ="347" ssid = "1">morphological analyzer in one day.</S>
			<S sid ="348" ssid = "2">Proceedings of the Workshop on Computational Approaches to Semitic Languages.</S>
			<S sid ="349" ssid = "3">ACL, Philadelphia, pp: 4754.</S>
	</SECTION>
	<SECTION title="Beesley, K. andL. Karttunen, 2000.  Finite-state non­ " number = "7">
			<S sid ="350" ssid = "1">concatenative morphotactics.</S>
			<S sid ="351" ssid = "2">Proceedings of the ACL, Hong Kong, pp: 191198.</S>
	</SECTION>
	<SECTION title="Lovins,    J.,   1968.   Development  of   a   stemming. " number = "8">
			<S sid ="352" ssid = "1">algorithm.</S>
			<S sid ="353" ssid = "2">Mechanical Translation and Computational Linguistics, 11: 2231.</S>
	</SECTION>
	<SECTION title="Al-Fedaghi, S. and F. Al-A=i, 1989. A new algorithm. " number = "9">
			<S sid ="354" ssid = "1">to generate Arabic root-pattern forms.</S>
			<S sid ="355" ssid = "2">In Proceedings of the 11th National Computer Conference and Exhibition, March, Dhahran, Saudi Arabia, pp: 0407.</S>
	</SECTION>
	<SECTION title="Al-Kharashi, I. and M.W. Evens, 1994.  Words,  stems. " number = "10">
			<S sid ="356" ssid = "1">and roots in an Arabic information retrieval system.</S>
			<S sid ="357" ssid = "2">J. American Soc.</S>
			<S sid ="358" ssid = "3">Inform.</S>
			<S sid ="359" ssid = "4">Sci.</S>
			<S sid ="360" ssid = "5">, 45: 548560.</S>
	</SECTION>
	<SECTION title="Al-Shalabi,  R.   and  M.W.   Evens,   1998.  A. " number = "11">
			<S sid ="361" ssid = "1">computational morphology system for Arabic computational approaches to semitic languages.</S>
			<S sid ="362" ssid = "2">Workshop, COLING 98, Montreal, Canada, pp: 5865.</S>
	</SECTION>
	<SECTION title="Khoja,  S., 1999.   Stemming  Arabic  text.  Lancaster,. " number = "12">
			<S sid ="363" ssid = "1">U.K., Computing Department, Lancaster University.</S>
			<S sid ="364" ssid = "2">www.</S>
			<S sid ="365" ssid = "3">comp.lancs.uk/ computing/userslkhoja/ stemmer.ps.</S>
	</SECTION>
	<SECTION title="Paik, W., 1994.  Chronological Information Extraction. " number = "13">
			<S sid ="366" ssid = "1">System (CIES), Dagstuhl-Seminar-Report: 79 on Summarizing Text for Intelligent Communication, EndresNiggemeyer, B., Hobbs, J. and Jones, K.S.</S>
			<S sid ="367" ssid = "2">(Eds.), Wadem, Germany: IBFI</S>
	</SECTION>
	<SECTION title="Porter, M.F., 1980.  An algorithm  for suffix stripping.. " number = "14">
			<S sid ="368" ssid = "1">Program, 14: 130137.</S>
	</SECTION>
	<SECTION title="Salton, G., 1968. Automatic Information Organization. " number = "15">
			<S sid ="369" ssid = "1">and Retrieval.</S>
			<S sid ="370" ssid = "2">New York, NY McGraw-Hill.</S>
	</SECTION>
	<SECTION title="Dawson, J.L.,  1974.  Suffix  removal   for  word. " number = "16">
			<S sid ="371" ssid = "1">conflation.</S>
			<S sid ="372" ssid = "2">Bulletin of the Association for Literary and Linguistic Computing, 2: 3346.</S>
	</SECTION>
	<SECTION title="Van  Rijsbergen, C.J.,  1979.  Information Retrieval.. " number = "17">
			<S sid ="373" ssid = "1">London, UK: Butterworths.</S>
	</SECTION>
	<SECTION title="Katzer,   J.,  M.J. McGill, J.A. Tessier, W. Frakes and. " number = "18">
			<S sid ="374" ssid = "1">P.</S>
			<S sid ="375" ssid = "2">DasGupta, 1982.</S>
			<S sid ="376" ssid = "3">A study of the overlap among document representations.</S>
			<S sid ="377" ssid = "4">Information Technology: Research and Development, 2: 261274.</S>
	</SECTION>
	<SECTION title="Karen,  S.J., S. Walker,  S.E. Robertson, 2000. A. " number = "19">
			<S sid ="378" ssid = "1">probabilistic model of information retrieval: A development and comparative experiments-Part 2.</S>
			<S sid ="379" ssid = "2">Inf.</S>
			<S sid ="380" ssid = "3">Process.</S>
			<S sid ="381" ssid = "4">Manage., 36: 809840.</S>
	</SECTION>
	<SECTION title="Harman,  D., 1991.   How  effective is  suffixing?  J.. " number = "20">
</PAPER>
